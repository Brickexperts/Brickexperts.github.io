<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[python常用模块（3）]]></title>
    <url>%2F2019%2F08%2F07%2Fpython%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97%EF%BC%883%EF%BC%89%2F</url>
    <content type="text"><![CDATA[textwrap用来重新格式化文本的输出 fill() 调整换行符,每行显示给定宽度 dedent()：去除缩进 indent():给定前缀 首行缩进： 多余的省略号：shorter() wrap():wrap(s,width) 以单词为单位(包括字符)最大长度不超过width个字符 itertoolsPython的内建模块itertools提供了非常有用的用于操作迭代对象的函数 count()会创建一个无限的迭代器，所以下述代码会打印出自然数序列，根本停不下来，只能按Ctrl+C退出。 cycle()会把传入的一个序列无限重复下去： repeat()负责把一个元素无限重复下去，不过如果提供第二个参数就可以限定重复次数： chain()可以把一组迭代对象串联起来，形成一个更大的迭代器： groupby()把迭代器中相邻的重复元素挑出来放在一起： 实际上挑选规则是通过函数完成的，只要作用于函数的两个元素返回的值相等，这两个元素就被认为是在一组的，而函数返回值作为组的key。如果我们要忽略大小写分组，就可以让元素’A’和’a’都返回相同的key： permutations():输出输入序列的全排列,考虑顺序 combinations():同上，不过不考虑顺序 product():输出输入序列的笛卡儿积 compress：可以对一个序列的筛选结果施加到另一个相关的序列上 dropwhile():筛选满足条件的元素 islice()： zip_longest：zip可产生元祖。当其中摸个输入序列中没有元素可以继续迭代时，迭代过程结束。所以整个迭代的长度和最短的输入序列相同。 如果不想这样就用zip_longest：]]></content>
      <categories>
        <category>python</category>
        <category>常用模块</category>
        <category>常用模块（3）</category>
      </categories>
      <tags>
        <tag>python常用模块</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python常用模块（2）]]></title>
    <url>%2F2019%2F08%2F07%2Fpython%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97%EF%BC%882%EF%BC%89%2F</url>
    <content type="text"><![CDATA[collection：collections是Python内建的一个集合模块，提供了许多有用的集合类。 namedtuple是一个函数，它用来创建一个自定义的tuple对象，并且规定了tuple元素的个数，并可以用属性而不是索引来引用tuple的某个元素。这样一来，我们用namedtuple可以很方便地定义一种数据类型，它具备tuple的不变性，又可以根据属性来引用，使用十分方便。 利用namedtuple定义和使用具名元祖：第一个参数为类名，第二个参数为类的各个字段的名字 具名元祖有些专用的属性：类属性_fields,类方法_make(),实例方法_asdict() 如果需要修改任何属性，可以通过使用nametupled实例的_replace方法来实现。该方法会创建按一个新的命名元祖，并对相应的值进行替换。 deque：是为了高效实现插入和删除操作的双向列表，适合用于队列和栈。deque(maxlen=N)创建一个固定长度的队列，当有新记录加入而队列已满时会自动移除最老的那条记录。 defaultdict:使用dict时，如果引用的Key不存在，就会抛出KeyError。如果希望key不存在时，返回一个默认值，就可以用defaultdict。defaultdict的一个特点就是会自动初始化第一个值。 用defaultdict的效率比不用高: OrderedDict 使用dict时，Key是无序的。在对dict做迭代时，我们无法确定Key的顺序。 如果要保持Key的顺序，可以用OrderedDict。 OrderDict的大小是普通字典的2倍多，这是由于它额外创建的链表所导致。 注意，OrderedDict的Key会按照插入的顺序排列，不是Key本身排序：OrderedDict可以实现一个FIFO（先进先出）的dict，当容量超出限制时，先删除最早添加的Key Counter：一个简单的计数器 计数器的更新包括增加和减少两种，增加使用update，减少用subtract。 most_common(x):根据x返回频率前x的项。 itemgetter：可以通过公共键对字典列表排序。 ChainMap：可接受多个映射然后再逻辑上是它们表现为一个单独的映射结构。如果有重复的键，那么会采用第一个映射中所对应的值。修改映射的操作总是会作用在列出的第一个映射结构上。 randomrandom.random() 产生0-1的随机浮点数 random.uniform(a, b) 产生指定范围内的随机浮点数 random.randint(a, b) 产生指定范围内的随机整数 random.randrange([start], stop[, step]) 从一个指定步长的集合中产生随机数 random.choice(sequence) 从序列中产生一个随机数 random.shuffle(x[, random]) 将一个列表中的元素打乱 random.sample(sequence, k) 从序列中随机获取指定长度的片断 functoolsreduce(function, sequence, value)：对sequence中的item顺序迭代调用function，如果有value，还可以作为初始值调用。function接收的参数个数只能为2，先把sequence中第一个值和第二个值当参数传给function，再把function的返回值和第三个值当参数传给function，然后只返回一个结果。 partial：基于一个函数创建一个新的可调用对象，把原函数的某些参数固定。 偏函数：只需要传一次值，后面想传就传]]></content>
      <categories>
        <category>python</category>
        <category>常用模块</category>
        <category>常用模块（2）</category>
      </categories>
      <tags>
        <tag>python常用模块</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python常用模块（1）]]></title>
    <url>%2F2019%2F08%2F07%2Fpython%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97%EF%BC%881%EF%BC%89%2F</url>
    <content type="text"><![CDATA[​ 这几年，python大火。其中的一个原因是python的库特别多，而且封装非常好。接下来我来总结以下我用过的一些库，虽然都不是很大的库，但还是有用的。 jsonjson主要执行序列化和反序列化的功能，通过Python的json模块，可以将字符串形式的json数据转化为字典，也可以将Python中的字典数据转化为字符串形式的json数据。 通过json字符串转为字典 json.loads 字典转换为json：json.dumps json.loads()、dumps解码python json格式 json.load、dump加载json格式文件 pickle使用方法与json一样 区别： json是可以在不同语言之间交换数据的，而pickle只在python之间使用。 json只能序列化最基本的数据类型，而pickle可以序列化所有的数据类型，包括类，函数都可以序列化。 hashlib该模块提供了常见的摘要算法。如MD5，SHA1……摘要算法又称哈希算法、散列算法，通过一个函数，把任意长度的数据转换为一个长度固定的数据串。 摘要算法是一个单向函数，通过摘要函数f()对任意长度的数据data计算出固定长度的摘要digest，目的是发现原始数据是否被改动过。计算f(data)很容易，但通过digest反推data却非常困难，对原始数据做一个字节的修改，都会导致计算出来的摘要不同。 stringstring.digits:包含数字0-9的字符串 string.letters:包含所有字母（大写或小写）的字符串 string.lowercase:包含所有小写字母的字符串 string.printable:包含所有可打印字符的字符串 string.punctuation:包含所有标点的字符串 string.uppercase:包含所有大写字母的字符串 string.ascii_letters和string.digits方法，其中ascii_letters是生成所有字母，从a-z和A-Z,digits是生成所有数字0-9. 词云 decimal如果期望获得更高的精度（并且愿意牺牲掉一些性能），可以使用decimal模块。 fractions模块可以用来处理涉及分数的数学计算问题 copy完成深拷贝和浅拷贝 is和==的区别：==是看值，is看是否指向同一个 浅拷贝：拷贝内容的地址 深拷贝：开发另一片空间存放要拷贝的内容 copy会判断数据类型是否为可变类型，如元祖为不可变类型，则只会完成浅拷贝。 fileinput可以快速对一个或多个文件进行循环遍历 fileinput.input([files[, inplace[, backup[, mode[, openhook]]]]]])功能:生成FileInput模块类的实例。能够返回用于for循环遍历的对象。注意:文件名可以提供多个 inplace：是否返回输出结果到源文件中，默认为零不返回。设置为1时返回。 backup：备份文件的扩展名 mode：读写模式。只能时读、写、读写、二进制四种模式。默认是读 openhook：必须是一个函数，有两个参数，文件名和模式。返回相应的打开文件对象 fileinput.filename()：返回当前正在读取的文件的名称。在读取第一行之前，返回None。 fileinput.fileno()：返回当前文件的整数“文件描述符”。如果没有打开文件（在第一行之前和文件之间），则返回-1。 fileinput.lineno()：返回刚读过的行的累计行号。在读取第一行之前，返回0。读取完最后一个文件的最后一行后，返回该行的行号。 fileinput.filelineno()：返回当前文件中的行号。在读取第一行之前，返回0。读取完最后一个文件的最后一行后，返回该文件中该行的行号。 fileinput.isfirstline()：如果刚刚读取的行是其文件的第一行，则返回true，否则返回false。 fileinput.isstdin()：如果读取了最后一行sys.stdin，则返回true，否则返回false。 fileinput.nextfile()：关闭当前文件，以便下一次迭代将读取下一个文件的第一行（如果有的话）; 未从文件中读取的行将不计入累计行数。直到读取下一个文件的第一行之后才会更改文件名。在读取第一行之前，此功能无效; 它不能用于跳过第一个文件。读取完最后一个文件的最后一行后，此功能无效。 fileinput.close()关闭序列 subprocess：subprocess模块可以让我们非常方便地启动一个子进程，然后控制其输入和输出。Popen()建立子进程的时候改变标准输入、标准输出和标准错误，并可以利用subprocess.PIPE将多个子进程的输入和输出连接在一起，构成管道(pipe) subprocess.call():父进程等待子进程完成，返回退出信息(returncode，相当于Linux exit code) subprocess.check_call():父进程等待子进程完成，返回0，检查退出信息，如果returncode不为0，则举出错误subprocess.CalledProcessError，该对象包含有returncode属性，可用try…except…来检查 subprocess.check_output():父进程等待子进程完成，返回子进程向标准输出的输出结果，检查退出信息，如果returncode不为0，则举出错误subprocess.CalledProcessError，该对象包含有returncode属性和output属性，output属性为标准输出的输出结果，可用try…except…来检查。 subprocess.Popen()，以下为参数： args：shell命令，可以是字符串，或者序列类型，如list,tuple。 bufsize：缓冲区大小，可不用关心 stdin,stdout,stderr：分别表示程序的标准输入，标准输出及标准错误 shell：与上面方法中用法相同 cwd：用于设置子进程的当前目录 env：用于指定子进程的环境变量。如果env=None，则默认从父进程继承环境变量 universal_newlines：不同系统的的换行符不同，当该参数设定为true时，则表示使用\n作为换行符 常用方法： poll() ： 检查子进程状态 kill() ： 终止子进程 send_signal() :向子进程发送信号 terminate() ： 终止子进程 communicate:从PIPE中读取PIPE的文本，该方法会阻塞父进程，直到子进程完成 常用属性：pid：子进程的pid，returncode：子进程的退出码。]]></content>
      <categories>
        <category>python</category>
        <category>常用模块</category>
        <category>常用模块（1）</category>
      </categories>
      <tags>
        <tag>python常用模块</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[元类]]></title>
    <url>%2F2019%2F08%2F07%2F%E5%85%83%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[​ 今天来讲一下python里面较难的一个东西，我暂时还不知道这个东西具体用到哪。所以后面会陆陆续续的补。我学到的python内容里面有两个东西是比较难的，一个是描述符，另一个就是今天讲的元类。 python通过类创建对象，通过元类创建类。（类也是对象） 通过type动态创建类。命名规则： type(类名，由父类名称构成的元祖（针对继承的情况，可以为空），包含属性的字典（名称和值）)]]></content>
      <categories>
        <category>python</category>
        <category>元类</category>
      </categories>
      <tags>
        <tag>python的元类</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pandas用法总结]]></title>
    <url>%2F2019%2F08%2F07%2Fpandas%2F</url>
    <content type="text"><![CDATA[​ pandas也是一个非常强大的库，所以我也只是总结了我用到的方法。 pandas常用的数据类型：1、Series 一维 带标签的数组（标签就是索引）2、DataFrame 二维 Series的容器 Series：通过列表创建Series： 索引可以指定，默认从0开始： 通过字典创建Series：可以通过astype修改类型 取值： 可以将条件和value、index配合使用： pandas读取外部数据： read_csv:读取CSV文件 read_excel:读取excel文件 其他文件类似 DataFrame通过列表创建： 通过数组创建： 通过字典创建： DataFrame的基础属性： shape ：行数 列数 dtypes：列数据类型 ndim：数据维度 index：行索引 columns：列索引 values：对象值 DataFrame的方法： head(n):显示头n行。默认是前5行 tail(n)：显示尾n行。 info()：行数，列数，列索引，列非空值个数，列类型，内存占用 describe()：计数 均值 标准差 最大值 四分位数 最小值 DataFrame排序：sort_values()。通过设置by来确定排序的key。设置ascending确定升序or降序。 DataFrame的取值： 方括号写数字，表示取行。对行进行操作。根据实际情况写 对列进行操作： 配合使用： loc：DataFrame通过标签索引获取行数据 根据多个索引取多个对应的值： iloc：DataFrame通过位置获取列数据。与ioc类似，只是将索引换成数字。 数组合并： 1、join 按行索引合并 2、merge按列索引进行合并 on指定按哪一列合并 how：合并方式 inner(交集，默认) outer(并集) left(左边为准，NaN补全) right(右边为准，NaN补全) 如果列索引不同。可以left_on和right_on指定左边、右边DataFrame的合并列。 另一种写法： 分组:groupby(by) by:通过什么分组，可以设置多个条件分组 聚合：count 计算数量 sum 求和 mean 求平均值 median 求中位数 std、var 求标准差和方差 min、max 求最大和最小值 DataFrame的索引和复合索引：简单的索引操作： 获取index：df.index 指定index：df.index=[“”,””] 同理可得指定columns：df.columns=[“ “,” “] 重新设置index：df.reindex() 指定某一列成为index：df.set_index()。drop决定是否保留设定的列 可以设定多个列成为index： 返回index的唯一值：df.set_index().index.unique() 时间序列：date_range(start,end,period,freq) 生成一段时间范围。start和end表示范围，periods表示个数，freq表示频率(年、月、天) 频率类型： 时间段：PeriodIndex 重采样resample：指的是将时间序列从一个频率转化为另一个频率进行处理的过程。将高频率数据转化为低频率数据为降采样。低频率数据转化为高频率为升采样。 判断数据是否为NaN：pd.isnull() pd.notfull() 在DataFrame中对缺失数据（NaN）的处理： 方式1：删除NaN所在的行列dropna(axis,how,inplace):how=”any”时一行(列)里有一个为nan就删。how=”all”时，一行全部为nan时才删。inplace为True，原地修改。False为False，不修改。 方式2：填充数据，fillna() 处理为0的数据：t[t==0]=np.nan 计算平均值时：nan不参与计算，0参与]]></content>
      <categories>
        <category>python</category>
        <category>pandas</category>
      </categories>
      <tags>
        <tag>pandas</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python知识散记（3）]]></title>
    <url>%2F2019%2F08%2F07%2Fpython%E7%9F%A5%E8%AF%86%E6%95%A3%E8%AE%B0%EF%BC%883%EF%BC%89%2F</url>
    <content type="text"><![CDATA[​ 今天的知识散记讲三个器，哪三个器呢？装饰器、迭代器、生成器。还有列表生成式、字典生成式。 装饰器：python装饰器就是用于拓展原来函数功能的一种函数，这个函数的特殊之处在于它的返回值也是一个函数，使用python装饰器的好处就是在不用更改原函数的代码前提下给函数增加新的功能。 使用闭包完成的装饰器原理： 当执行test(test)时，func已经指向test()函数。所以func()相当于test()。这就是装饰器的原理。但是实际不是这样写的，请看下图： 使用装饰器对有参数的函数装饰： 对不定长参数的装饰： 装饰器对有返回值的函数装饰： 带参数的装饰器 用类做装饰器： 装饰器完了，自己慢慢悟吧。 迭代器迭代器只能前进不能后退。使用迭代器不要求事先准备好整个迭代过程中的所有元素。迭代器仅仅在迭代到某个元素时才计算该元素，而在这之前或之后元素可以不存在或者被销毁。因此迭代器适合遍历一些数量巨大甚至无限的序列。 Python中迭代器的本质上每次调用__next__()方法都返回下一个元素或抛出StopIteration的容器对象 由于Python中没有“迭代器”这个类，因此具有以下两个特性的类都可以称为“迭代器”类： 1、有__next__()方法，返回容器的下一个元素或抛出StopIteration异常 2、有__iter__()方法，返回迭代器本身 all(iterable)：如果迭代器里面的所有元素都为True时,返回True;否则返回False any(iterable）：如果迭代器里面的所有元素为False,返回False;否则返回True. 生成器一个个的生成数据，但占用内存更少，生成器是特殊的迭代器。 当yield存在函数时，函数就变成一个生成器。yield不像return那样返回值，而是每次产生多个值。每次使用yield产生一个值，函数就会被冻结。 用aim.__next__()得出结果： aim.send()得出结果： 列表生成式和字典推导式：]]></content>
      <categories>
        <category>python</category>
        <category>知识散记</category>
        <category>知识散记（3）</category>
      </categories>
      <tags>
        <tag>python知识散记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python知识散记（2）]]></title>
    <url>%2F2019%2F08%2F06%2Fpython%E7%9F%A5%E8%AF%86%E6%95%A3%E8%AE%B0%EF%BC%882%EF%BC%89%2F</url>
    <content type="text"><![CDATA[​ 接着上次的知识散记，我们接着看。 闭包在函数内部定义一个函数，并且这个函数用到了外面的变量。将这个函数以及用到的一些变量称之为闭包。 当某个函数被当成对象返回时，夹带了外部 变量，就形成了一个闭包。 global：一般多用在函数内，声明变量的作用域为全局作用域。箭头变化的时候加，箭头不变的时候可以不加。（箭头类似指针） nonlocal：nonlocal关键字用来在函数或其他作用域中使用外层(非全局)变量 lambda匿名函数： 不要看匿名函数蛮简单的，其实还是有点注意事项的。对默认参数的赋值只会在函数定义的时候绑定一次。x是一个自由变量。在运行的时候绑定，而不是在定义的时候绑定。执行时，x的值是多少就是多少。如果希望匿名函数可以在定义的时候绑定，并保持值不变，则采用下面方法。 assert:断言用来直接让程序崩溃，在程序中置入检查点 条件后可以添加字符串，用来解释断言 format: 对*和**的解释：星号(*)和(**)作为形参的时候是起到“打包”的作用，相反，作为实参的时候是起到“解包”的作用。 星号(*)或(**)作为形参，表示调用可变参数函数：通过在形参前加一个星号(*)或两个星号(**)来指定函数可以接收任意数量的实参。 从两个示例的输出可以看出：当参数形如 *args 时，传递给函数的任意个实参会按位置打包成一个元 组（tuple）；当参数形如 **args 时，传递给函数的任意个 key = value 实参会被包装进一个字典（dict）。 星号(**)和(*)作为实参时，表示通过解包参数调用函数： 常用内置函数补充：复数可以通过complex（real，imag）来指定。conjugete提取共轭复数 hasattr：hasattr() 函数用于判断对象是否包含对应的属性。如果对象有该属性返回 True，否则返回 False。 上下文管理器（context manager）：任何实现了__enter__和__exit__方法的对象都可称为上下文管理器 __enter__():方法返回资源对象，这里就是你将要打开的那个文件对象，__exit__()处理一些清除工作。因为File类实现上下文管理器，现在就可以使用with语句了。 实现上下文管理器的其他方法：使用contextmanager装饰器 python的三种修饰符：staticmethod、classmethod 和 property，作用分别是把类中定义的实例方法变成静态方法、类方法和类属性。staticmethod、classmethod具体看python的类和对象。 注意： 函数先定义，再修饰它；反之会编译器不认识； 修饰符“@”后面必须是之前定义的某一个函数； 每个函数只能有一个修饰符，大于等于两个则不可以。 property用法:它的作用把方法当作属性来访问（注意getnum和setter的顺序，一定getnum在第一个）]]></content>
      <categories>
        <category>python</category>
        <category>知识散记</category>
        <category>知识散记（2）</category>
      </categories>
      <tags>
        <tag>python知识散记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python知识散记（1）]]></title>
    <url>%2F2019%2F08%2F06%2Fpython%E7%9F%A5%E8%AF%86%E6%95%A3%E8%AE%B0%EF%BC%881%EF%BC%89%2F</url>
    <content type="text"><![CDATA[​ 今天来讲一下python的一些散装知识，还是蛮多的。所以分了几个部分。今天的部分是最简单的，废话少说。开始吧 导入模块方法：1、最常见的方式，直接将要导入的模块名称写在后面导入。import xxxx 2、from .. import .. 与import类似，只是更明确的要导入的方法或变量。 3、from modname import *，导入所有的类和公有方法。 if __name__==”__main__“:让你写的脚本模块既可以导入到别的模块中用，另外该模块自己也可执行。 常用的一些内置函数callable(object)：检查对象object是否可调用。如果返回True，object仍然可能调用失败；但如果返回False，调用对象ojbect绝对不会成功。 divmod(a,b)：以元祖的方式放回a//b以及a%b。 ord(str)：把对应的字符转成整数. chr(integer)：把整数转化成对应的字母. bool(x)：把一个值转化为布尔值,如果该值为假或者省略返回False,否则返回True abs(x) ：返回一个数的绝对值.该参数可以是整数或浮点数.如果参数是一个复数,则返回其大小 round(number[, ndigits])：返回浮点数number保留ndigits位小数后四舍五入的值。 dir([object]): 没有参数,返回当前局部范围的名单列表。有参数，试图返回该对象的有效的属性列表 issubclass(class, classinfo):返回True如果参数class是classinfo的一个子类，否则返回False。 isinstance(object, classinfo):返回True如果参数object是classinfo的一个实例，否则返回False(适用于继承)。 zip(*iterables):生成一个迭代器，迭代器聚合了从每个可迭代数集里的元素。它的内容只能被消费一次 map：第一个参数 function 以参数序列中的每一个元素调用 function函数，返回包含每次 function 函数返回值的新列表。 filter：filter() 函数用于过滤序列，过滤掉不符合条件的元素，返回由符合条件元素组成的新列表。应该接收两个参数，第一个为函数，第二个为序列，序列的每个元素作为参数传递给函数进行判，然后返回 True 或 False，最后将返回 True 的元素放到新列表中。 enumerate是一个非常有用的函数，直接看效果。 eval(str [,globals [,locals ]])：用来计算存储在字符串中的有效python表达式。 exec(object[, globals[, locals]])， 用来执行存储在字符串或文件中的python语句 格式化输出格式： python语句中一些基本规则和特殊字符： python调试：python调试两种方法都有用到pdb模块 第一种：在代码的目录下，打开cmd，输入python -m 文件名 h：帮助命令 第二种：可以在交互界面进行调试]]></content>
      <categories>
        <category>python</category>
        <category>知识散记</category>
        <category>知识散记（1）</category>
      </categories>
      <tags>
        <tag>python知识散记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[协程]]></title>
    <url>%2F2019%2F08%2F06%2Fpython%E4%B8%AD%E7%9A%84%E5%8D%8F%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[​ 今天，我们来讲一些协程。协程是python中独有的，在其他语言中是没有这个概念的。协程是利用线程在等待的时候做事情。 使用yield完成协程： 使用greenlet完成协程： 使用gevent完成协程： 要想用时间模块延迟，则必须打补丁： 我还没看完，后面补。未完待续……]]></content>
      <categories>
        <category>python</category>
        <category>协程</category>
      </categories>
      <tags>
        <tag>python协程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python中的进程]]></title>
    <url>%2F2019%2F08%2F06%2Fpython%E4%B8%AD%E7%9A%84%E8%BF%9B%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[多进程：multiprocessing模块 os.getpid()获取当前进程的id os.getppid()获取父进程的id 大量启动子进程，可以用进程池pool批量创建子进程。可以通过processes改变创建的进程数目。 apply_async(func[, args=()[, kwds={}[, callback=None]]])该函数用于传递不定参数，非阻塞且支持结果返回进行回调。 将函数添加到进程池： map(func, iterable[, chunksize=None])：Pool类中的map方法，与内置的map函数用法行为基本一致，它会使进程阻塞直到返回结果。 注意，虽然第二个参数是一个迭代器，但在实际使用中，必须在整个队列都就绪后，程序才会运行子进程。 close()：关闭进程池（pool），使其不在接受新的任务。 terminate()：结束工作进程，不在处理未处理的任务。 join([timeout])：主进程阻塞等待子进程的退出，join方法必须在close或terminate之后使用。timeout表示等待最多时间。若超出，则会直接执行下列代码 Value、Array是通过共享内存的方式共享数据 Value：将一个值存放在内存中， Array：将多个数据存放在内存中，但要求数据类型一致 Value: Array:两种情况 若为数字，表示开辟的共享内存中的空间大小，（Value表示为该空间绑定一个数值） 若为数组，表示在共享内存中存入数组 说明：三个0表示开辟的共享内存容量为3，当再超过3时就会报错。 Manager（Value、Array、dict、list、Lock、Semaphore等）是通过共享进程的方式共享数据。 进程间通信：Queue ，Pipe 使用方法和队列差不多 q.get_nowait()：和get()差不多，不用等。 Pipe:Pipe可以是单向(half-duplex)，也可以是双向(duplex)。我们通过mutiprocessing.Pipe(duplex=False)创建单向管道 (默认为双向)。一个进程从PIPE一端输入对象，然后被PIPE另一端的进程接收，单向管道只允许管道一端的进程输入，而双向管道则允许从两端输入。 这里的Pipe是双向的。 Pipe对象建立的时候，返回一个含有两个元素的表，每个元素代表Pipe的一端(Connection对象)。我们对Pipe的某一端调用send()方法来传送对象，在另一端使用recv()来接收。 生产者与消费者模式：在两者中找一个缓冲的东西（队列，缓冲池），解决数据生产方和数据处理方数据不分配的问题。 耦合：谁和谁的关系越强，耦合性就越强。耦合性越强，程序维护越难。 解耦的好处：哪块不合适，就改那块。 接上面：]]></content>
      <categories>
        <category>python</category>
        <category>进程</category>
      </categories>
      <tags>
        <tag>python进程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python中的线程]]></title>
    <url>%2F2019%2F08%2F06%2Fpython%E4%B8%AD%E7%9A%84%E7%BA%BF%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[重要的话写在前面：进程间不共享全局变量，线程间共享全局变量。 同步：按预定的先后次序进行运行 异步：不确定的次序 对于操作系统来说，一个任务就是一个进程。进程内的子任务成为线程 ，一个进程至少有一个线程 多任务执行的方式： 多进程 多线程 多进程+多线程 多线程：Python的标准库提供了两个模块：_thread和threading，_thread是低级模块，threading是高级模块，对_thread进行了封装。绝大多数情况下，我们只需要使用threading这个高级模块。 传入参数为元祖。也就是即使只有一个参数，也要写逗号。 join():将线程加入到当前线程，并等待其终止 判断线程是否在运行： 守护线程：将daemon属性设为True，则该线程无法被连接 daemon属性可以保证主线程结束时可以同时结束子线程或者使主线程等待子线程结束后在结束。故称为守护线程。daemon默认为False，如需修改，必须在调用start()方法启动线程之前进行设置。不适用与idle的交互模式或脚本模式 当daemon属性为False时，主线程会检测子线程是否结束，如果子线程还在运行，则主线程会等待他完成后在退出。当daemon属性为True时，子线程没执行的不再执行，主线程直接退出。 通过轮询终止线程： threading的常用方法： ​ active_count() 当前活动的 Thread 对象个数 ​ current_thread() 返回当前 Thread 对象 ​ current_thread().name返回当前的Thread对象的名字 ​ get_ident() 返回当前线程 ​ enumerater() 返回当前活动 Thread 对象列表 ​ main_thread() 返回主 Thread 对象 ​ settrace(func) 为所有线程设置一个 trace 函数 ​ setprofile(func) 为所有线程设置一个 profile 函数 ​ stack_size([size]) 返回新创建线程栈大小；或为后续创建的线程设定栈大小为 size ​ TIMEOUT_MAX Lock.acquire(), RLock.acquire(), Condition.wait() 允许的最大值 threading 可用对象列表： ​ Thread 表示执行线程的对象 ​ Lock 锁原语对象 ​ RLock 可重入锁对象，使单一进程再次获得已持有的锁(递归锁) Condition： 条件变量对象，使得一个线程等待另一个线程满足特定条件，比如改变状态或某个值 ​ wait(timeout): 线程挂起，直到收到一个notify通知或者超时（可选的，浮点数，单位是秒s）才会被唤醒继续运行。wait()必须在已获得Lock前提下才能调用，否则会触发RuntimeError。 ​ condition = threading.Condition(lock=None) # 创建Condition对象 参数可以不传 ​ condition.acquire() # 加锁 ​ condition.release() # 解锁 ​ condition.wait(timeout=None) # 阻塞，直到有调用notify(),或者notify_all()时再触发 ​ condition.wait_for(predicate, timeout=None) # 阻塞，等待predicate条件为真时执行 ​ condition.notify(n=1) # 通知n个wait()的线程执行, n默认为1 ​ condition.notify_all() # 通知所有wait着的线程执行 ​ with condition: # 支持with语法，不必每次手动调用acquire()/release() Semaphore 为线程间共享的有限资源提供一个”计数器”，如果没有可用资源会被阻塞 Events：它是由线程设置的信号标志，如果信号标志为真，则其他线程等待直到信号接触。 Event对象实现了简单的线程通信机制，它提供了设置信号，清除信号，等待等用于实现线程间的通信。 event = threading.Event() 创建一个event 1 设置信号 event.set() 使用Event的set（）方法可以设置Event对象内部的信号标志为真。Event对象提供了isSet（）方法来判断其内部信号标志的状态。 当使用event对象的set（）方法后，isSet（）方法返回真 2 清除信号 event.clear() 使用Event对象的clear（）方法可以清除Event对象内部的信号标志，即将其设为假，当使用Event的clear方法后，isSet()方法返回假 3 等待 event.wait() Event对象wait的方法只有在内部信号为真的时候才会很快的执行并完成返回。当Event对象的内部信号标志为假时，则wait方法一直等待到其为真时才返回。也就是说必须set新号标志为真 主线程在等事件设置后才继续执行 event使用示范： Barrier :创建一个”阻碍”，必须达到指定数量的线程后才可以继续 每个线程中都调用了wait()方法，在所有（此处设置为3）线程调用wait方法之前是阻塞的。也就是说，只有等到3个线程都执行到了wait方法这句时，所有线程才继续执行。 计算处于alive的Thread对象数量： 多线程避免全局变量的改变：上锁。上锁后执行的代码越少越好。 互斥锁：Lock是比较低级的同步原语，当被锁定后不属于特定的线程。一个锁有两个状态:Locked和unLocked.刚创建的的Locked处于unlocked状态。如果锁处于unlocked状态，acquire()方法将其修改为Locked并立即返回。如果锁处于locked状态，则阻塞当前线程并等待其他线程释放锁，然后将其修改为locked并立即返回。release()方法用来将锁的状态从locked修改为unlocked并立即返回。如果锁的状态本来就是unlocked，则会抛出异常 可重入锁Rlock对象也是一种常用的线程同步原语，可被同一个线程acquire()多次。当locked状态时，某现场拥有该锁，当处于unlocked状态时，该锁不属于任何线程。Rlock对象的acquire()/release()调用对可以嵌套，仅当最后一个或者最外层的release执行结束后，锁才会被设置为unlocked状态 死锁：双方都在等待对方的条件满足 避免死锁的方法：1、添加超时事件 2、 尽量避免（银行家算法） Threadlocal：保存当前线程的专有状态，这个状态对其他线程不可见。 全局变量local就是一个ThreadLocal对象，每个Thread对它都可以读写student属性，但互不影响。你可以把local看成全局变量，但每个属性如local.student都是线程的局部变量，可以任意读写而互不干扰，也不用管理锁的问题，ThreadLocal内部会处理。一个ThreadLocal变量虽然是全局变量，但每个线程都只能读写自己线程的独立副本，互不干扰。ThreadLocal解决了参数在一个线程中各个函数之间互相传递的问题。 线程池：threadpool模块或concerrent.futures模块 threadpool模块比较老旧，不是主流。 threadpool.ThreadPool(poolsize)：定义一个线程池，创建了poolsize个线程。 threadpool.makeRequest(开启多线程的函数，函数相关参数，[回调函数]) putRequest:将所有要运行多线程的请求扔进线程池。 concerrent.futures： ThreadPoolExecutor构造实例的时候，传入max_workers参数来设置线程池中最多能同时运行的线程数目。 使用submit函数来提交线程需要执行的任务（函数名和参数）到线程池中，并返回该任务的句柄（类似于文件、画图），注意submit()不是阻塞的，而是立即返回。 通过submit函数返回的任务句柄，能够使用done()方法判断该任务是否结束。上面的例子可以看出，由于任务有2s的延时，在task1提交后立刻判断，task1还未完成，而在延时4s之后判断，task1就完成了。 使用cancel()方法可以取消提交的任务，如果任务已经在线程池中运行了，就取消不了。这个例子中，线程池的大小设置为2，任务已经在运行了，所以取消失败。如果改变线程池的大小为1，那么先提交的是task1，task2还在排队等候，这是时候就可以成功取消。 使用result()方法可以获取任务的返回值。查看内部代码，发现这个方法是阻塞的 as_completed:一次取出所有任务的结果。as_completed()方法是一个生成器，在没有任务完成的时候，会阻塞，在有某个任务完成的时候，会yield这个任务，就能执行for循环下面的语句，然后继续阻塞住，循环到所有的任务结束。从结果也可以看出，先完成的任务会先通知主线程。 map的作用和submit一样，但略有不同。输出顺序和参数列表的顺序相同 wait方法接受三个参数，等待的任务序列，超时时间，以及等待条件。等待条件return_when默认为ALL_COMPLTED，表明要等待所有的任务都结束。还可以设为FIRST_COMPLETED，表示第一个任务完成就结束等待。FITST_EXCEPTION(注意要导入) 通过类创建线程： t.start后一定调用run函数，不定义run函数该线程不执行。对其他函数的调用只能在run函数里执行。多线程可以共享全局变量，但当数据量大时，数据会出错（产生资源竞争）。 线程是真的多，看到最后。迷迷糊糊，有错一定要提醒我。而且很多我还没有用过。后面用到的话，会补充上去的。接下来说最后一个：GIL。何为GIL？ GIL：全局解释器锁 单CPU的系统中运行多个进程那样，内存中可以存放多个程序，但任意时刻，只有一个程序在CPU中运行。同样地，虽然Python解释器中可以“运行”多个线程，但在任意时刻，只有一个线程在解释器中运行。 GIL保证了多线程时只有一个线程被调用。 所以多进程效率比多线程高，但是进程间通信比线程难。 解决方法：用C语言写关键部分。模块（ctypes）]]></content>
      <categories>
        <category>python</category>
        <category>线程</category>
      </categories>
      <tags>
        <tag>python线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[numpy]]></title>
    <url>%2F2019%2F08%2F06%2Fnumpy%2F</url>
    <content type="text"><![CDATA[​ 最近这几年，机器学习和深度学习大火。而这其中的数据计算是非常多，而这得益于python的numpy模块。多提一句：numpy是没有GIL（多线程解释器锁）的。所以，numpy中的计算是非常快的。那什么是GIL呢？请看python的多线程。话不多说，让我们开启今天的数学之旅。PS：numpy很多API，我还没有学完。我只是总结了一部分，后面会补充的。 通过array生成矩阵： 可以通过dtype设置矩阵数据的类型。astype可以修改数据类型。 还有其他生成矩阵的方式： numpy生成随机数： seed的使用方法： 可以通过reshape修改列表的行数和列数，resize改变数组的尺寸大小。根据reshape传入的参数判断转为哪种数组。 numpy运算：加、减、乘、除类似。如果两个矩阵形状相同，两个矩阵对应的元素做操作。若两个矩阵形状不相同，其中一个矩阵的维度与另一个矩阵的维度相同，可以在该维度上做操作。 通过axis求每行（列）的元素和或最大、最小值。0代表列，1代表行。 还可以获得最大、最小值： 其他一些计算： 对clip函数的解释：小于5的元素都设为5，大于9的元素都设为9 flatten：对数组展开为一维数组 numpy的合并： numpy的分割： 转置矩阵： 未完待续……]]></content>
      <categories>
        <category>python</category>
        <category>数学计算</category>
        <category>numpy</category>
      </categories>
      <tags>
        <tag>python的数学计算模块</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络编程]]></title>
    <url>%2F2019%2F08%2F06%2F%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[​ 今天，我们来讲一下网络编程。这里面用到一个库：socket。网络通信其实就是两个进程之间在编程。先说两个重要的协议：TCP协议 和 UDP协议。TCP协议是传输控制协议，UDP协议是数据传输协议。TCP和UDP的区别：TCP慢但是稳定，因为它经过了三次握手和四次挥手，不会丢失数据。UDP快。 socket:注意参数是一个tuple，包含地址和端口号。 在同一个os中，端口不允许相同，即如果某个端口已经被使用了，那么在这个进程释放之前，其他进程都不能使用这个端口。（端口用来区分进程，若相同，不能把数据发送到准确的进程） 创建Socket时，AF_INET指定使用IPv4协议，如果要用更先进的IPv6，就指定为AF_INET6。SOCK_STREAM指定使用面向流的TCP协议，这样，一个Socket对象就创建成功，但是还没有建立连接。 coding： 主机名可以通过调用socket.gethostname()获得 接收数据时，调用recv(max)方法，一次最多接收指定的字节数，因此，在一个while循环中反复接收，直到recv()返回空数据，表示接收完毕，退出循环。当我们接收完数据后，调用close()方法关闭Socket，这样，一次完整的网络通信就结束了 创建TCP连接时，主动发起连接的叫客户端，被动响应连接的叫服务器。 客户端要主动发起TCP连接，必须知道服务器的IP地址和端口号。 TCP服务端建立步骤： 一般是服务器（接受方）绑定端口，客户端（发送方）不绑定 UDP不需要调用listen（）方法。可以直接接收数据 TCP调用listen()方法开始监听端口，将主动套接字（默认）变为被动套接字，传入的参数指定等待连接的最大数量 TCP服务端： TCP客户端： 一般send()和recv()用于TCP，sendto()及recvfrom()用于UDP。sendto和recvfrom一般用于UDP协议中,但是如果在TCP中connect函数调用后也可以用。 服务器编程首先要绑定一个端口并监听来自其他客户端的连接。如果某个客户端连接过来了，服务器就与该客户端建立Socket连接，随后的通信就靠这个Socket连接了。 由于服务器会有大量来自客户端的连接，所以，服务器要能够区分一个Socket连接是和哪个客户端绑定的。一个Socket依赖4项：服务器地址、服务器端口、客户端地址、客户端端口来唯一确定一个Socket。但是服务器还需要同时响应多个客户端的请求，所以，每个连接都需要一个新的进程或者新的线程来处理，否则，服务器一次就只能服务一个客户端了。 然后，我们要绑定监听的地址和端口()。服务器可能有多块网卡，可以绑定到某一块网卡的IP地址上，也可以用0.0.0.0绑定到所有的网络地址，还可以用127.0.0.1绑定到本机地址。127.0.0.1是一个特殊的IP地址，表示本机地址，如果绑定到这个地址，客户端必须同时在本机运行才能连接，也就是说，外部的计算机无法连接进来。 端口号需要预先指定。请注意，小于1024的端口号必须要有管理员权限才能绑定： 每个连接都必须创建新线程（或进程）来处理，否则，单线程在处理连接的过程中，无法接受其他客户端的连接 利用多线程和socket进行聊天室的创建（UDP）： 下面这段代码是单进程服务器，配合进程或线程也可以建立多任务服务器（TCP）： serverSocket：当这个套接字被关闭时，代表不再接收新的客户端连接 clientSocket：当这个套接字被关闭时，代表不能使用send和recv发收数据。 当利用线程建立多任务服务器时，clientSocket不能关闭。因为子线程共用数据 当利用进程建立时，clientSocket能关闭。子进程和父进程完全”一样“（实时拷贝） 单进程实现多任务： 最后，讲一下单播，多播和广播。 单播：一对一 多播：一对多 广播：一对所有 UDP有广播，TCP没有广播 UDP发送广播数据的条件：]]></content>
      <categories>
        <category>python</category>
        <category>网络编程（socket）</category>
      </categories>
      <tags>
        <tag>python的网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则表达式]]></title>
    <url>%2F2019%2F08%2F05%2F%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[正则表达式（不能随意添加空格，不然会改变原来含义）： 元字符(不能匹配自身): . $ ^ ( ) { } [ ] $ + \ | *， |：A | B 会匹配 A 或 B 中出现的任何字符。为了能够更加合理的工作，| 的优先级非常低。例如 Fish|C 应该匹配 Fish 或 C，而不是匹配 Fis，然后一个 ‘h’ 或 ‘C’。同样，我们使用 | 来匹配 ‘|’ 字符本身；或者包含在一个字符类中，像这样 [|]。 ^:匹配字符串的起始位置。如果设置了 MULTILINE 标志，就会变成匹配每一行的起始位置。在 MULTILINE 中，每当遇到换行符就会立刻进行匹配。 $:匹配字符串的结束位置，每当遇到换行符也会离开进行匹配。 +：用于指定前一个字符匹配一次或多次 ：匹配的是零次或多次 ？：指定前一个字符匹配零次或者一次。 {m，n}(m和n都是十进制整数)：它的含义是前一个字符必须匹配m次到n（包括n次）次之间 原始字符串来表示正则表达式（就是在字符串前边加上 r） \A:只匹配字符串的起始位置。如果没有设置 MULTILINE 标志的时候，\A 和 ^ 的功能是一样的；但如果设置了 MULTILINE 标志，则会有一些不同：\A 还是匹配字符串的起始位置，但 ^ 会对字符串中的每一行都进行匹配。 \Z:只匹配字符串的结束位置 \B:另一个零宽断言，与 \b 的含义相反，\B 表示非单词边界的位置。 零宽断言： 有些元字符它们不匹配任何字符，只是简单地表示成功或失败，因此这些字符也称之为零宽断言 前向断言： （1）：前向肯定断言：如果当前包含的正则表达式（这里以 … 表示）在当前位置成功匹配，则代表成功，否则失败。一旦该部分正则表达式被匹配引擎尝试过，就不会继续进行匹配了；剩下的模式在此断言开始的地方继续尝试。 （2）：前向否定断言：这跟前向肯定断言相反（不匹配则表示成功，匹配表示失败） 假定我们要处理一段html，我们要替换掉相对url，例如text 这个a标签我们要替换成text，而对于代码 这样的a标签则要保留不做替换。这个应用场景下 就需要判断A标签的href属性如果不是以http://开头则匹配，即要做前向否定的断言. 脱字符：^ ,例如[^ 5 ]会匹配任何字符 “5”之外的任何字符 [ ]他们指定一个字符类用于存放你需要的字符集合。可以单独列出需要匹配字符，也可以两个字符和一个横杆-指定匹配的范围。元字符在方括号中不会触发“特殊功能”，在字符类中，它们只匹配自身。 反斜杠 \：如果在反斜杠后边紧跟着一个元字符，那么元字符的“特殊功能”也不会被触发。例如你需要匹配符号[ 或 \，你可以在他们前面加上一个反斜杠，以消除他们的特殊功能：\[ ,\\ 注意用小括号括住要重复的内容： 匹配ip（万能版）： 非捕获组和命名组： 非捕获组的语法是 (?:…)，这个 … 你可以替换为任何正则表达式。 “捕获”就是匹配的意思啦，普通的子组都是捕获组，因为它们能从字符串中匹配到数据 命名组：：(?P)。很明显，&lt; &gt; 里边的 name 就是命名组的名字啦，除了使用名字访问， 命名组仍然可以使用数字序号进行访问 正则表达式使用以下方法修改字符串： split(***string***[, maxsplit=0**])*：通过正则表达式匹配来分割字符串。如果在 RE 中，你使用了捕获组，那么它们的内容会作为一个列表返回。你可以通过传入一个 *maxsplit 参数来设置分割的数量。如果 maxsplit 的值是非 0，表示至多有 maxsplit 个分割会被处理，剩下的内容作为列表的最后一个元素返回。 .sub(***replacement***, string**[,* count=0**])*返回一个字符串，这个字符串从最左边开始，所有 RE 匹配的地方都替换成 *replacement。如果没有找到任何匹配，那么返回原字符串。可选参数 *count 指定最多替换的次数，必须是一个非负值。默认值是 0，意思是替换所有找到的匹配。下边是使用 sub() 方法的例子，它会将所有的颜色替换成 color： subn:subn() 方法跟 sub() 方法干同样的事情，但区别是返回值为一个包含有两个元素的元组：一个是替换后的字符串，一个是替换的数目。 匹配方法： 匹配的方法和属性： group(N) 返回第N组括号匹配的字符，groups() 返回所有括号匹配的字符，以tuple格式 match匹配的m： findall() 需要在返回前先创建一个列表，而 finditer() 则是将匹配对象作为一个迭代器返回 利用compile来先编译的方法是模式级别的方法（适用于多次使用该正则表达式），可以针对同一种模式做多次匹配，如下图：另一种是模式对象方法 import re import re p=re.compile() re.search(“”,””) p.search() 贪婪模式和非贪婪模式： 贪婪模式是让正则表达式尽可能的匹配符合的内容 在匹配的字符后面加一个问号，启动非贪婪模式 编译标志：编译标志让你可以修改正则表达式的工作方式。在 re模块下，编译标志均有两个名字：完整名和简写 ASCII(re.A) 使得 \w，\W，\b，\B，\s 和 \S 只匹配 ASCII 字符，而不匹配完整的 Unicode 字符。这个标志仅对 Unicode 模式有意义，并忽略字节模式。 DOTALL(re.S) 使得 . 可以匹配任何字符，包括换行符。如果不使用这个标志，. 将匹配除了换行符的所有字符。 IGNORECASE(re.I) 字符类和文本字符串在匹配的时候不区分大小写。举个例子，正则表达式 [A-Z] 也将会匹配对应的小写字母，像 FishC 可以匹配 FishC，fishc 或 FISHC 等。如果你不设置 LOCALE，则不会考虑语言（区域）设置这方面的大小写问题。 LOCALE(re.L) 使得 \w，\W，\b 和 \B 依赖当前的语言（区域）环境，而不是 Unicode 数据库。区域设置是 C 语言的一个功能，主要作用是消除不同语言之间的差异。例如你正在处理的是法文文本，你想使用 \w+ 来匹配单词，但是 \w 只是匹配 [A-Za-z] 中的单词，并不会匹配 ‘é’ 或 ‘&#231;’。如果你的系统正确的设置了法语区域环境，那么 C 语言的函数就会告诉程序 ‘é’ 或 ‘&#231;’ 也应该被认为是一个字符。当编译正则表达式的时候设置了 LOCALE 的标志，\w+ 就可以识别法文了，但速度多少会受到影响。 MULTILINE(re.M) 通常 ^ 只匹配字符串的开头，而 $ 则匹配字符串的结尾。当这个标志被设置的时候，^ 不仅匹配字符串的开头，还匹配每一行的行首；&amp; 不仅匹配字符串的结尾，还匹配每一行的行尾。 VERBOSE(re.X) 这个标志使你的正则表达式可以写得更好看和更有条理，因为使用了这个标志，空格会被忽略（除了出现在字符类中和使用反斜杠转义的空格）；这个标志同时允许你在正则表达式字符串中使用注释， 符号后边的内容是注释，不会递交给匹配引擎（除了出现在字符类中和使用反斜杠转义的 ） 正则表达式特殊符号及用法：]]></content>
      <categories>
        <category>python</category>
        <category>正则表达式</category>
      </categories>
      <tags>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读取、写入excel]]></title>
    <url>%2F2019%2F08%2F05%2F%E8%AF%BB%E5%8F%96%E3%80%81%E5%86%99%E5%85%A5excel%2F</url>
    <content type="text"><![CDATA[​ 今天我们来讲一下python如何对excel进行 读取和写入操作。 ##xlrd只支持对excel文件个是为xls文件的读取。 table = data.sheets()[0] #通过索引顺序获取 table = data.sheet_by_index(sheet_index)) #通过索引顺序获取 table = data.sheet_by_name(sheet_name)#通过名称获取 name=workbook_r.sheet_names() #获取文件的所有工作表名字 对行的操作： nrows = table.nrows #获取该sheet中的有效行数 table.row(rowx) #返回由该行中所有的单元格对象组成的列表 table.row_slice(rowx) #返回由该列中所有的单元格对象组成的列表 table.row_types(rowx, start_colx=0, end_colx=None) #返回由该行中所有单元格的数据类型组成的列表 table.row_values(rowx, start_colx=0, end_colx=None) #返回由该行中所有单元格的数据组成的列表 table.row_len(rowx) #返回该列的有效单元格长度 对列的操作： ncols = table.ncols #获取列表的有效列数 table.col(colx, start_rowx=0, end_rowx=None) #返回由该列中所有的单元格对象组成的列表 table.col_slice(colx, start_rowx=0, end_rowx=None) #返回由该列中所有的单元格对象组成的列表 table.col_types(colx, start_rowx=0, end_rowx=None) #返回由该列中所有单元格的数据类型组成的列表 table.col_values(colx, start_rowx=0, end_rowx=None) #返回由该列中所有单元格的数据组成的列表 获取单元格内容： 单元格 A1= table.cell(0,0).value C4=able.cell(2,3).value 使用行列索引 cell_A1 = table.row(0)[0].value cell_A2 = table.col(1)[0].value ##xlwt只支持对Excel文件格式为xls文件的写入 add_sheet(sheet_name): 添加sheet get_sheet(Sheet_name): 选择sheet save(file_name): 保存]]></content>
      <categories>
        <category>python</category>
        <category>读取、写入excel</category>
      </categories>
      <tags>
        <tag>xlrd、xlwt</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[垃圾回收GC]]></title>
    <url>%2F2019%2F08%2F05%2F%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6GC%2F</url>
    <content type="text"><![CDATA[​ 每种语言都有自己的垃圾回收机制。接下来我们来讲一下python的垃圾回收机制。 小整数对象池：python对小整数的定义为[-5，257)，这些整数对象是提前建立好的，不会被垃圾回收。单个字母也一样，但是当定义两个相同的字符串（没有空格等特殊符号），触发intern机制，引用计数为零，触发垃圾回收。 引用计数机制的优点：简单、实时性（一旦没有引用，内存就直接释放了）。 缺点：维护引用计数消耗资源、循环引用 python以引用计数为主，隔代回收为辅进行垃圾回收 GC模块（不能重写del方法）： 1、gc.set_debug(flags) 设置gc的debug日志，一般设置为gc.DEBUG_LEAK 2、gc.collect([generation]) 显式进行垃圾回收，可以输入参数，0代表只检查第一代的对象，1代表检查一，二代的对象，2代表检查一，二，三代的对象，如果不传参数，执行一个full collection，也就是等于传2。 返回不可达（unreachable objects）对象的数目 3、gc.get_threshold() 获取的gc模块中自动执行垃圾回收的频率 4、gc.set_threshold(threshold0[,threshold1[, threshold2]) 设置自动执行垃圾回收的频率。 5、gc.get_count() 获取当前自动执行垃圾回收的计数器，返回一个长度为3的列表 6、gc.disable() 把gc关闭,gc.enable()打开gc（默认打开） 7.gc.garbage 存储垃圾 导致引用计数+1的情况： 导致引用计数-1的情况： 查看一个对象的引用计数： 因为调用函数的时候传入a，所以是2.真正的引用计数=sys.getrefcount()-1]]></content>
      <categories>
        <category>python</category>
        <category>GC</category>
      </categories>
      <tags>
        <tag>python的GC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[工厂生产模式]]></title>
    <url>%2F2019%2F08%2F05%2F%E5%B7%A5%E5%8E%82%E7%94%9F%E4%BA%A7%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[​ 今天，我们来讲一下什么是工厂方法模式。工厂方法模式是在基类完成基本框架的搭建，在子类中具体实现方法的实现。工厂模式是一种典型的解耦模式。 函数或者类之间的关系越强，耦合性越强。代码就越难更新。 使用函数进行解耦： 使用类进行解耦：]]></content>
      <categories>
        <category>python</category>
        <category>工厂方法模式</category>
      </categories>
      <tags>
        <tag>python生产模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[类和对象]]></title>
    <url>%2F2019%2F08%2F05%2F%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[​ 众所周知，面向过程是根据业务逻辑从上到下写代码，面向过程：根据业务逻辑从上到下写代码面向对象：将数据与函数绑定到一起，进行封装，这样能更快速的开发程序，减少了重复代码的重写过程。面向对象语言三个基本要素：封装 继承 多态把函数和全局变量和在一起就是封装。而python就属于面向对象的语言。 类与对象的关系和区别：类是抽象的概念，仅仅代表事物的模板。对象是一个能够看得到，摸得着的具体的实体比如：飞机是对象，飞机图纸是类。 类由三部分构成: 类的名称:类名 类的属性：一组数据 一个特殊的对象：能够知道这个对象的class. 类的方法：允许进行的操作 类的抽象：拥有相同或者类似属性和行为的对象都可以抽象出一个类 python调用__init__方法的作用：初始化对象 python调用__str__方法： 私有方法：外界不能直接调用 私有属性：可以添加，可以添加后取值，不可以取值。（以双下划线开头为私有变量，单下划线开头的为保护变量） 通过内部方法取值： 私有属性无法取值的原因是因为名字重整技术，其实可以通过_类名_属性可以访问： 在这里讲一下私有的原理：这是通过名字重整机制改变的。命名规则：_类名__num（尽量不要用） python可以自己调用__del__方法，__del__是该对象被删除后调用的方法，注意：这里的删除是没有引用对象 完全删除后（没有引用对象）： 测量对象的引用对象：用sys模块的sys.getrefcount，得出结果后减一。 __new__方法：创建对象 实例化对象相当于做三件事： 1.通过__init__来创建对象，然后找了一个变量来接收___init__的返回值。这个返回值表示创建出来的对象引用。 2.__init__（刚刚创建出来的对象的引用） 3.返回对象的引用。 __new__方法 和 \init__方法的区别: 1.\init__ 通常用于初始化一个新实例，控制这个初始化的过程，比如添加一些属性， 做一些额外的操作，发生在类实例被创建完以后。它是实例级别的方法。没有返回值。负责初始化 2._new_ 通常用于控制生成一个新实例的过程。它是类级别的方法，参数是cls。负责创建。__init__和\new__方法合起来相当于C++的构造函数。 下面讲一个新的概念：单例 单例是创建了多少个对象都是指向同一片内存。 只初始化一次对象： 继承：可以少写代码。继承父类的方法和属性 继承可以多类继承。当子类和父类有什么不同时，可以进行重写（在子类中写一个和父类方法名相同的方法进行不同操作） 私有方法，私有属性不能被继承，可以被间接调用，如果在子类中实现了一个公有方法调用的方法或属性，那么这个方法是不能调用继承的父类的私有方法和私有属性 多继承： 当子类中的方法和父类方法名一样时会按照以下顺序去进行执行： 子类调用父类的三种方法： 父类.方法 super().init(不用传self，传参数) super(父类，self).init（不传self，参数）可以根据父类指定调用哪一个父类 多态：在写完方法的时候并不知道调用的是什么方法。真正执行的时候才知道 接下来的内容也很重要哦： 类在程序中也属于一个对象，称之为类对象。同过类创建出来的对象称之为实例对象。 类属性(classmethod)：类对象里的属性 实例属性：实例对象里的属性 实例属性和类属性的区别：实例属性和具体的某个实例对象有关系，且一个实例对象和另外一个实例对象是不共享属性的。类属性属于类对象，并且多个实例对象共享同一个类属性。 实例方法和类方法： 静态方法： 实例方法 类方法和静态方法的区别：实例方法和类方法必须传一个参数（实例方法self用来接收对象，类方法cls用于接收类），静态方法不需要参数（可以有）。 动态添加属性和方法： slots可以限制添加属性：这可以告诉解释器这个类的所有实例属性都在这了。可以节省大量内存。每个子类都要定义slots属性，因为解释器会忽略继承的slots属性。 内建属性： getattribute:属性拦截器 使用类名调用类属性时，不会经过__getattribute__方法，其他均要调用。（可以用来做日志）]]></content>
      <categories>
        <category>python</category>
        <category>类和对象</category>
      </categories>
      <tags>
        <tag>python的类和对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python异常]]></title>
    <url>%2F2019%2F08%2F05%2Fpython%E5%BC%82%E5%B8%B8%2F</url>
    <content type="text"><![CDATA[​ 今天我们来讲一下python的异常。何为异常？即是一个事件，该事件会在程序执行过程中发生，影响了程序的正常执行。异常时python对象，表示一个错误。当python脚本发生异常时我们需要捕获处理它，否则程序会终止执行。 ##try/except可以用来捕获异常 ##一个try捕获多个异常： ##一个try对多个except：根据不同的except做不同的操作 ##try-finally语句无论是否发生异常都将执行最后的代码。 ##异常传递 ##raise自定义异常： ##最后是python的标准异常：]]></content>
      <categories>
        <category>python</category>
        <category>异常</category>
      </categories>
      <tags>
        <tag>python异常</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python数据类型]]></title>
    <url>%2F2019%2F08%2F04%2Fpython%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[​ 每种编程语言都有属于自己的数据类型。今天，我们就来讲一下python的数据类型——列表，元祖，字典，字符串，堆，集合，队列。 列表​ 同时还有一些比较常用的方法，类似cmp(比较大小，python3已经找不到。如要使用，可以利用operator模块)，len(list)计算列表元素个数，max(list)求列表中的最大值，min(list)求最小值。下面对上面列表的排序方法(list.sort)进行讲解： 下张图片是对以上方法的coding： ##元祖（tuple） 元祖不像列表可以改变。元祖是不可变的。但可以利用切片灵活使用。 字典（dict）####注意：字典支持常见的集合操作（&amp;等操作） 字典有多个键与其对应的值构成的键-值对组成。键-值对称为项。每个键和它的值之间用:(冒号)隔开，项之间用,(逗号)隔开。 len(d)返回d中项(键-值对)的数量 d[k]返回关联到键k的值 d[k]=v将值关联到键k上 del d[k] 删除键为k的项 k in d 检查d中是否有含有键为k的值 clear()：清除字典中所有的项 fromkeys()：使用给定的键建立新的字典，每个键都对应一个默认的值None，也可以设立默认值 get():访问字典项，访问一个不存在的键时，没有异常。且可以定义默认值为None。 items和iteritems： items将所有的项以列表方式返回，列表中的每一项都表示为（键，值）对的形式。 iteritems方法的作用大致相同，但是会返回一个迭代器对象而不是列表。 keys和iterkeys： keys方法将字典中的键以列表形式返回，而iterkeys则返回针对键的迭代器 values和itervalues： values方法以列表的形式返回字典中的值，itervalues返回值的迭代器。与返回键的列表不同的是，返回值的列表中可以包含重复的元素。 pop：用来获得对应于给定键的值，然后将这个键-值对从字典中移除。 popitem：弹出随机的项 setdefault：获得与给定键相关联的值，能在字典中不含有给定键的情况下设立相应的键值。 update：可以利用一个字典项更新另外一个字典 堆（heapq）使用该数据类型前，我们先导入一个新的模块heapq heappush(heap,x):将x入对 heapop(heap)：将堆中最小的元素弹出 heapify(heap)：将heap属性强制应用到任意一个列表 heapreplace(heap,x)：将堆中最小的元素弹出，同时将x入堆 nlargest(n,iter)：返回iter中前n大的元素 nsmallest(n,iter)：返回iter中前n小的元素 集合（set）集合可取交集、取并集、取差集、对称差集： 利用set做去重操作： 集合分为可变集合和不可变集合： 队列（Queue）在python中，队列时线程间最常用的交换数据形式，Queue模块时提供队列操作的模块。 先进先出（FIFO）： 先进后出（LIFO）： 优先级队列：优先级队列put进去一个元祖，（优先级，数据），优先级数字越小，优先级越高。 注意：如果有两个元素优先级是一样的，那么在出队的时候是按照先进先出的顺序。 双端队列： 队列的方法： 使用put方法往队列中添加元素，需要考虑是否能放下的问题如果放不下了，默认会阻塞(block=True)，阻塞时可以定义超时时间timeout。可以使用block=False设置阻塞时立即报错 使用get()从队列里取数据。如果为空的话，blocking= False 直接报 empty异常。如果blocking = True，就是等一会，timeout必须为 0或正数。None为一直等下去，0为不等，正数n为等待n秒还不能读取，报empty异常。 字符串（string）用+拼接字符串： 将值转换为字符串的机制： 1、通过str函数，把值转换为合理形式的字符串，以便用户可以理解 2、通过repr函数创建一个字符串，以合法的python表达式的形式表示值 join和split： 字符串格式化方式： capitalize() 把字符串的第一个字符改为大写 casefold() 把整个字符串的所有字符改为小写 center(width) 将字符串居中，并使用空格填充至长度 width 的新字符串 count(sub[, start[, end]]) 返回 sub 在字符串里边出现的次数，start 和 end 参数表示范围，可选。 encode(encoding=’utf-8’, errors=’strict’) 以 encoding 指定的编码格式对字符串进行编码。 startswith(prefix[, start[, end]]) 检查字符串是否以 prefix 开头，是则返回 True，否则返回 False。start 和 end 参数可以指定范围检查，可选。 endswith(sub[, start[, end]])检查字符串是否以 sub 子字符串结束，如果是返回 True，否则返回 False。start 和 end 参数表示范围，可选。 startswith和endswith如果需要同时针对多个选项做检查，只需要给startswith和endswith提供包含可能选项的元祖。 expandtabs([tabsize=8]) 把字符串中的 tab 符号（\t）转换为空格，如不指定参数，默认的空格数是 tabsize=8。 find(sub[, start[, end]])检测 sub 是否包含在字符串中，如果有则返回索引值，否则返回 -1，start 和 end 参数表示范围，可选。 maketrans() 方法用于创建字符映射的转换表，对于接受两个参数的最简单的调用方式，第一个参数是字符串，表示需要转换的字符，第二个参数也是字符串表示转换的目标。 注：两个字符串的长度必须相同，为一一对应的关系。 translate(table)根据 table 的规则（可以由 str.maketrans(‘a’, ‘b’) 定制）转换字符串中的字符 index(sub[, start[, end]]) 跟 find 方法一样，不过如果 sub 不在 string 中会产生一个异常。 isalnum() 如果字符串至少有一个字符并且所有字符都是字母或数字则返回 True，否则返回 False。 isalpha() 如果字符串至少有一个字符并且所有字符都是字母则返回 True，否则返回 False。 isdecimal() 如果字符串只包含十进制数字则返回 True，否则返回 False。 isdigit() 如果字符串只包含数字则返回 True，否则返回 False。 islower() 如果字符串中至少包含一个区分大小写的字符，并且这些字符都是小写，则返回 True，否则返回 False。 isnumeric() 如果字符串中只包含数字字符，则返回 True，否则返回 False。 isspace() 如果字符串中只包含空格，则返回 True，否则返回 False。 istitle() 如果字符串是标题化（所有的单词都是以大写开始，其余字母均小写），则返回 True，否则返回 False。 isupper() 如果字符串中至少包含一个区分大小写的字符，并且这些字符都是大写，则返回 True，否则返回 False。 join(sub) 以字符串作为分隔符，插入到 sub 中所有的字符之间。 ljust(width) 返回一个左对齐的字符串，并使用空格填充至长度为 width 的新字符串。 rjust(width) 返回一个右对齐的字符串，并使用空格填充至长度为 width 的新字符串。 format也可以完成对齐的任务。“&lt;”：左对齐 “&gt;”：右对齐 “^”：居中对齐 lower() 转换字符串中所有大写字符为小写。 lstrip() 去掉字符串左边的所有空格无法去除中间的字符 rstrip() 删除字符串末尾的空格。无法去除中间的字符 partition(sub) 找到子字符串 sub，把字符串分成一个 3 元组 (pre_sub, sub, fol_sub)，如果字符串中不包含 sub 则返回 (‘原字符串’, ‘’, ‘’) replace(old, new[, count]) 把字符串中的 old 子字符串替换成 new 子字符串，如果 count 指定，则替换不超过 count 次。 rfind(sub[, start[, end]]) 类似于 find() 方法，不过是从右边开始查找。返回值是下标 rindex(sub[, start[, end]]) 类似于 index() 方法，不过是从右边开始。 rpartition(sub) 类似于 partition() 方法，不过是从右边开始查找。 split(sep=None, maxsplit=-1) 不带参数默认是以空格为分隔符切片字符串，如果 maxsplit 参数有设置，则仅分隔 maxsplit 个子字符串，返回切片后的子字符串拼接的列表。 splitlines(([keepends])) 在输出结果里是否去掉换行符，默认为 False，不包含换行符；如果为 True，则保留换行符。。 strip([chars]) 删除字符串前边和后边所有的空格，chars 参数可以定制删除的字符，可选。 swapcase() 翻转字符串中的大小写。 title() 返回标题化（所有的单词都是以大写开始，其余字母均小写）的字符串。 upper() 转换字符串中的所有小写字符为大写。 zfill(width) 返回长度为 width 的字符串，原字符串右对齐，前边用 0 填充。]]></content>
      <categories>
        <category>python</category>
        <category>数据类型</category>
      </categories>
      <tags>
        <tag>python数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我的第一篇博客]]></title>
    <url>%2F2019%2F08%2F03%2F%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[​ 你好陌生人，欢迎来到湛蓝星空的博客。这是我的第一篇博客，纠结了很久要不要写，因为我通常都是用一些笔记软件来记录学的一些知识。在这里，希望你能学到你希望学到的东西。 PS：本人实在太菜。如果有错误，请谅解。]]></content>
      <categories>
        <category>你好</category>
      </categories>
      <tags>
        <tag>你好</tag>
      </tags>
  </entry>
</search>
