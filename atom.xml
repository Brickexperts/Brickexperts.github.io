<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>DY的个人博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-08-08T06:54:48.073Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>湛蓝星空</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>opencv(5)</title>
    <link href="http://yoursite.com/2019/08/08/opencv-5/"/>
    <id>http://yoursite.com/2019/08/08/opencv-5/</id>
    <published>2019-08-08T06:35:27.000Z</published>
    <updated>2019-08-08T06:54:48.073Z</updated>
    
    <content type="html"><![CDATA[<h2 id="视频处理"><a href="#视频处理" class="headerlink" title="视频处理"></a>视频处理</h2><p>Videocapture：VideoCapture(args)：如果args=0，则打开摄像头。如果args=路径， 则打开视频源</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/opencv68.png" alt></p><p>摄像头设置和查询：</p><p>调用摄像头读取图像数据，以及使用</p><p>cap.set( propId ， value ) </p><p>cap.get( propId )</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/opencv69.png" alt></p><p>图片合成视频：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/opencv70.png" alt></p><p>视频分解图片：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/opencv71.png" alt></p><h2 id="normalize：归一化函数"><a href="#normalize：归一化函数" class="headerlink" title="normalize：归一化函数"></a>normalize：归一化函数</h2><p>为了消除指标之间的影响，需要对数据进行标准化处理，以解决数据指标之间的可比性</p><p>cv2.normalize(src[, dst[, alpha[, beta[, norm_type[, dtype[, mask]]]]]])</p><p>src:输入数组</p><p>dst:与src大小相同的输出数组</p><p>alpha:下限边界</p><p>beta:上限边界</p><p>norm_type:NORM_MINMAX  NORM_INF  NORM_L1 NORM_L2</p><p>dType:当输出为负时，输出数组具有与src相同的类型。否则，具有与src相同的信道数和深度</p><p>mask:掩膜</p><h2 id="画图"><a href="#画图" class="headerlink" title="画图"></a>画图</h2><p>cv2.rectangle（）：若将五改为-1，则填充整个矩形</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/opencv72.png" alt></p><p>cv2.circle：要画圆的话，只需要指定圆形的中心点坐标和半径大小，颜色和粗细</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/opencv73.png" alt></p><p>cv2.ellispe:一个参数是中心点的位置坐标。下一个参数是长轴和短轴的长度。椭圆沿逆时针方向旋转的角度。椭圆弧沿顺时针方向起始的角度和结束角度，如果是 0 到 360，就是整个椭圆。</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/opencv74.png" alt></p><h2 id="图像金字塔"><a href="#图像金字塔" class="headerlink" title="图像金字塔"></a>图像金字塔</h2><p>我们对同一图像的不同分辨率的子图像处理。比如我们在一幅图像中查找某个目标比如脸，我们不知目标在图像中的尺寸大小。这种情况下我们创建一组图，这些图像是具有不同分率的原始图像。我们把组图像叫做图像字塔简单来就是同一图像的不同分率的子图集合。如果我们把大的图像放在底部最小的放在顶部。看来像一座金字塔，故而得名图像金字塔。 </p><p>图像金字塔：高斯金字塔和拉普拉斯金字塔</p><p>向下采样：将图像缩小，图像信息丢失</p><p>向上采样：将图像放大，图像会变模糊</p><p>向下采样和向上采样不是可逆的，无法将图像变为原始图像。</p><p>向下采样函数：cv2.pyrDown(原始图像)</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/opencv75.png" alt></p><p>向上采样函数：cv2.pyrUP</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/opencv76.png" alt></p><p>拉普拉斯金字塔：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/opencv77.png" alt></p><h2 id="opencv删除窗口："><a href="#opencv删除窗口：" class="headerlink" title="opencv删除窗口："></a>opencv删除窗口：</h2><p>删除所有窗口 ：cv2.destroyAllWindow()        删除指定窗口：cv2.destroyWindow(“original”)</p><p>waitKey(x):参数为等待键盘触发的时间。单位为毫秒。如不输入参数，则输入任意键退出。</p><h2 id="setMouseCallback"><a href="#setMouseCallback" class="headerlink" title="setMouseCallback():"></a>setMouseCallback():</h2><p>event为事件</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/opencv78.png" alt></p><p>x，y代表鼠标位于窗口的（x，y）位置</p><p>flags：代表鼠标的拖曳事件以及鼠标和键盘联合的事件。共有32种</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/opencv79.png" alt></p><p>param：函数指针，标识所相应的事件函数。</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/opencv80.png" alt></p><h2 id="namewindow"><a href="#namewindow" class="headerlink" title="namewindow"></a>namewindow</h2><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/opencv82.png" alt></p><p>WINDOW_NORMAL    用户可以改变窗口的大小；</p><p>WINDOW_AUTOSIZE  窗口大小会根据显示图像自动调整，用户必能手动改变窗口大小；</p><p>WINDOW_OPENGL     支持OpenGL。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;视频处理&quot;&gt;&lt;a href=&quot;#视频处理&quot; class=&quot;headerlink&quot; title=&quot;视频处理&quot;&gt;&lt;/a&gt;视频处理&lt;/h2&gt;&lt;p&gt;Videocapture：VideoCapture(args)：如果args=0，则打开摄像头。如果args=路径， 则打开
      
    
    </summary>
    
      <category term="python" scheme="http://yoursite.com/categories/python/"/>
    
      <category term="opencv" scheme="http://yoursite.com/categories/python/opencv/"/>
    
      <category term="opencv(5)" scheme="http://yoursite.com/categories/python/opencv/opencv-5/"/>
    
    
      <category term="视觉处理" scheme="http://yoursite.com/tags/%E8%A7%86%E8%A7%89%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>opencv(4)</title>
    <link href="http://yoursite.com/2019/08/08/opencv-4/"/>
    <id>http://yoursite.com/2019/08/08/opencv-4/</id>
    <published>2019-08-08T06:15:03.000Z</published>
    <updated>2019-08-08T06:35:15.859Z</updated>
    
    <content type="html"><![CDATA[<h2 id="图像类型转换"><a href="#图像类型转换" class="headerlink" title="图像类型转换"></a>图像类型转换</h2><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/opencv63.png" alt></p><p>cvtColor:颜色空间转换函数</p><p>cv2.cvtColor()支持多种颜色空间之间的转换，其</p><p>需要注意的是cvtColor()函数不能直接将RGB图像转换为二值图像(Binary Image)，需要借助threshold()函数</p><p>HSV中：H为色彩，取值范围是[0,179]，S为饱和度，取值范围是[0,255],V是亮度，取值范围是[0,255]。</p><p>支持的转换类型和转换码如下：</p><p>1、RGB和BGR（opencv默认的彩色图像的颜色空间是BGR）颜色空间的转换</p><p>COLOR_BGR2RGB</p><p>COLOR_RGB2BGR</p><p>COLOR_RGBA2BGRA</p><p>COLOR_BGRA2RGBA</p><p>2、向RGB和BGR图像中增添alpha通道</p><p>COLOR_RGB2RGBA</p><p>COLOR_BGR2BGRA</p><p>3、从RGB和BGR图像中去除alpha通道</p><p>COLOR_RGBA2RGB</p><p>COLOR_BGRA2BGR</p><p>4、从RBG和BGR颜色空间转换到灰度空间</p><p>COLOR_RGB2GRAY</p><p>COLOR_BGR2GRAY</p><p>COLOR_RGBA2GRAY</p><p>COLOR_BGRA2GRAY</p><p>5、从灰度空间转换到RGB和BGR颜色空间</p><p>COLOR_GRAY2RGB</p><p>COLOR_GRAY2BGR</p><p>COLOR_GRAY2RGBA</p><p>COLOR_GRAY2BGRA</p><p>6、RGB和BGR颜色空间与BGR565颜色空间之间的转换</p><p>COLOR_RGB2BGR565</p><p>COLOR_BGR2BGR565</p><p>COLOR_BGR5652RGB</p><p>COLOR_BGR5652BGR</p><p>COLOR_RGBA2BGR565</p><p>COLOR_BGRA2BGR565</p><p>COLOR_BGR5652RGBA</p><p>COLOR_BGR5652BGRA</p><p>7、灰度空间域BGR565之间的转换</p><p>COLOR_GRAY2BGR555</p><p>COLOR_BGR5552GRAY</p><p>8、RGB和BGR颜色空间与CIE XYZ之间的转换</p><p>COLOR_RGB2XYZ</p><p>COLOR_BGR2XYZ</p><p>COLOR_XYZ2RGB</p><p>COLOR_XYZ2BGR</p><p>9、RGB和BGR颜色空间与uma色度（YCrCb空间）之间的转换</p><p>COLOR_RGB2YCrCb</p><p>COLOR_BGR2YCrCb</p><p>COLOR_YCrCb2RGB</p><p>COLOR_YCrCb2BGR</p><p>10、RGB和BGR颜色空间与HSV颜色空间之间的相互转换</p><p>COLOR_RGB2HSV</p><p>COLOR_BGR2HSV</p><p>COLOR_HSV2RGB</p><p>COLOR_HSV2BGR</p><p>11、RGB和BGR颜色空间与HLS颜色空间之间的相互转换</p><p>COLOR_RGB2HLS</p><p>COLOR_BGR2HLS</p><p>COLOR_HLS2RGB</p><p>COLOR_HLS2BGR</p><p>12、RGB和BGR颜色空间与CIE Lab颜色空间之间的相互转换</p><p>COLOR_RGB2Lab</p><p>COLOR_BGR2Lab</p><p>COLOR_Lab2RGB</p><p>COLOR_Lab2BGR</p><p>13、RGB和BGR颜色空间与CIE Luv颜色空间之间的相互转换</p><p>COLOR_RGB2Luv</p><p>COLOR_BGR2Luv</p><p>COLOR_Luv2RGB</p><p>COLOR_Luv2BGR</p><p>14、Bayer格式（raw data）向RGB或BGR颜色空间的转换</p><p>COLOR_BayerBG2RGB</p><p>COLOR_BayerGB2RGB</p><p>COLOR_BayerRG2RGB</p><p>COLOR_BayerGR2RGB</p><p>COLOR_BayerBG2BGR</p><p>COLOR_BayerGB2BGR</p><p>COLOR_BayerRG2BGR</p><p>COLOR_BayerGR2BGR</p><h2 id="inrange："><a href="#inrange：" class="headerlink" title="inrange："></a>inrange：</h2><p>实现二值化功能</p><p>image=cv2.inrance(hsv,lower_red,upper_red)</p><p>第一个参数：hsv指的是原图</p><p>第二个参数：lower_red指的是图像中低于这个lower_red的值，图像值变为0</p><p>第三个参数：upper_red指的是图像中高于这个upper_red的值，图像值变为0</p><p>而在lower_red～upper_red之间的值变成255</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/opencv64.png" alt></p><h2 id="图像中的与、或、异或、非操作"><a href="#图像中的与、或、异或、非操作" class="headerlink" title="图像中的与、或、异或、非操作"></a>图像中的与、或、异或、非操作</h2><p>opencv中的bitwise_not，bitwise_xor，bitwise_or，bitwise_and的使用方法与效果。</p><p>bitwise_and是对二进制数据进行“与”操作，即对图像（灰度图像或彩色图像均可）每个像素值进行二进制“与”操作，1&amp;1=1，1&amp;0=0，0&amp;1=0，0&amp;0=0。</p><p>bitwise_or是对二进制数据进行“或”操作，即对图像（灰度图像或彩色图像均可）每个像素值进行二进制“或”操作，1|1=1，1|0=0，0|1=0，0|0=0。</p><p>bitwise_xor是对二进制数据进行“异或”操作，即对图像（灰度图像或彩色图像均可）每个像素值进行二进制“异或”操作，1^1=0,1^0=1,0^1=1,0^0=0。</p><p>bitwise_not是对二进制数据进行“非”操作，即对图像（灰度图像或彩色图像均可）每个像素值进行二进制“非”操作，<del>1=0，</del>0=1。</p><h2 id="Hough直线变换"><a href="#Hough直线变换" class="headerlink" title="Hough直线变换"></a>Hough直线变换</h2><p>cv2.HoughLines()，返回值就是距离和角度。这个函数的第一个参数是一个二值化图像。第二个和第三个值代表距离和角度的精确度。第四个参数是阈值，只有累加其中的值高于阈值时才被认为是一条直线。</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/opencv65.png" alt></p><p>cv2.HoughLinesP():比上面多两个参数，minLineLength和MaxLineGap。比较简单</p><p>minLineLength：线的最短长度，比这个短的线都忽略</p><p>MaxLineGap：两条线段的最大间断，如果小于此值，这两条直线被看成一条直线</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/opencv66.png" alt></p><h2 id="Hough圆环变换："><a href="#Hough圆环变换：" class="headerlink" title="Hough圆环变换："></a>Hough圆环变换：</h2><p>HoughCircles(image, method, dp, minDist[, circles[, param1[, param2[, minRadius[, maxRadius]]]]])</p><p>image参数表示8位单通道灰度输入图像矩阵。</p><p>method参数表示圆检测方法，目前唯一实现的方法是HOUGH_GRADIENT。</p><p>dp参数表示累加器与原始图像相比的分辨率的反比参数。例如，如果dp = 1，则累加器具有与输入图像相同的分辨率。如果dp=2，累加器分辨率是元素图像的一半，宽度和高度也缩减为原来的一半。</p><p>minDist参数表示检测到的两个圆心之间的最小距离。如果参数太小，除了真实的一个圆圈之外，可能错误地检测到多个相邻的圆圈。如果太大，可能会遗漏一些圆圈。</p><p>circles参数表示检测到的圆的输出向量，向量内第一个元素是圆的横坐标，第二个是纵坐标，第三个是半径大小。</p><p>param1参数表示Canny边缘检测的高阈值，低阈值会被自动置为高阈值的一半。</p><p>param2参数表示圆心检测的累加阈值，参数值越小，可以检测越多的假圆圈，但返回的是与较大累加器值对应的圆圈。</p><p>minRadius参数表示检测到的圆的最小半径。</p><p>maxRadius参数表示检测到的圆的最大半径</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/opencv67.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;图像类型转换&quot;&gt;&lt;a href=&quot;#图像类型转换&quot; class=&quot;headerlink&quot; title=&quot;图像类型转换&quot;&gt;&lt;/a&gt;图像类型转换&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Brickexper
      
    
    </summary>
    
      <category term="python" scheme="http://yoursite.com/categories/python/"/>
    
      <category term="opencv" scheme="http://yoursite.com/categories/python/opencv/"/>
    
      <category term="opencv(4)" scheme="http://yoursite.com/categories/python/opencv/opencv-4/"/>
    
    
      <category term="视觉处理" scheme="http://yoursite.com/tags/%E8%A7%86%E8%A7%89%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>opencv(3)</title>
    <link href="http://yoursite.com/2019/08/08/opencv-3/"/>
    <id>http://yoursite.com/2019/08/08/opencv-3/</id>
    <published>2019-08-08T05:44:27.000Z</published>
    <updated>2019-08-08T06:59:24.588Z</updated>
    
    <content type="html"><![CDATA[<h2 id="图像轮廓"><a href="#图像轮廓" class="headerlink" title="图像轮廓"></a>图像轮廓</h2><p>和图像边缘不一样，边缘不连续。将边缘连接成一个整体构成轮廓。</p><p>提取图像轮廓的方法：先调用cv2.findContours()，后调用cv2.drawCont()</p><p>cv2.findCount函数使用方法:</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/opencv42.png" alt></p><p>参数mode的几种方式：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/opencv43.png" alt></p><p>参数method的几种方法：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/opencv44.png" alt></p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/opencv45.png" alt></p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/opencv46.png" alt></p><h2 id="轮廓特征："><a href="#轮廓特征：" class="headerlink" title="轮廓特征："></a>轮廓特征：</h2><p>cv2.moments()会将计算得到的<strong>矩</strong>以一个字典的形式返回。</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/20190808134950.png" alt></p><p><strong>轮廓面积</strong>可以使用函数 cv2.contourArea() 计算得到</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/opencv47.png" alt></p><p><strong>轮廓周长</strong>：cv2.arcLength(cnt，True) 函数的第二个参数用来指定对象的形状是闭合的(True)，还是打开的。</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/opencv448.png" alt></p><p><strong>轮廓近似</strong>：cv2.approxPolyDP(cnt，epsilon，True)</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/opencv54.png" alt></p><p><strong>凸包</strong>：函数cv2.convexHull() 可以用来检测一个曲线是否具有凸性缺陷并能纠正凸性缺陷。凸性曲线总是凸出来的，至少是平的。如果有地方凹去了就叫做凸性缺陷。</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/opencv49.png" alt></p><p><strong>凸性检测</strong>：cv2.isContourConvex()可以用来检测一个曲线是不是凸的，返回True和False。</p><p><strong>边界矩形</strong>：直边界矩形和旋转的边界矩形。</p><p><strong>直边界矩形</strong>：面积不是最小的。x,y,w,h=cv2.boundingRect()。x,y,为矩形左上角的坐标，w,h为矩形的宽和高</p><p><strong>旋转的边界矩形</strong>：面积最小。考虑了对象的旋转。cv2.minAreaRect())。返回的是一个 Box2D 结构，其中包含矩形左上点的坐标x，y矩形的宽和高w，h以及旋度。但是绘制个矩形矩形的 4 个点可以函数cv2.boxPoints() 获 得。</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/opencv50.png" alt></p><p><strong>最小外接圆</strong>：cv2.minEnlosingCircle()</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/opencv51.png" alt></p><p><strong>椭圆拟合</strong>：旋转边界矩形的内切圆   cv2.fitEllipse(cnt)</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/opencv52.png" alt></p><p><strong>形状匹配</strong>：cv2.matchShape()可以帮我们比较两个形状或轮廓的相似度。返回值越小，匹配越好。</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/opencv53.png" alt></p><h2 id="getStructuringElement"><a href="#getStructuringElement" class="headerlink" title="getStructuringElement"></a>getStructuringElement</h2><p>构建一个核。前面腐蚀膨胀的numpy构建的结构化元素是正方形的</p><p>getStructuringElement  与 Numpy 定义的元素结构是完全一样的这个函数的第一个参数表示内核的形状，有三种形状可以选择。</p><p>矩形：MORPH_RECT;</p><p>交叉形：MORPH_CROSS;</p><p>椭圆形：MORPH_ELLIPSE;</p><p>第二和第三个参数分别是内核的尺寸以及锚点的位置。对于锚点的位置，有默认值（-1,-1），表示锚点位于中心点。element形状唯一依赖锚点位置，其他情况下，锚点只是影响了形态学运算结果的偏移。</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/opencv55.png" alt></p><h2 id="透视变换"><a href="#透视变换" class="headerlink" title="透视变换"></a>透视变换</h2><p>在不同的视觉拍摄同一个物体，会有不同的图像。透视变换就是类似于改变拍摄物体的角度</p><p>仿射变换：由平移、错切、缩放、反转、旋转复合而成，是透视变换的特殊形式</p><p>OpenCV提供了两个变换函数cv2.warpAﬃne(仿射变换)和cv2.warpPerspective(透视变换) ，cv2.warpAﬃne 接收的参数是 2×3 的变换矩阵，而cv2.warpPerspective 接收的参数是 3×3 的变换矩阵。</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/opencv56.png" alt></p><p>函数cv2.warpAﬃne() 的第三个参数的是输出图像的大小。它的格式应是图像的(宽,高)。注意的是图像的宽对应的是列数，高对应的是行数。可以实现图片平移。可以和cv2.getAffineTransform配合使用</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/opencv57.png" alt></p><p>其中两个参数是变换前后的位置关系</p><p>函数cv2.warpPerspective配合cv2.getPerspectiveTransform()使用。同时可以用findHomography返回的单应性矩阵。</p><p>getPersonspectiveTransform得出变换矩阵：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/opencv58.png" alt></p><p>得出变换矩阵以后用warpPerspective()：第一个参数是输入图像，M是变换矩阵，第三个参数是输出图像的大小</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/opencv60.png" alt></p><p>getPerspectiveTransform和findHomography的区别：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/opencv59.png" alt></p><h2 id="旋转：cv2-getRotationMatrix2D"><a href="#旋转：cv2-getRotationMatrix2D" class="headerlink" title="旋转：cv2.getRotationMatrix2D()"></a>旋转：cv2.getRotationMatrix2D()</h2><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/opencv62.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;图像轮廓&quot;&gt;&lt;a href=&quot;#图像轮廓&quot; class=&quot;headerlink&quot; title=&quot;图像轮廓&quot;&gt;&lt;/a&gt;图像轮廓&lt;/h2&gt;&lt;p&gt;和图像边缘不一样，边缘不连续。将边缘连接成一个整体构成轮廓。&lt;/p&gt;
&lt;p&gt;提取图像轮廓的方法：先调用cv2.findCon
      
    
    </summary>
    
      <category term="python" scheme="http://yoursite.com/categories/python/"/>
    
      <category term="opencv" scheme="http://yoursite.com/categories/python/opencv/"/>
    
      <category term="opencv(3)" scheme="http://yoursite.com/categories/python/opencv/opencv-3/"/>
    
    
      <category term="视觉处理" scheme="http://yoursite.com/tags/%E8%A7%86%E8%A7%89%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>opencv(2)</title>
    <link href="http://yoursite.com/2019/08/08/opencv-2/"/>
    <id>http://yoursite.com/2019/08/08/opencv-2/</id>
    <published>2019-08-08T05:12:56.000Z</published>
    <updated>2019-08-08T05:44:13.181Z</updated>
    
    <content type="html"><![CDATA[<p>图像滤波：即在尽量保留图像细节特征的条件下对目标图像的噪声进行抑制，是图像预处理中不可缺少的操作，其处理效果的好坏将直接影响到后续图像处理和分析的有效性和可靠性。</p><h2 id="图像滤波"><a href="#图像滤波" class="headerlink" title="图像滤波"></a>图像滤波</h2><p>图像滤波的目的   a、消除图像中混入的噪声       b、为图像识别抽取出图像特征</p><p><strong>均值滤波</strong>，用blur函数</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/opencv22.png" alt></p><p><strong>方框滤波</strong>：进行归一化处理后，和均值滤波相同。当normalize为零时，不进行归一化处理。当normalize为一时，进行归一化处理（默认）。目标图像深度通常于原始图像一样，值为-1。</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/opencv23.png" alt></p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/opencv24.png" alt></p><p><strong>高斯滤波</strong>：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/opencv25.png" alt></p><p><strong>注意</strong>：ksize：核大小必须为单数        sigmaX、sigmaY：控制权重</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/opencv26.png" alt></p><p><strong>中值滤波</strong>：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/opencv27.png" alt></p><p>两种边缘保留滤波：</p><p><strong>biateraFilter</strong>：能在保持边界清晰的情况下有效的去除噪音</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/opencv28.png" alt></p><p><strong>filter2D</strong>:对2D图像实施低通滤波。去除噪音，模糊图像</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/opencv29.png" alt></p><h2 id="膨胀和腐蚀"><a href="#膨胀和腐蚀" class="headerlink" title="膨胀和腐蚀"></a>膨胀和腐蚀</h2><p>膨胀、腐蚀时用到的kernel的形状一般有下面三种： </p><p>矩形: MORPH_RECT </p><p>交叉形: MORPH_CROSS </p><p>椭圆形: MORPH_ELLIPSE </p><p><strong>图像腐蚀</strong>：调用erode函数</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/opencv30.png" alt></p><p><strong>图像膨胀</strong>：调用dialate</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/opencv31.png" alt></p><p><strong>开运算</strong>：先通过图像腐蚀，后经过图像膨胀可以图像去噪。iteration表示次数</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/opencv32.png" alt></p><p><strong>闭运算</strong>：先是先通过图像膨胀，后经过图像腐蚀</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/opencv33.png" alt></p><p><strong>梯度运算</strong>：图像膨胀-图像腐蚀</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/opencv34.png" alt></p><p><strong>图像礼帽（图像顶帽）</strong>：原始图像-开运算图像，得到噪声图像</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/opencv35.png" alt></p><p><strong>图像黑帽</strong>：闭运算-原始图像</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/opencv36.png" alt></p><h2 id="求梯度"><a href="#求梯度" class="headerlink" title="求梯度"></a>求梯度</h2><p>梯度简单来说就是求导。Sobel，Scharr是求一阶导数或二阶导数。Scharr是对Sobel的优化。Laplacian是求二阶导数。</p><p>Sobel算子：当一个像素右边的值减去左边的值不为零，该像素为边界。</p><p>计算梯度的函数：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/opencv37.png" alt></p><p>ddepth通常取cv2.CV_64F。</p><p>dx=0,dy=1计算y轴的边界,dx=1,dy=0计算x轴的边界。满足条件dx&gt;=0&amp;&amp;dy&gt;=0&amp;&amp;dx+dy=1</p><p>将图像中的负值转为正：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/opencv38.png" alt></p><p>将一个图像的边缘提取出来：如果没有converScaleAbs，所有的负值都会被截断为0.换句话就是把边界丢掉。</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/opencv39.png" alt></p><p>Scharr算子：比sobel算子精准，使用方法基本一样</p><p>计算梯度调用函数：cv2.Scharr(src,ddpetch,dx,dy)</p><p>des=cv2.Scharr(src,ddpetch,dx,dy) 等价于des=cv2.Sobel(src,ddpetch,dx,dy,-1)</p><h2 id="为图像扩边：cv2-copyMakeBorder"><a href="#为图像扩边：cv2-copyMakeBorder" class="headerlink" title="为图像扩边：cv2.copyMakeBorder()"></a>为图像扩边：cv2.copyMakeBorder()</h2><p>src:原图图像</p><p>top,bottom,left,right分别表示在原图四周扩充边缘的大小</p><p>borderType：扩充边缘的类型，就是外插的类型，OpenCV中给出以下几种方式</p><p>  * BORDER_REPLICATE</p><p>  * BORDER_REFLECT</p><p>  * BORDER_REFLECT_101</p><p>  * BORDER_WRAP</p><p>  * BORDER_CONSTANT</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/opencv40.png" alt></p><h2 id="canny函数提取图片边缘"><a href="#canny函数提取图片边缘" class="headerlink" title="canny函数提取图片边缘"></a>canny函数提取图片边缘</h2><p>cv2.canny(img,threshold1,threshold2)    img代表原始图像，threshold1、threshold2为阈值。两个阈值越小，得出图像边缘越详细。反之，边框越边缘。</p><p>提取原理步骤：1、高斯模糊 - GaussianBlur  2、灰度转换 - cvtColor  3、计算梯度 – Sobel/Scharr  4、非最大信号抑制5、高低阈值输出二值图像</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/opencv41.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;图像滤波：即在尽量保留图像细节特征的条件下对目标图像的噪声进行抑制，是图像预处理中不可缺少的操作，其处理效果的好坏将直接影响到后续图像处理和分析的有效性和可靠性。&lt;/p&gt;
&lt;h2 id=&quot;图像滤波&quot;&gt;&lt;a href=&quot;#图像滤波&quot; class=&quot;headerlink&quot; ti
      
    
    </summary>
    
      <category term="python" scheme="http://yoursite.com/categories/python/"/>
    
      <category term="opencv" scheme="http://yoursite.com/categories/python/opencv/"/>
    
      <category term="opencv(2)" scheme="http://yoursite.com/categories/python/opencv/opencv-2/"/>
    
    
      <category term="视觉处理" scheme="http://yoursite.com/tags/%E8%A7%86%E8%A7%89%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>opencv(1)</title>
    <link href="http://yoursite.com/2019/08/08/opencv-1/"/>
    <id>http://yoursite.com/2019/08/08/opencv-1/</id>
    <published>2019-08-08T03:32:09.000Z</published>
    <updated>2019-08-08T05:28:39.361Z</updated>
    
    <content type="html"><![CDATA[<p>​    因为我是对图像处理的方面比较感兴趣的。所以我也是对python的视觉处理模块<strong>opencv</strong>进行了学习。这个模块虽然是传统方法，但还是蛮有用的。而且它有上千个API，我总结了以下我所学到的。开始吧。</p><p>cv2是opencv的扩展模块。</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/opencv1.png" alt>    </p><p>imread第二个参数类型:</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/opencv2.png" alt></p><p>cv2.imwrite:保存图片</p><p><strong>下文中：绝对路径代表绝对路径也行</strong> </p><p>改变图片某行某列的像素：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/opencv3.png" alt></p><p>批量改变图片像素：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/opencv4.png" alt></p><p>获取图像属性：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/opencv5.png" alt></p><p>拆分通道：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/opencv6.png" alt></p><p>合并通道：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/opencv8.png" alt></p><p>图片移位：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/opencv9.png" alt></p><p>将两张图片加在一起：1、取模加法   2、饱和运算</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/opencv10.png" alt></p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/opencv11.png" alt></p><p><strong>注意</strong>：两张图片的大小和类型相等</p><p>减法(subtract)、乘法(multiply)和除法(divide)和加法(add)类似</p><p>图像融合：将两张或两张以上的图片融合到一张图片上</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/20190808132723.png" alt></p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/opencv12.png" alt></p><p>图像缩放（参数必须为整数）：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/opencv13.png" alt></p><p>图像翻转：调用cv2.flip(原始图像，flipcode)</p><p>三种情况：</p><p>filpcode=0：以x轴为对称轴的上下翻转</p><p>flipcode&gt;0:以Y轴为对称轴的左右翻转</p><p>flipcode&lt;0:X、Y轴各翻转一次</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/opencv14.png" alt></p><p>图像颜色反转：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/opencv16.png" alt></p><p>图片打上马赛克：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/opencv17.png" alt></p><p>图片上写字：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/opencv18.png" alt></p><p>图片修补：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/opencv19.png" alt></p><p>图片亮度增强：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/opencv20.png" alt></p><p>图像阈值分割：调用了threshold函数</p><p>五种分割方法：</p><p>二进制阈值化（cv2.THRESH_BINARY）：选定一个阈值，用每一个像素的阈值和该阈值比较，大于该阈值则将该像素阈点值设为最大，若小于该阈值，则将该像素点阈值设为零。</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/opencv21.png" alt></p><p>反二进制阈值化（cv.THRESH_BINARY_INV）：选定一个阈值，用每一个像素的阈值和该阈值比较，大于该阈值则将该像素点的阈值设为零，若小于该阈值，则将该像素点阈值设为最大。</p><p>截断阈值化（cv.THRESH_TRUNC）：选定个阈值，用每一个像素的阈值和该阈值比较，大于该阈值则将该像素点的阈值设为该阈值，小于该阈值的像素点的阈值不变。</p><p>阈值化为0（THRESH_TOZERO）：先选定一个阈值，像素点的灰度值大于该阈值的不进行任何改变；像素点的灰度值小于该阈值的，其灰度值全部变为0。 </p><p>反阈值化为0(THRESH_TOZERO_INV)：先选定一个阈值，像素点的灰度值小于该阈值的不进行任何改变；像素点的灰度值大于该阈值的，其灰度值全部变为0。</p><p>还有另一种阈值分割函数：自适应阈值函数  <strong>cv2.adaptiveThreshold()</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;​    因为我是对图像处理的方面比较感兴趣的。所以我也是对python的视觉处理模块&lt;strong&gt;opencv&lt;/strong&gt;进行了学习。这个模块虽然是传统方法，但还是蛮有用的。而且它有上千个API，我总结了以下我所学到的。开始吧。&lt;/p&gt;
&lt;p&gt;cv2是opencv
      
    
    </summary>
    
      <category term="python" scheme="http://yoursite.com/categories/python/"/>
    
      <category term="opencv" scheme="http://yoursite.com/categories/python/opencv/"/>
    
      <category term="opencv(1)" scheme="http://yoursite.com/categories/python/opencv/opencv-1/"/>
    
    
      <category term="视觉处理" scheme="http://yoursite.com/tags/%E8%A7%86%E8%A7%89%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>时间模块</title>
    <link href="http://yoursite.com/2019/08/08/%E6%97%B6%E9%97%B4%E6%A8%A1%E5%9D%97/"/>
    <id>http://yoursite.com/2019/08/08/时间模块/</id>
    <published>2019-08-08T01:59:51.000Z</published>
    <updated>2019-08-08T03:27:50.758Z</updated>
    
    <content type="html"><![CDATA[<p>​    今天我们来讲一下python里面的时间模块。time 模块提供各种时间相关的功能。在 Python 中，与时间处理有关的模块包括：time，datetime 以及 calendar。</p><p>首先先来一波术语解释：</p><p>时间戳（timestamp）的方式：通常来说，时间戳表示的是从 1970 年 1 月 1 日 00:00:00 开始按秒计算的偏移量（time.gmtime(0)）此模块中的函数无法处理 1970 纪元年以前的日期和时间或太遥远的未来（处理极限取决于 C 函数库，对于 32 位系统来说，是 2038 年）</p><p>UTC（Coordinated Universal Time，世界协调时）也叫格林威治天文时间，是世界标准时间。在中国为 UTC+8</p><p>DST（Daylight Saving Time）即夏令时的意思。一些实时函数的计算精度可能低于它们建议的值或参数，例如在大部分 Unix 系统，时钟一秒钟“滴答”50~100 次</p><p>gmtime()，localtime()和 strptime() 以时间元祖（struct_time）的形式返回。</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/time1.png" alt></p><p><strong>注一</strong>：范围真的是0-61.这是基于历史原因。</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/time2.png" alt></p><p>##time</p><p> <strong>time.altzone</strong>：返回格林威治西部的夏令时地区的偏移秒数；如果该地区在格林威治东部会返回负值（如西欧，包括英国）；对夏令时启用地区才能使用。</p><p> <strong>time.asctime([t])</strong>：接受时间元组并返回一个可读的形式为”Tue Dec 11 18:07:14 2015”（2015年12月11日 周二 18时07分14秒）的 24 个字符的字符串。</p><p><strong>time.clock()</strong>：用以浮点数计算的秒数返回当前的 CPU 时间。用来衡量不同程序的耗时，比 time.time() 更有用。<em>Python 3.3 以后不被推荐，由于该方法依赖操作系统，建议使用 perf_counter() 或 process_time() 代替（一个返回系统运行时间，一个返回进程运行时间，请按照实际需求选择）</em></p><p><strong>time.ctime([secs])</strong> ：作用相当于 asctime(localtime(secs))，未给参数相当于 asctime()</p><p><strong>time.gmtime([secs])</strong>：接收时间辍（1970 纪元年后经过的浮点秒数）并返回格林威治天文时间下的时间元组 t（注：t.tm_isdst 始终为 0）</p><p><strong>time.daylight</strong>：如果夏令时被定义，则该值为非零。</p><p><strong>time.localtime([secs])</strong>：接收时间辍（1970 纪元年后经过的浮点秒数）并返回当地时间下的时间元组 t（t.tm_isdst 可取 0 或 1，取决于当地当时是不是夏令时）</p><p><strong>time.mktime(t)</strong>：接受时间元组并返回时间辍（1970纪元后经过的浮点秒数）</p><p><strong>time.perf_counter()</strong>：返回计时器的精准时间（系统的运行时间），包含整个系统的睡眠时间。由于返回值的基准点是未定义的，所以，只有连续调用的结果之间的差才是有效的。</p><p><strong>time.process_time()</strong> ：返回当前进程执行 CPU 的时间总和，不包含睡眠时间。由于返回值的基准点是未定义的，所以，只有连续调用的结果之间的差才是有效的。</p><p><strong>time.sleep(secs)</strong>：推迟调用线程的运行，secs 的单位是秒。 </p><p><strong>time.clock()</strong>：用以浮点数计算的秒数返回当前的 CPU 时间。用来衡量不同程序的耗时，比 time.time() 更有用。</p><p><em>Python 3.3</em> <em>以后不被推荐，由于该方法依赖操作系统，建议使用</em> <em>perf_counter()</em> <em>或</em> <em>process_time()</em> <em>代替（一个返回系统运行时间，一个返回进程运行时间，请按照实际需求选择）</em></p><p><strong>time.time()</strong>：返回当前时间的时间戳（1970 纪元年后经过的浮点秒数）</p><p><strong>time.timezone</strong>：time.timezone 属性是当地时区（未启动夏令时）距离格林威治的偏移秒数（美洲 &gt;0；大部分欧洲，亚洲，非洲 &lt;= 0）</p><p><strong>time.tzname</strong>：time.tzname 属性是包含两个字符串的元组：第一是当地非夏令时区的名称，第二个是当地的 DST 时区的名称。</p><p><strong>time.strftime(format[, t])</strong> ：把一个代表时间的元组或者 struct_time（如由 time.localtime() 和 time.gmtime() 返回）转化为格式化的时间字符串。如果 t 未指定，将传入 time.localtime()。如果元组中任何一个元素越界，将会抛出 ValueError 异常。</p><p><strong>time.strptime(string[, format])</strong>：把一个格式化时间字符串转化为 struct_time。实际上它和 strftime() 是逆操作</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/time5.png" alt></p><p>format 格式如下：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/time3.png" alt></p><p>注1：“%p”只有与“%I”配合使用才有效果。</p><p>注2：范围真的是*0 ~ 61（你没有看错哦）；60代表闰秒，61是基于历史原因保留。</p><p>注3：当使用 strptime() 函数时，只有当在这年中的周数和天数被确定的时候%U <em>和</em> %W 才会被计算。</p><h2 id="datetime"><a href="#datetime" class="headerlink" title="datetime"></a>datetime</h2><p><strong>datetime.today()</strong>：返回一个表示当前本地时间的 datetime 对象，等同于 datetime.fromtimestamp(time.time())</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/time6.png" alt></p><p><strong>datetime.now(tz=None)</strong>：返回一个表示当前本地时间的 datetime 对象；如果提供了参数 tz，则获取 tz 参数所指时区的本地时间</p><p><strong>datetime.utcnow()</strong>:返回一个当前 UTC 时间的 datetime 对象</p><p><strong>datetime.fromtimestamp(timestamp, tz=None)</strong>: 根据时间戮创建一个 datetime 对象，参数 tz 指定时区信息</p><p><strong>datetime.utcfromtimestamp(timestamp)</strong>: 根据时间戮创建一个 UTC 时间的 datetime 对象</p><p><strong>datetime.fromordinal(ordinal)</strong>: 返回对应 Gregorian 日历时间对应的 datetime 对象</p><p><strong>datetime.combine(date, time)</strong>: 根据参数 date 和 time，创建一个 datetime 对象</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/time10.png" alt></p><p><strong>datetime.strptime(date_string, format)</strong>: 将格式化字符串转换为 datetime 对象</p><p><strong>datetime.timedelta</strong>对象代表两个时间之间的时间差，两个date或datetime对象相减就可以返回一个timedelta对象。</p><p>*<em>datetime.timedelta([days[, seconds[, microseconds[, milliseconds[, minutes[, hours[, weeks]]]]]]]) *</em></p><p>往前算：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/time7.png" alt></p><p>往后算：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/time8.png" alt></p><p><strong>datetime.date()</strong>：返回一个 date 对象datetime.time() - 返回一个 time 对象（tzinfo 属性为 None）</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/time9.png" alt></p><p><strong>datetime.timetz()</strong>： 返回一个 time() 对象（带有 tzinfo 属性）</p><p><strong>datetime.replace([year[, month[, day[, hour[, minute[, second[, microsecond[, tzinfo]]]]]]]])</strong>： 生成一个新的日期对象，用参数指定日期和时间代替原有对象中的属性</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/time11.png" alt></p><p><strong>datetime.astimezone(tz=None)</strong>： 传入一个新的 tzinfo 属性，返回根据新时区调整好的 datetime 对象</p><p><strong>datetime.utcoffset()</strong>：如果 tzinfo 属性是 None，则返回 None；否则返回 self.tzinfo.utcoffset(self)</p><p><strong>datetime.dst()</strong>：如果 tzinfo 属性是 None，则返回 None；否则返回 self.tzinfo.dst(self)</p><p><strong>datetime.tzname()</strong>：如果 tzinfo 属性是 None，则返回 None；否则返回 self.tzinfo.tzname(self)</p><p><strong>datetime.timetuple()</strong>：返回日期对应的 time.struct_time 对象（类似于 time模块的 time.localtime()）</p><p><strong>datetime.utctimetuple()</strong>：返回 UTC 日期对应的 time.struct_time 对象</p><p><strong>datetime.toordinal()</strong>：返回日期对应的 Gregorian Calendar 日期（类似于 self.date().toordinal()）</p><p><strong>datetime.timestamp()</strong>：返回当前时间的时间戳（类似于 <a href="http://bbs.fishc.com/thread-51326-1-1.html" target="_blank" rel="noopener">time 模块</a>的 time.time()）</p><p><strong>datetime.weekday()</strong>：返回 0 ~ 6 表示星期几（星期一是 0，依此类推）</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/time12.png" alt></p><p><strong>datetime.isoweekday()</strong>： 返回 1 ~ 7 表示星期几（星期一是1， 依此类推）</p><p><strong>datetime.isocalendar()</strong> ：返回一个三元组格式 (year, month, day)</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/time13.png" alt></p><p><strong>datetime.isoformat(sep=’T’)</strong>：返回一个 ISO 8601 格式的日期字符串，如 “YYYY-MM-DD” 的字符串</p><p><strong>datetime.__str__()</strong>：对于 date 对象 d 来说，str(d) 相当于 d.isoformat()</p><p><strong>datetime.ctime()</strong>：返回一个表示日期的字符串，相当于 time模块的 time.ctime(time.mktime(d.timetuple()))</p><p><strong>datetime.strftime(format)</strong>:返回自定义格式化字符串表示日期。</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/time14.png" alt></p><p><strong>datetime.__format__(format)</strong>跟 datetime.strftime(format) 一样，这使得调用 str.format() 时可以指定 data 对象的字符串</p><h2 id="calendar"><a href="#calendar" class="headerlink" title="calendar"></a>calendar</h2><p>calendar.calendar(year,w,l,c)(year为年份，w是每日宽度，c为间隔距离，l为每星期行数) 日历</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/time15.png" alt></p><p>*<em>calendar.isleap(year) *</em>：如果是闰年就返回True，否则返回False</p><p><strong>calendar.leapdays(y1,y2)</strong>：返回y1与y2两年间的闰年总数</p><p>*<em>calendar.month(year,month,w,l) *</em>：year代表年份，month代表月日历，每行宽度间隔为w，l是每星期的行数</p><p>*<em>calendar.prcal *</em>：相当于print(calendar.calendar(year,w,l,c))</p><p><strong>calendar.prmonth(year,month,w,l)</strong>：相当于print(calendar.calendar(year,w,l,c))</p><p><strong>calendar.weekday(year,month,day)</strong>： 返回指定日期的日期码，0-6（星期），1-12（月份）</p><p><strong>calendar.firstweekday()</strong>返回当前起始日期的设置</p><p><strong>calendar.setfirstweekday()</strong>：设置每周的起始日期码</p><p><strong>calendar.timegm</strong>(时间元祖) 和time.gmtime相反</p><p><strong>calendar.monthrange(year,month)</strong>：返回两个整数。第一个是该月第一天是星期几的日期码，第二个是该月的日期码。日从0（星期一）到6（星期日）;月从1到12。</p><h2 id="timeit"><a href="#timeit" class="headerlink" title="timeit"></a>timeit</h2><p>测试一个函数的执行时间：timeit.timeit</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/time16.png" alt></p><p>timeit.repeat:返回一个包含了每次实验的执行时间的列表</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/time17.png" alt></p><p>三个时间模块的函数特别多，我也没有一一去试。用到的时候才会深究，各位看官根据自己的情况来试着使用起来吧。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;​    今天我们来讲一下python里面的时间模块。time 模块提供各种时间相关的功能。在 Python 中，与时间处理有关的模块包括：time，datetime 以及 calendar。&lt;/p&gt;
&lt;p&gt;首先先来一波术语解释：&lt;/p&gt;
&lt;p&gt;时间戳（timestamp）
      
    
    </summary>
    
      <category term="python" scheme="http://yoursite.com/categories/python/"/>
    
      <category term="时间管理" scheme="http://yoursite.com/categories/python/%E6%97%B6%E9%97%B4%E7%AE%A1%E7%90%86/"/>
    
    
      <category term="python时间管理" scheme="http://yoursite.com/tags/python%E6%97%B6%E9%97%B4%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>python常用模块（3）</title>
    <link href="http://yoursite.com/2019/08/07/python%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97%EF%BC%883%EF%BC%89/"/>
    <id>http://yoursite.com/2019/08/07/python常用模块（3）/</id>
    <published>2019-08-07T07:01:22.000Z</published>
    <updated>2019-08-07T07:36:34.051Z</updated>
    
    <content type="html"><![CDATA[<h2 id="textwrap"><a href="#textwrap" class="headerlink" title="textwrap"></a>textwrap</h2><p>用来重新格式化文本的输出</p><p>fill() 调整换行符,每行显示给定宽度</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/textwrap1.png" alt></p><p>dedent()：去除缩进</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/textwrap2.png" alt></p><p>indent():给定前缀</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/textwrap3.png" alt></p><p>首行缩进：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/textwrap4.png" alt></p><p>多余的省略号：shorter()</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/wraptext5.png" alt></p><p>wrap():wrap(s,width) 以单词为单位(包括字符)最大长度不超过width个字符</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/wraptext6.png" alt></p><h2 id="itertools"><a href="#itertools" class="headerlink" title="itertools"></a>itertools</h2><p>Python的内建模块itertools提供了非常有用的用于操作迭代对象的函数</p><p><strong>count</strong>()会创建一个无限的迭代器，所以下述代码会打印出自然数序列，根本停不下来，只能按Ctrl+C退出。</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/itertools.png" alt></p><p><strong>cycle()</strong>会把传入的一个序列无限重复下去：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/itertools1.png" alt></p><p><strong>repeat()</strong>负责把一个元素无限重复下去，不过如果提供第二个参数就可以限定重复次数：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/itertools2.png" alt></p><p><strong>chain()</strong>可以把一组迭代对象串联起来，形成一个更大的迭代器：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/itertools3.png" alt></p><p><strong>groupby()</strong>把迭代器中相邻的重复元素挑出来放在一起：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/itertools5.png" alt></p><p>实际上挑选规则是通过函数完成的，只要作用于函数的两个元素返回的值相等，这两个元素就被认为是在一组的，而函数返回值作为组的key。如果我们要忽略大小写分组，就可以让元素’A’和’a’都返回相同的key：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/itertools6.png" alt></p><p><strong>permutations()</strong>:输出输入序列的全排列,考虑顺序</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/itertools7.png" alt></p><p><strong>combinations()</strong>:同上，不过不考虑顺序</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/itertools8.png" alt></p><p><strong>product()</strong>:输出输入序列的笛卡儿积</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/itertools9.png" alt></p><p><strong>compress</strong>：可以对一个序列的筛选结果施加到另一个相关的序列上</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/itertools10.png" alt></p><p><strong>dropwhile()</strong>:筛选满足条件的元素</p><p><strong>islice()</strong>：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/itertools11.png" alt></p><p><strong>zip_longest</strong>：zip可产生元祖。当其中摸个输入序列中没有元素可以继续迭代时，迭代过程结束。所以整个迭代的长度和最短的输入序列相同。</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/itertools12.png" alt></p><p>如果不想这样就用zip_longest：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/itertools13.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;textwrap&quot;&gt;&lt;a href=&quot;#textwrap&quot; class=&quot;headerlink&quot; title=&quot;textwrap&quot;&gt;&lt;/a&gt;textwrap&lt;/h2&gt;&lt;p&gt;用来重新格式化文本的输出&lt;/p&gt;
&lt;p&gt;fill() 调整换行符,每行显示给定宽度&lt;/p&gt;

      
    
    </summary>
    
      <category term="python" scheme="http://yoursite.com/categories/python/"/>
    
      <category term="常用模块" scheme="http://yoursite.com/categories/python/%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/"/>
    
      <category term="常用模块（3）" scheme="http://yoursite.com/categories/python/%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97%EF%BC%883%EF%BC%89/"/>
    
    
      <category term="python常用模块" scheme="http://yoursite.com/tags/python%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/"/>
    
  </entry>
  
  <entry>
    <title>python常用模块（2）</title>
    <link href="http://yoursite.com/2019/08/07/python%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97%EF%BC%882%EF%BC%89/"/>
    <id>http://yoursite.com/2019/08/07/python常用模块（2）/</id>
    <published>2019-08-07T06:27:10.000Z</published>
    <updated>2019-08-07T07:00:53.343Z</updated>
    
    <content type="html"><![CDATA[<h2 id="collection："><a href="#collection：" class="headerlink" title="collection："></a>collection：</h2><p>collections是Python内建的一个集合模块，提供了许多有用的集合类。</p><p><strong>namedtuple</strong>是一个函数，它用来创建一个自定义的tuple对象，并且规定了tuple元素的个数，并可以用属性而不是索引来引用tuple的某个元素。这样一来，我们用namedtuple可以很方便地定义一种数据类型，它具备tuple的不变性，又可以根据属性来引用，使用十分方便。</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/collections1.png" alt></p><p>利用namedtuple定义和使用具名元祖：第一个参数为类名，第二个参数为类的各个字段的名字</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/collections2.png" alt></p><p>具名元祖有些专用的属性：类属性_fields,类方法_make(),实例方法_asdict()</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/collections3.png" alt></p><p>如果需要修改任何属性，可以通过使用nametupled实例的_replace方法来实现。该方法会创建按一个新的命名元祖，并对相应的值进行替换。</p><p><strong>deque</strong>：是为了高效实现插入和删除操作的双向列表，适合用于队列和栈。deque(maxlen=N)创建一个固定长度的队列，当有新记录加入而队列已满时会自动移除最老的那条记录。</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/collections5.png" alt></p><p><strong>defaultdict</strong>:使用dict时，如果引用的Key不存在，就会抛出KeyError。如果希望key不存在时，返回一个默认值，就可以用defaultdict。defaultdict的一个特点就是会自动初始化第一个值。</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/collections6.png" alt></p><p>用defaultdict的效率比不用高:</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/collections7.png" alt></p><p><strong>OrderedDict</strong></p><p>使用dict时，Key是无序的。在对dict做迭代时，我们无法确定Key的顺序。</p><p>如果要保持Key的顺序，可以用OrderedDict。</p><p>OrderDict的大小是普通字典的2倍多，这是由于它额外创建的链表所导致。</p><p>注意，OrderedDict的Key会按照插入的顺序排列，不是Key本身排序：OrderedDict可以实现一个FIFO（先进先出）的dict，当容量超出限制时，先删除最早添加的Key</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/collections8.png" alt></p><p><strong>Counter</strong>：一个简单的计数器</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/collections10.png" alt></p><p>计数器的更新包括增加和减少两种，增加使用update，减少用subtract。</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/collections11.png" alt></p><p>most_common(x):根据x返回频率前x的项。</p><p><strong>itemgetter</strong>：可以通过公共键对字典列表排序。</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/collections12.png" alt></p><p><strong>ChainMap</strong>：可接受多个映射然后再逻辑上是它们表现为一个单独的映射结构。如果有重复的键，那么会采用第一个映射中所对应的值。修改映射的操作总是会作用在列出的第一个映射结构上。</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/collections13.png" alt></p><h2 id="random"><a href="#random" class="headerlink" title="random"></a>random</h2><p>random.random() 产生0-1的随机浮点数</p><p>random.uniform(a, b) 产生指定范围内的随机浮点数</p><p>random.randint(a, b) 产生指定范围内的随机整数</p><p>random.randrange([start], stop[, step]) 从一个指定步长的集合中产生随机数</p><p>random.choice(sequence) 从序列中产生一个随机数</p><p>random.shuffle(x[, random]) 将一个列表中的元素打乱</p><p>random.sample(sequence, k) 从序列中随机获取指定长度的片断</p><h2 id="functools"><a href="#functools" class="headerlink" title="functools"></a>functools</h2><p><strong>reduce(function, sequence, value)</strong>：对sequence中的item顺序迭代调用function，如果有value，还可以作为初始值调用。function接收的参数个数只能为2，先把sequence中第一个值和第二个值当参数传给function，再把function的返回值和第三个值当参数传给function，然后只返回一个结果。</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/functools1.png" alt></p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/functoolss.png" alt></p><p><strong>partial</strong>：基于一个函数创建一个新的可调用对象，把原函数的某些参数固定。</p><p>偏函数：只需要传一次值，后面想传就传</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/functools2.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;collection：&quot;&gt;&lt;a href=&quot;#collection：&quot; class=&quot;headerlink&quot; title=&quot;collection：&quot;&gt;&lt;/a&gt;collection：&lt;/h2&gt;&lt;p&gt;collections是Python内建的一个集合模块，提供了许多有
      
    
    </summary>
    
      <category term="python" scheme="http://yoursite.com/categories/python/"/>
    
      <category term="常用模块" scheme="http://yoursite.com/categories/python/%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/"/>
    
      <category term="常用模块（2）" scheme="http://yoursite.com/categories/python/%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97%EF%BC%882%EF%BC%89/"/>
    
    
      <category term="python常用模块" scheme="http://yoursite.com/tags/python%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/"/>
    
  </entry>
  
  <entry>
    <title>python常用模块（1）</title>
    <link href="http://yoursite.com/2019/08/07/python%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97%EF%BC%881%EF%BC%89/"/>
    <id>http://yoursite.com/2019/08/07/python常用模块（1）/</id>
    <published>2019-08-07T05:51:37.000Z</published>
    <updated>2019-08-07T06:26:32.829Z</updated>
    
    <content type="html"><![CDATA[<p>​    这几年，python大火。其中的一个原因是python的库特别多，而且封装非常好。接下来我来总结以下我用过的一些库，虽然都不是很大的库，但还是有用的。</p><h2 id="json"><a href="#json" class="headerlink" title="json"></a>json</h2><p>json主要执行序列化和反序列化的功能，通过Python的json模块，可以将字符串形式的json数据转化为字典，也可以将Python中的字典数据转化为字符串形式的json数据。</p><p>通过json字符串转为字典 json.loads</p><p>字典转换为json：json.dumps</p><p>json.loads()、dumps解码python json格式 </p><p>json.load、dump加载json格式文件</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/json.png" alt></p><p>pickle使用方法与json一样</p><p>区别：</p><p>json是可以在不同语言之间交换数据的，而pickle只在python之间使用。</p><p>json只能序列化最基本的数据类型，而pickle可以序列化所有的数据类型，包括类，函数都可以序列化。</p><h2 id="hashlib"><a href="#hashlib" class="headerlink" title="hashlib"></a>hashlib</h2><p>该模块提供了常见的摘要算法。如MD5，SHA1……摘要算法又称哈希算法、散列算法，通过一个函数，把任意长度的数据转换为一个长度固定的数据串。</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/20190807140248.png" alt></p><p>摘要算法是一个单向函数，通过摘要函数f()对任意长度的数据data计算出固定长度的摘要digest，目的是发现原始数据是否被改动过。计算f(data)很容易，但通过digest反推data却非常困难，对原始数据做一个字节的修改，都会导致计算出来的摘要不同。</p><h2 id="string"><a href="#string" class="headerlink" title="string"></a>string</h2><p>string.digits:包含数字0-9的字符串</p><p>string.letters:包含所有字母（大写或小写）的字符串</p><p>string.lowercase:包含所有小写字母的字符串</p><p>string.printable:包含所有可打印字符的字符串</p><p>string.punctuation:包含所有标点的字符串</p><p>string.uppercase:包含所有大写字母的字符串</p><p>string.ascii_letters和string.digits方法，其中ascii_letters是生成所有字母，从a-z和A-Z,digits是生成所有数字0-9.</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/string%E6%A8%A1%E5%9D%97.png" alt></p><h2 id="词云"><a href="#词云" class="headerlink" title="词云"></a>词云</h2><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/wordcloud.png" alt></p><h2 id="decimal"><a href="#decimal" class="headerlink" title="decimal"></a>decimal</h2><p>如果期望获得更高的精度（并且愿意牺牲掉一些性能），可以使用decimal模块。</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/decimal.png" alt></p><h2 id="fractions"><a href="#fractions" class="headerlink" title="fractions"></a>fractions</h2><p>模块可以用来处理涉及分数的数学计算问题</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/fractions.png" alt></p><h2 id="copy"><a href="#copy" class="headerlink" title="copy"></a>copy</h2><p>完成深拷贝和浅拷贝</p><p>is和==的区别：==是看值，is看是否指向同一个</p><p>浅拷贝：拷贝内容的地址</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/copy1.png" alt></p><p>深拷贝：开发另一片空间存放要拷贝的内容</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/copy3.png" alt></p><p>copy会判断数据类型是否为可变类型，如元祖为不可变类型，则只会完成浅拷贝。</p><h2 id="fileinput"><a href="#fileinput" class="headerlink" title="fileinput"></a>fileinput</h2><p>可以快速对一个或多个文件进行循环遍历</p><p>fileinput.input([files[, inplace[, backup[, mode[, openhook]]]]]])功能:生成FileInput模块类的实例。能够返回用于for循环遍历的对象。注意:文件名可以提供多个</p><p>inplace：是否返回输出结果到源文件中，默认为零不返回。设置为1时返回。</p><p>backup：备份文件的扩展名</p><p>mode：读写模式。只能时读、写、读写、二进制四种模式。默认是读</p><p>openhook：必须是一个函数，有两个参数，文件名和模式。返回相应的打开文件对象</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/fileinput.png" alt></p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/fileinput2.png" alt></p><p>fileinput.filename()：返回当前正在读取的文件的名称。在读取第一行之前，返回None。</p><p>fileinput.fileno()：返回当前文件的整数“文件描述符”。如果没有打开文件（在第一行之前和文件之间），则返回-1。</p><p>fileinput.lineno()：返回刚读过的行的累计行号。在读取第一行之前，返回0。读取完最后一个文件的最后一行后，返回该行的行号。</p><p>fileinput.filelineno()：返回当前文件中的行号。在读取第一行之前，返回0。读取完最后一个文件的最后一行后，返回该文件中该行的行号。</p><p>fileinput.isfirstline()：如果刚刚读取的行是其文件的第一行，则返回true，否则返回false。</p><p>fileinput.isstdin()：如果读取了最后一行sys.stdin，则返回true，否则返回false。</p><p>fileinput.nextfile()：关闭当前文件，以便下一次迭代将读取下一个文件的第一行（如果有的话）; 未从文件中读取的行将不计入累计行数。直到读取下一个文件的第一行之后才会更改文件名。在读取第一行之前，此功能无效; 它不能用于跳过第一个文件。读取完最后一个文件的最后一行后，此功能无效。</p><p>fileinput.close()关闭序列</p><h2 id="subprocess："><a href="#subprocess：" class="headerlink" title="subprocess："></a>subprocess：</h2><p>subprocess模块可以让我们非常方便地启动一个子进程，然后控制其输入和输出。Popen()建立子进程的时候改变标准输入、标准输出和标准错误，并可以利用subprocess.PIPE将多个子进程的输入和输出连接在一起，构成管道(pipe)</p><p>subprocess.call():父进程等待子进程完成，返回退出信息(returncode，相当于Linux exit code)</p><p>subprocess.check_call():父进程等待子进程完成，返回0，检查退出信息，如果returncode不为0，则举出错误subprocess.CalledProcessError，该对象包含有returncode属性，可用try…except…来检查</p><p>subprocess.check_output():父进程等待子进程完成，返回子进程向标准输出的输出结果，检查退出信息，如果returncode不为0，则举出错误subprocess.CalledProcessError，该对象包含有returncode属性和output属性，output属性为标准输出的输出结果，可用try…except…来检查。</p><p>subprocess.Popen()，以下为参数：</p><p>args：shell命令，可以是字符串，或者序列类型，如list,tuple。</p><p>bufsize：缓冲区大小，可不用关心</p><p>stdin,stdout,stderr：分别表示程序的标准输入，标准输出及标准错误</p><p>shell：与上面方法中用法相同</p><p>cwd：用于设置子进程的当前目录</p><p>env：用于指定子进程的环境变量。如果env=None，则默认从父进程继承环境变量</p><p>universal_newlines：不同系统的的换行符不同，当该参数设定为true时，则表示使用\n作为换行符</p><p>常用方法：</p><p>poll() ： 检查子进程状态</p><p>kill() ： 终止子进程</p><p>send_signal() :向子进程发送信号</p><p>terminate() ： 终止子进程</p><p>communicate:从PIPE中读取PIPE的文本，该方法会阻塞父进程，直到子进程完成</p><p>常用属性：pid：子进程的pid，returncode：子进程的退出码。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;​    这几年，python大火。其中的一个原因是python的库特别多，而且封装非常好。接下来我来总结以下我用过的一些库，虽然都不是很大的库，但还是有用的。&lt;/p&gt;
&lt;h2 id=&quot;json&quot;&gt;&lt;a href=&quot;#json&quot; class=&quot;headerlink&quot; tit
      
    
    </summary>
    
      <category term="python" scheme="http://yoursite.com/categories/python/"/>
    
      <category term="常用模块" scheme="http://yoursite.com/categories/python/%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/"/>
    
      <category term="常用模块（1）" scheme="http://yoursite.com/categories/python/%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97%EF%BC%881%EF%BC%89/"/>
    
    
      <category term="python常用模块" scheme="http://yoursite.com/tags/python%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/"/>
    
  </entry>
  
  <entry>
    <title>元类</title>
    <link href="http://yoursite.com/2019/08/07/%E5%85%83%E7%B1%BB/"/>
    <id>http://yoursite.com/2019/08/07/元类/</id>
    <published>2019-08-07T05:39:47.000Z</published>
    <updated>2019-08-07T05:47:41.542Z</updated>
    
    <content type="html"><![CDATA[<p>​    今天来讲一下python里面较难的一个东西，我暂时还不知道这个东西具体用到哪。所以后面会陆陆续续的补。我学到的python内容里面有两个东西是比较难的，一个是描述符，另一个就是今天讲的元类。</p><p><strong>python通过类创建对象，通过元类创建类。（类也是对象）</strong></p><p>通过type动态创建类。命名规则：</p><p>type(类名，由父类名称构成的元祖（针对继承的情况，可以为空），包含属性的字典（名称和值）)</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/%E5%85%83%E7%B1%BB1.png" alt></p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/%E5%85%83%E7%B1%BB2.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;​    今天来讲一下python里面较难的一个东西，我暂时还不知道这个东西具体用到哪。所以后面会陆陆续续的补。我学到的python内容里面有两个东西是比较难的，一个是描述符，另一个就是今天讲的元类。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;python通过类创建对象，通过元类创建类
      
    
    </summary>
    
      <category term="python" scheme="http://yoursite.com/categories/python/"/>
    
      <category term="元类" scheme="http://yoursite.com/categories/python/%E5%85%83%E7%B1%BB/"/>
    
    
      <category term="python的元类" scheme="http://yoursite.com/tags/python%E7%9A%84%E5%85%83%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>pandas用法总结</title>
    <link href="http://yoursite.com/2019/08/07/pandas/"/>
    <id>http://yoursite.com/2019/08/07/pandas/</id>
    <published>2019-08-07T01:55:50.000Z</published>
    <updated>2019-08-07T03:22:43.479Z</updated>
    
    <content type="html"><![CDATA[<p>​    pandas也是一个非常强大的库，所以我也只是总结了我用到的方法。</p><p>pandas常用的数据类型：1、Series  一维 带标签的数组（标签就是索引）2、DataFrame  二维   Series的容器</p><h2 id="Series："><a href="#Series：" class="headerlink" title="Series："></a>Series：</h2><p>通过列表创建Series：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/pandas1.png" alt></p><p>索引可以指定，默认从0开始：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/pandas2.png" alt></p><p>通过字典创建Series：可以通过astype修改类型</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/pandas3.png" alt></p><p>取值：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/pandas4.png" alt></p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/pandas5.png" alt></p><p>可以将条件和value、index配合使用：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/panda6.png" alt></p><p>pandas读取外部数据：</p><p>read_csv:读取CSV文件</p><p>read_excel:读取excel文件</p><p>其他文件类似</p><h2 id="DataFrame"><a href="#DataFrame" class="headerlink" title="DataFrame"></a>DataFrame</h2><p>通过列表创建：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/pandas7.png" alt></p><p>通过数组创建：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/pandas8.png" alt></p><p>通过字典创建：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/pandas9.png" alt></p><p><strong>DataFrame的基础属性</strong>：</p><p>shape ：行数 列数</p><p>dtypes：列数据类型</p><p>ndim：数据维度</p><p>index：行索引</p><p>columns：列索引</p><p>values：对象值</p><p><strong>DataFrame的方法</strong>：</p><p>head(n):显示头n行。默认是前5行</p><p>tail(n)：显示尾n行。</p><p>info()：行数，列数，列索引，列非空值个数，列类型，内存占用</p><p>describe()：计数 均值 标准差 最大值 四分位数 最小值</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/pandas10.png" alt></p><p>DataFrame排序：sort_values()。通过设置by来确定排序的key。设置ascending确定升序or降序。</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/pandas11.png" alt></p><p>DataFrame的取值：</p><p>方括号写数字，表示取行。对行进行操作。根据实际情况写</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/pandas13.png" alt></p><p>对列进行操作：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/pandas14.png" alt></p><p>配合使用：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/pandas16.png" alt></p><p>loc：DataFrame通过标签索引获取行数据</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/pandas17.png" alt></p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/pandas18.png" alt></p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/pandas19.png" alt></p><p>根据多个索引取多个对应的值：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/pandas20.png" alt></p><p>iloc：DataFrame通过位置获取列数据。与ioc类似，只是将索引换成数字。</p><p>数组合并：</p><p>1、join 按行索引合并             </p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/pandas21.png" alt></p><p>2、merge按列索引进行合并 on指定按哪一列合并  how：合并方式 inner(交集，默认) outer(并集)  left(左边为准，NaN补全)  right(右边为准，NaN补全)</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/pandas23.png" alt></p><p>如果列索引不同。可以left_on和right_on指定左边、右边DataFrame的合并列。</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/pandas24.png" alt></p><p>另一种写法：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/pandas25.png" alt></p><p>分组:groupby(by)               by:通过什么分组，可以设置多个条件分组</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/pandas26.png" alt></p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/pandas27.png" alt></p><p>聚合：count   计算数量</p><p>sum             求和</p><p>mean        求平均值</p><p>median        求中位数</p><p>std、var      求标准差和方差</p><p>min、max       求最大和最小值</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/pandas28.png" alt></p><h4 id="DataFrame的索引和复合索引："><a href="#DataFrame的索引和复合索引：" class="headerlink" title="DataFrame的索引和复合索引："></a>DataFrame的索引和复合索引：</h4><p>简单的索引操作：</p><p>获取index：df.index</p><p>指定index：df.index=[“”,””]</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/pandas29.png" alt></p><p>同理可得指定columns：df.columns=[“ “,” “]</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/pandas30.png" alt></p><p>重新设置index：df.reindex()</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/pandas31.png" alt></p><p>指定某一列成为index：df.set_index()。drop决定是否保留设定的列</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/pandas32.png" alt></p><p>可以设定多个列成为index：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/pandas33.png" alt></p><p>返回index的唯一值：df.set_index().index.unique()</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/pandas34.png" alt></p><p>时间序列：date_range(start,end,period,freq) 生成一段时间范围。start和end表示范围，periods表示个数，freq表示频率(年、月、天)</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/pandas35.png" alt></p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/pandas37.png" alt></p><p>频率类型：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/pandas36.png" alt></p><p>时间段：PeriodIndex</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/pandas38.png" alt></p><p> 重采样resample：指的是将时间序列从一个频率转化为另一个频率进行处理的过程。将高频率数据转化为低频率数据为降采样。低频率数据转化为高频率为升采样。</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/pandas39.png" alt></p><h2 id="判断数据是否为NaN："><a href="#判断数据是否为NaN：" class="headerlink" title="判断数据是否为NaN："></a>判断数据是否为NaN：</h2><p>pd.isnull()  pd.notfull()</p><p>在DataFrame中对缺失数据（NaN）的处理：</p><p>方式1：删除NaN所在的行列dropna(axis,how,inplace):how=”any”时一行(列)里有一个为nan就删。how=”all”时，一行全部为nan时才删。inplace为True，原地修改。False为False，不修改。</p><p>方式2：填充数据，fillna()</p><p>处理为0的数据：t[t==0]=np.nan</p><p>计算平均值时：nan不参与计算，0参与</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;​    pandas也是一个非常强大的库，所以我也只是总结了我用到的方法。&lt;/p&gt;
&lt;p&gt;pandas常用的数据类型：1、Series  一维 带标签的数组（标签就是索引）2、DataFrame  二维   Series的容器&lt;/p&gt;
&lt;h2 id=&quot;Series：&quot;&gt;&lt;
      
    
    </summary>
    
      <category term="python" scheme="http://yoursite.com/categories/python/"/>
    
      <category term="pandas" scheme="http://yoursite.com/categories/python/pandas/"/>
    
    
      <category term="pandas" scheme="http://yoursite.com/tags/pandas/"/>
    
  </entry>
  
  <entry>
    <title>python知识散记（3）</title>
    <link href="http://yoursite.com/2019/08/07/python%E7%9F%A5%E8%AF%86%E6%95%A3%E8%AE%B0%EF%BC%883%EF%BC%89/"/>
    <id>http://yoursite.com/2019/08/07/python知识散记（3）/</id>
    <published>2019-08-07T00:20:58.000Z</published>
    <updated>2019-08-07T05:49:14.457Z</updated>
    
    <content type="html"><![CDATA[<p>​    今天的知识散记讲三个器，哪三个器呢？装饰器、迭代器、生成器。还有列表生成式、字典生成式。</p><h2 id="装饰器："><a href="#装饰器：" class="headerlink" title="装饰器："></a>装饰器：</h2><p>python装饰器就是用于拓展原来函数功能的一种函数，这个函数的特殊之处在于它的返回值也是一个函数，使用python装饰器的好处就是在不用更改原函数的代码前提下给函数增加新的功能。 </p><p>使用闭包完成的装饰器原理：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/python33.png" alt></p><p>当执行test(test)时，func已经指向test()函数。所以func()相当于test()。这就是装饰器的原理。但是实际不是这样写的，请看下图：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/python32.png" alt></p><p>使用装饰器对有参数的函数装饰：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/python34.png" alt></p><p>对不定长参数的装饰：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/python35.png" alt></p><p>装饰器对有返回值的函数装饰：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/python36.png" alt></p><p>带参数的装饰器</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/python37.png" alt></p><p>用类做装饰器：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/python38.png" alt></p><p>装饰器完了，自己慢慢悟吧。</p><h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><p>迭代器只能前进不能后退。使用迭代器不要求事先准备好整个迭代过程中的所有元素。迭代器仅仅在迭代到某个元素时才计算该元素，而在这之前或之后元素可以不存在或者被销毁。因此迭代器适合遍历一些数量巨大甚至无限的序列。</p><p>Python中迭代器的本质上每次调用__next__()方法都返回下一个元素或抛出StopIteration的容器对象</p><p>由于Python中没有“迭代器”这个类，因此具有以下两个特性的类都可以称为“迭代器”类：</p><p>1、有__next__()方法，返回容器的下一个元素或抛出StopIteration异常</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/python39.png" alt></p><p>2、有__iter__()方法，返回迭代器本身</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/python40.png" alt></p><p>all(iterable)：如果迭代器里面的所有元素都为True时,返回True;否则返回False</p><p>any(iterable）：如果迭代器里面的所有元素为False,返回False;否则返回True.</p><h2 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h2><p>一个个的生成数据，但占用内存更少，生成器是特殊的迭代器。</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/python41.png" alt></p><p>当yield存在函数时，函数就变成一个生成器。yield不像return那样返回值，而是每次产生多个值。每次使用yield产生一个值，函数就会被冻结。</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/python42.png" alt></p><p>用aim.__next__()得出结果：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/python43.png" alt></p><p>aim.send()得出结果：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/python45.png" alt></p><h2 id="列表生成式和字典推导式："><a href="#列表生成式和字典推导式：" class="headerlink" title="列表生成式和字典推导式："></a>列表生成式和字典推导式：</h2><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/python46.png" alt></p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/python47.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;​    今天的知识散记讲三个器，哪三个器呢？装饰器、迭代器、生成器。还有列表生成式、字典生成式。&lt;/p&gt;
&lt;h2 id=&quot;装饰器：&quot;&gt;&lt;a href=&quot;#装饰器：&quot; class=&quot;headerlink&quot; title=&quot;装饰器：&quot;&gt;&lt;/a&gt;装饰器：&lt;/h2&gt;&lt;p&gt;pytho
      
    
    </summary>
    
      <category term="python" scheme="http://yoursite.com/categories/python/"/>
    
      <category term="知识散记" scheme="http://yoursite.com/categories/python/%E7%9F%A5%E8%AF%86%E6%95%A3%E8%AE%B0/"/>
    
      <category term="知识散记（3）" scheme="http://yoursite.com/categories/python/%E7%9F%A5%E8%AF%86%E6%95%A3%E8%AE%B0/%E7%9F%A5%E8%AF%86%E6%95%A3%E8%AE%B0%EF%BC%883%EF%BC%89/"/>
    
    
      <category term="python知识散记" scheme="http://yoursite.com/tags/python%E7%9F%A5%E8%AF%86%E6%95%A3%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>python知识散记（2）</title>
    <link href="http://yoursite.com/2019/08/06/python%E7%9F%A5%E8%AF%86%E6%95%A3%E8%AE%B0%EF%BC%882%EF%BC%89/"/>
    <id>http://yoursite.com/2019/08/06/python知识散记（2）/</id>
    <published>2019-08-06T07:32:02.000Z</published>
    <updated>2019-08-07T05:48:57.041Z</updated>
    
    <content type="html"><![CDATA[<p>​    接着上次的知识散记，我们接着看。</p><h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>在函数内部定义一个函数，并且这个函数用到了外面的变量。将这个函数以及用到的一些变量称之为闭包。</p><p>当某个函数被当成对象返回时，夹带了外部 变量，就形成了一个闭包。</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/python13.png" alt></p><h2 id="global："><a href="#global：" class="headerlink" title="global："></a>global：</h2><p>一般多用在函数内，声明变量的作用域为全局作用域。箭头变化的时候加，箭头不变的时候可以不加。（箭头类似指针）</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/python14.png" alt></p><h2 id="nonlocal："><a href="#nonlocal：" class="headerlink" title="nonlocal："></a>nonlocal：</h2><p>nonlocal关键字用来在函数或其他作用域中使用外层(非全局)变量</p><h2 id="lambda匿名函数："><a href="#lambda匿名函数：" class="headerlink" title="lambda匿名函数："></a>lambda匿名函数：</h2><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/python15.png" alt></p><p>不要看匿名函数蛮简单的，其实还是有点注意事项的。<strong>对默认参数的赋值只会在函数定义的时候绑定一次。x是一个自由变量。在运行的时候绑定，而不是在定义的时候绑定。执行时，x的值是多少就是多少。如果希望匿名函数可以在定义的时候绑定，并保持值不变，则采用下面方法。</strong></p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/python23.png" alt></p><h2 id="assert-断言"><a href="#assert-断言" class="headerlink" title="assert:断言"></a>assert:断言</h2><p>用来直接让程序崩溃，在程序中置入检查点</p><p>条件后可以添加字符串，用来解释断言</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/python16.png" alt></p><h2 id="format"><a href="#format" class="headerlink" title="format:"></a>format:</h2><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/python30.png" alt></p><h2 id="对-和-的解释："><a href="#对-和-的解释：" class="headerlink" title="对*和**的解释："></a>对*和**的解释：</h2><p>星号(*)和(**)作为形参的时候是起到“打包”的作用，相反，作为实参的时候是起到“解包”的作用。</p><h6 id="星号-或-作为形参，表示调用可变参数函数："><a href="#星号-或-作为形参，表示调用可变参数函数：" class="headerlink" title="星号(*)或(**)作为形参，表示调用可变参数函数："></a>星号(*)或(**)作为形参，表示调用可变参数函数：</h6><p>通过在形参前加一个星号(*)或两个星号(**)来指定函数可以接收任意数量的实参。</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/python18.png" alt></p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/python29.png" alt></p><p>从两个示例的输出可以看出：当参数形如 *args 时，传递给函数的任意个实参会按位置打包成一个元</p><p>组（tuple）；当参数形如 **args 时，传递给函数的任意个 key = value 实参会被包装进一个字典（dict）。</p><h6 id="星号-和-作为实参时，表示通过解包参数调用函数："><a href="#星号-和-作为实参时，表示通过解包参数调用函数：" class="headerlink" title="星号(**)和(*)作为实参时，表示通过解包参数调用函数："></a>星号(**)和(*)作为实参时，表示通过解包参数调用函数：</h6><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/python20.png" alt></p><h2 id="常用内置函数补充："><a href="#常用内置函数补充：" class="headerlink" title="常用内置函数补充："></a>常用内置函数补充：</h2><p>复数可以通过<strong>complex（real，imag）</strong>来指定。conjugete提取共轭复数</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/python21.png" alt></p><p><strong>hasattr</strong>：hasattr() 函数用于判断对象是否包含对应的属性。如果对象有该属性返回 True，否则返回 False。</p><h2 id="上下文管理器（context-manager）："><a href="#上下文管理器（context-manager）：" class="headerlink" title="上下文管理器（context manager）："></a>上下文管理器（context manager）：</h2><p>任何实现了__enter__和__exit__方法的对象都可称为上下文管理器</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/python24.png" alt></p><p>__enter__():方法返回资源对象，这里就是你将要打开的那个文件对象，__exit__()处理一些清除工作。因为File类实现上下文管理器，现在就可以使用with语句了。</p><p>实现上下文管理器的其他方法：使用contextmanager装饰器</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/python25.png" alt></p><h2 id="python的三种修饰符："><a href="#python的三种修饰符：" class="headerlink" title="python的三种修饰符："></a>python的三种修饰符：</h2><p>staticmethod、classmethod 和 property，作用分别是把类中定义的实例方法变成静态方法、类方法和类属性。staticmethod、classmethod具体看python的类和对象。</p><p>注意：</p><ol><li><p>函数先定义，再修饰它；反之会编译器不认识；</p></li><li><p>修饰符“@”后面必须是之前定义的某一个函数；</p></li><li><p>每个函数只能有一个修饰符，大于等于两个则不可以。</p></li></ol><p>property用法:它的作用把方法当作属性来访问（注意getnum和setter的顺序，一定getnum在第一个）</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/python27.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;​    接着上次的知识散记，我们接着看。&lt;/p&gt;
&lt;h2 id=&quot;闭包&quot;&gt;&lt;a href=&quot;#闭包&quot; class=&quot;headerlink&quot; title=&quot;闭包&quot;&gt;&lt;/a&gt;闭包&lt;/h2&gt;&lt;p&gt;在函数内部定义一个函数，并且这个函数用到了外面的变量。将这个函数以及用到的一些变量
      
    
    </summary>
    
      <category term="python" scheme="http://yoursite.com/categories/python/"/>
    
      <category term="知识散记" scheme="http://yoursite.com/categories/python/%E7%9F%A5%E8%AF%86%E6%95%A3%E8%AE%B0/"/>
    
      <category term="知识散记（2）" scheme="http://yoursite.com/categories/python/%E7%9F%A5%E8%AF%86%E6%95%A3%E8%AE%B0/%E7%9F%A5%E8%AF%86%E6%95%A3%E8%AE%B0%EF%BC%882%EF%BC%89/"/>
    
    
      <category term="python知识散记" scheme="http://yoursite.com/tags/python%E7%9F%A5%E8%AF%86%E6%95%A3%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>python知识散记（1）</title>
    <link href="http://yoursite.com/2019/08/06/python%E7%9F%A5%E8%AF%86%E6%95%A3%E8%AE%B0%EF%BC%881%EF%BC%89/"/>
    <id>http://yoursite.com/2019/08/06/python知识散记（1）/</id>
    <published>2019-08-06T06:43:04.000Z</published>
    <updated>2019-08-07T05:48:35.382Z</updated>
    
    <content type="html"><![CDATA[<p>​    今天来讲一下python的一些散装知识，还是蛮多的。所以分了几个部分。今天的部分是最简单的，废话少说。开始吧</p><h2 id="导入模块方法："><a href="#导入模块方法：" class="headerlink" title="导入模块方法："></a>导入模块方法：</h2><p>1、最常见的方式，直接将要导入的模块名称写在后面导入。import xxxx</p><p>2、from .. import .. </p><p>与import类似，只是更明确的要导入的方法或变量。</p><p>3、from modname import *，导入所有的类和公有方法。</p><h2 id="if-name-”-main-“"><a href="#if-name-”-main-“" class="headerlink" title="if __name__==”__main__“:"></a>if __name__==”__main__“:</h2><p>让你写的脚本模块既可以导入到别的模块中用，另外该模块自己也可执行。</p><h2 id="常用的一些内置函数"><a href="#常用的一些内置函数" class="headerlink" title="常用的一些内置函数"></a>常用的一些内置函数</h2><p><strong>callable(object)</strong>：检查对象object是否可调用。如果返回True，object仍然可能调用失败；但如果返回False，调用对象ojbect绝对不会成功。</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/python1.png" alt></p><p><strong>divmod(a,b)</strong>：以元祖的方式放回a//b以及a%b。</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/python2.png" alt></p><p><strong>ord(str)</strong>：把对应的字符转成整数.</p><p><strong>chr(integer)</strong>：把整数转化成对应的字母.</p><p><strong>bool(x)</strong>：把一个值转化为布尔值,如果该值为假或者省略返回False,否则返回True</p><p><strong>abs(x)</strong> ：返回一个数的绝对值.该参数可以是整数或浮点数.如果参数是一个复数,则返回其大小</p><p><strong>round(number[, ndigits])</strong>：返回浮点数number保留ndigits位小数后四舍五入的值。</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/python3.png" alt></p><p><strong>dir([object])</strong>: 没有参数,返回当前局部范围的名单列表。有参数，试图返回该对象的有效的属性列表</p><p><strong>issubclass(class, classinfo)</strong>:返回True如果参数class是classinfo的一个子类，否则返回False。</p><p><strong>isinstance(object, classinfo)</strong>:返回True如果参数object是classinfo的一个实例，否则返回False(适用于继承)。</p><p><strong>zip(*iterables)</strong>:生成一个迭代器，迭代器聚合了从每个可迭代数集里的元素。它的内容只能被消费一次</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/python4.png" alt></p><p><strong>map</strong>：第一个参数 function 以参数序列中的每一个元素调用 function函数，返回包含每次 function 函数返回值的新列表。</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/python6.png" alt></p><p><strong>filter</strong>：filter() 函数用于过滤序列，过滤掉不符合条件的元素，返回由符合条件元素组成的新列表。应该接收两个参数，第一个为函数，第二个为序列，序列的每个元素作为参数传递给函数进行判，然后返回 True 或 False，最后将返回 True 的元素放到新列表中。</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/python7.png" alt></p><p><strong>enumerate</strong>是一个非常有用的函数，直接看效果。</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/python26.png" alt></p><p><strong>eval(str [,globals [,locals ]])</strong>：用来计算存储在字符串中的有效python表达式。</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/python8.png" alt></p><p><strong>exec(object[, globals[, locals]])</strong>， 用来执行存储在字符串或文件中的python语句</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/python9.png" alt></p><h2 id="格式化输出格式："><a href="#格式化输出格式：" class="headerlink" title="格式化输出格式："></a>格式化输出格式：</h2><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/python10.png" alt></p><h2 id="python语句中一些基本规则和特殊字符："><a href="#python语句中一些基本规则和特殊字符：" class="headerlink" title="python语句中一些基本规则和特殊字符："></a>python语句中一些基本规则和特殊字符：</h2><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/python11.png" alt></p><h2 id="python调试："><a href="#python调试：" class="headerlink" title="python调试："></a>python调试：</h2><p>python调试两种方法都有用到pdb模块</p><p>第一种：在代码的目录下，打开cmd，输入python -m 文件名</p><p>h：帮助命令</p><p>第二种：可以在交互界面进行调试</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/python12.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;​    今天来讲一下python的一些散装知识，还是蛮多的。所以分了几个部分。今天的部分是最简单的，废话少说。开始吧&lt;/p&gt;
&lt;h2 id=&quot;导入模块方法：&quot;&gt;&lt;a href=&quot;#导入模块方法：&quot; class=&quot;headerlink&quot; title=&quot;导入模块方法：&quot;&gt;&lt;/
      
    
    </summary>
    
      <category term="python" scheme="http://yoursite.com/categories/python/"/>
    
      <category term="知识散记" scheme="http://yoursite.com/categories/python/%E7%9F%A5%E8%AF%86%E6%95%A3%E8%AE%B0/"/>
    
      <category term="知识散记（1）" scheme="http://yoursite.com/categories/python/%E7%9F%A5%E8%AF%86%E6%95%A3%E8%AE%B0/%E7%9F%A5%E8%AF%86%E6%95%A3%E8%AE%B0%EF%BC%881%EF%BC%89/"/>
    
    
      <category term="python知识散记" scheme="http://yoursite.com/tags/python%E7%9F%A5%E8%AF%86%E6%95%A3%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>协程</title>
    <link href="http://yoursite.com/2019/08/06/python%E4%B8%AD%E7%9A%84%E5%8D%8F%E7%A8%8B/"/>
    <id>http://yoursite.com/2019/08/06/python中的协程/</id>
    <published>2019-08-06T03:38:42.000Z</published>
    <updated>2019-08-06T03:47:42.984Z</updated>
    
    <content type="html"><![CDATA[<p>​    今天，我们来讲一些协程。协程是python中独有的，在其他语言中是没有这个概念的。协程是利用线程在等待的时候做事情。</p><p>使用yield完成协程：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/%E5%8D%8F%E7%A8%8B1.png" alt></p><p>使用greenlet完成协程：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/%E5%8D%8F%E7%A8%8B2.png" alt></p><p>使用gevent完成协程：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/%E5%8D%8F%E7%A8%8B3.png" alt></p><p>要想用时间模块延迟，则必须打补丁：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/%E5%8D%8F%E7%A8%8B4.png" alt></p><p>我还没看完，后面补。未完待续……</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;​    今天，我们来讲一些协程。协程是python中独有的，在其他语言中是没有这个概念的。协程是利用线程在等待的时候做事情。&lt;/p&gt;
&lt;p&gt;使用yield完成协程：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Br
      
    
    </summary>
    
      <category term="python" scheme="http://yoursite.com/categories/python/"/>
    
      <category term="协程" scheme="http://yoursite.com/categories/python/%E5%8D%8F%E7%A8%8B/"/>
    
    
      <category term="python协程" scheme="http://yoursite.com/tags/python%E5%8D%8F%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>python中的进程</title>
    <link href="http://yoursite.com/2019/08/06/python%E4%B8%AD%E7%9A%84%E8%BF%9B%E7%A8%8B/"/>
    <id>http://yoursite.com/2019/08/06/python中的进程/</id>
    <published>2019-08-06T03:15:37.000Z</published>
    <updated>2019-08-06T03:38:00.114Z</updated>
    
    <content type="html"><![CDATA[<p>多进程：multiprocessing模块</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/%E8%BF%9B%E7%A8%8B1.png" alt></p><p>os.getpid()获取当前进程的id    os.getppid()获取父进程的id</p><p>大量启动子进程，可以用进程池pool批量创建子进程。可以通过processes改变创建的进程数目。</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/%E8%BF%9B%E7%A8%8B3.png" alt></p><p>apply_async(func[, args=()[, kwds={}[, callback=None]]])该函数用于传递不定参数，非阻塞且支持结果返回进行回调。</p><p>将函数添加到进程池：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/%E8%BF%9B%E7%A8%8B2.png" alt></p><p>map(func, iterable[, chunksize=None])：Pool类中的map方法，与内置的map函数用法行为基本一致，它会使进程阻塞直到返回结果。 注意，虽然第二个参数是一个迭代器，但在实际使用中，必须在整个队列都就绪后，程序才会运行子进程。</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/%E8%BF%9B%E7%A8%8B4.png" alt></p><p>close()：关闭进程池（pool），使其不在接受新的任务。</p><p>terminate()：结束工作进程，不在处理未处理的任务。</p><p>join([timeout])：主进程阻塞等待子进程的退出，join方法必须在close或terminate之后使用。timeout表示等待最多时间。若超出，则会直接执行下列代码</p><p>Value、Array是通过共享内存的方式共享数据 </p><p>Value：将一个值存放在内存中，</p><p>Array：将多个数据存放在内存中，但要求数据类型一致</p><p>Value:</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/%E8%BF%9B%E7%A8%8B5.png" alt></p><p>Array:两种情况</p><p>若为数字，表示开辟的共享内存中的空间大小，（Value表示为该空间绑定一个数值）</p><p>若为数组，表示在共享内存中存入数组</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/%E8%BF%9B%E7%A8%8B6.png" alt></p><p>说明：三个0表示开辟的共享内存容量为3，当再超过3时就会报错。</p><p>Manager（Value、Array、dict、list、Lock、Semaphore等）是通过共享进程的方式共享数据。</p><p>进程间通信：Queue ，Pipe</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/%E8%BF%9B%E7%A8%8B13.png" alt></p><p>使用方法和队列差不多</p><p>q.get_nowait()：和get()差不多，不用等。 </p><p>Pipe:Pipe可以是单向(half-duplex)，也可以是双向(duplex)。我们通过mutiprocessing.Pipe(duplex=False)创建单向管道 (默认为双向)。一个进程从PIPE一端输入对象，然后被PIPE另一端的进程接收，单向管道只允许管道一端的进程输入，而双向管道则允许从两端输入。</p><p>这里的Pipe是双向的。</p><p>Pipe对象建立的时候，返回一个含有两个元素的表，每个元素代表Pipe的一端(Connection对象)。我们对Pipe的某一端调用send()方法来传送对象，在另一端使用recv()来接收。</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/%E8%BF%9B%E7%A8%8B7.png" alt></p><p><strong>生产者与消费者模式：在两者中找一个缓冲的东西（队列，缓冲池），解决数据生产方和数据处理方数据不分配的问题。</strong></p><p>耦合：谁和谁的关系越强，耦合性就越强。耦合性越强，程序维护越难。</p><p>解耦的好处：哪块不合适，就改那块。</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/%E8%BF%9B%E7%A8%8B8.png" alt></p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/%E8%BF%9B%E7%A8%8B10.png" alt></p><p>接上面：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/%E8%BF%9B%E7%A8%8B11.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;多进程：multiprocessing模块&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Brickexperts/Figurebed/master/%E8%BF%9B%E7%A8%8B1.png&quot; alt&gt;&lt;/p&gt;

      
    
    </summary>
    
      <category term="python" scheme="http://yoursite.com/categories/python/"/>
    
      <category term="进程" scheme="http://yoursite.com/categories/python/%E8%BF%9B%E7%A8%8B/"/>
    
    
      <category term="python进程" scheme="http://yoursite.com/tags/python%E8%BF%9B%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>python中的线程</title>
    <link href="http://yoursite.com/2019/08/06/python%E4%B8%AD%E7%9A%84%E7%BA%BF%E7%A8%8B/"/>
    <id>http://yoursite.com/2019/08/06/python中的线程/</id>
    <published>2019-08-06T02:34:04.000Z</published>
    <updated>2019-08-06T03:08:28.270Z</updated>
    
    <content type="html"><![CDATA[<p>重要的话写在前面：进程间不共享全局变量，线程间共享全局变量。</p><p>同步：按预定的先后次序进行运行                异步：不确定的次序</p><p>对于操作系统来说，一个任务就是一个进程。进程内的子任务成为线程 ，一个进程至少有一个线程</p><p>多任务执行的方式：</p><p>多进程</p><p>多线程</p><p>多进程+多线程</p><p>多线程：Python的标准库提供了两个模块：_thread和threading，_thread是低级模块，threading是高级模块，对_thread进行了封装。绝大多数情况下，我们只需要使用threading这个高级模块。</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/%E7%BA%BF%E7%A8%8B1.png" alt></p><p>传入参数为元祖。也就是即使只有一个参数，也要写逗号。</p><p>join():将线程加入到当前线程，并等待其终止</p><p>判断线程是否在运行：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/%E7%BA%BF%E7%A8%8B2.png" alt></p><p>守护线程：将daemon属性设为True，则该线程无法被连接</p><p>daemon属性可以保证主线程结束时可以同时结束子线程或者使主线程等待子线程结束后在结束。故称为守护线程。daemon默认为False，如需修改，必须在调用start()方法启动线程之前进行设置。<strong>不适用与idle的交互模式或脚本模式</strong></p><p>当daemon属性为False时，主线程会检测子线程是否结束，如果子线程还在运行，则主线程会等待他完成后在退出。当daemon属性为True时，子线程没执行的不再执行，主线程直接退出。</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/%E7%BA%BF%E7%A8%8B4.png" alt></p><p>通过轮询终止线程：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/%E7%BA%BF%E7%A8%8B5.png" alt></p><p>threading的常用方法：</p><p>​    active_count() 当前活动的 Thread 对象个数</p><p>​    current_thread() 返回当前 Thread 对象</p><p>​    current_thread().name返回当前的Thread对象的名字</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/%E7%BA%BF%E7%A8%8B6.png" alt></p><p>​    get_ident() 返回当前线程</p><p>​    enumerater() 返回当前活动 Thread 对象列表</p><p>​    main_thread() 返回主 Thread 对象</p><p>​    settrace(func) 为所有线程设置一个 trace 函数</p><p>​    setprofile(func) 为所有线程设置一个 profile 函数</p><p>​    stack_size([size]) 返回新创建线程栈大小；或为后续创建的线程设定栈大小为 size</p><p>​    TIMEOUT_MAX Lock.acquire(), RLock.acquire(), Condition.wait() 允许的最大值</p><p>threading 可用对象列表：</p><p>​    Thread 表示执行线程的对象</p><p>​    Lock 锁原语对象</p><p>​    RLock 可重入锁对象，使单一进程再次获得已持有的锁(递归锁)</p><p>Condition： 条件变量对象，使得一个线程等待另一个线程满足特定条件，比如改变状态或某个值</p><p>​    wait(timeout): 线程挂起，直到收到一个notify通知或者超时（可选的，浮点数，单位是秒s）才会被唤醒继续运行。wait()必须在已获得Lock前提下才能调用，否则会触发RuntimeError。</p><p>​    condition = threading.Condition(lock=None)   # 创建Condition对象  参数可以不传</p><p>​    condition.acquire()    # 加锁</p><p>​    condition.release()    # 解锁</p><p>​    condition.wait(timeout=None)                 # 阻塞，直到有调用notify(),或者notify_all()时再触发</p><p>​    condition.wait_for(predicate, timeout=None)  # 阻塞，等待predicate条件为真时执行</p><p>​    condition.notify(n=1)        # 通知n个wait()的线程执行, n默认为1</p><p>​    condition.notify_all()       # 通知所有wait着的线程执行</p><p>​     with condition:              # 支持with语法，不必每次手动调用acquire()/release() </p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/%E7%BA%BF%E7%A8%8B7.png" alt></p><p>Semaphore 为线程间共享的有限资源提供一个”计数器”，如果没有可用资源会被阻塞</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/%E7%BA%BF%E7%A8%8B8.png" alt></p><p>Events：它是由线程设置的信号标志，如果信号标志为真，则其他线程等待直到信号接触。</p><p>Event对象实现了简单的线程通信机制，它提供了设置信号，清除信号，等待等用于实现线程间的通信。</p><p>event = threading.Event() 创建一个event</p><p>1 设置信号</p><p>event.set()</p><p>使用Event的set（）方法可以设置Event对象内部的信号标志为真。Event对象提供了isSet（）方法来判断其内部信号标志的状态。</p><p>当使用event对象的set（）方法后，isSet（）方法返回真</p><p>2 清除信号</p><p>event.clear()</p><p>使用Event对象的clear（）方法可以清除Event对象内部的信号标志，即将其设为假，当使用Event的clear方法后，isSet()方法返回假</p><p>3 等待</p><p>event.wait()</p><p>Event对象wait的方法只有在内部信号为真的时候才会很快的执行并完成返回。当Event对象的内部信号标志为假时，则wait方法一直等待到其为真时才返回。也就是说必须set新号标志为真</p><p>主线程在等事件设置后才继续执行</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/%E7%BA%BF%E7%A8%8B10.png" alt></p><p>event使用示范：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/%E7%BA%BF%E7%A8%8B11.png" alt></p><p>Barrier :创建一个”阻碍”，必须达到指定数量的线程后才可以继续</p><p>每个线程中都调用了wait()方法，在所有（此处设置为3）线程调用wait方法之前是阻塞的。也就是说，只有等到3个线程都执行到了wait方法这句时，所有线程才继续执行。</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/%E7%BA%BF%E7%A8%8B12.png" alt></p><p>计算处于alive的Thread对象数量：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/%E7%BA%BF%E7%A8%8B13.png" alt></p><p>多线程避免全局变量的改变：上锁。上锁后执行的代码越少越好。</p><p>互斥锁：Lock是比较低级的同步原语，当被锁定后不属于特定的线程。一个锁有两个状态:Locked和unLocked.刚创建的的Locked处于unlocked状态。如果锁处于unlocked状态，acquire()方法将其修改为Locked并立即返回。如果锁处于locked状态，则阻塞当前线程并等待其他线程释放锁，然后将其修改为locked并立即返回。release()方法用来将锁的状态从locked修改为unlocked并立即返回。如果锁的状态本来就是unlocked，则会抛出异常</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/%E7%BA%BF%E7%A8%8B14.png" alt></p><p>可重入锁Rlock对象也是一种常用的线程同步原语，可被同一个线程acquire()多次。当locked状态时，某现场拥有该锁，当处于unlocked状态时，该锁不属于任何线程。Rlock对象的acquire()/release()调用对可以嵌套，仅当最后一个或者最外层的release执行结束后，锁才会被设置为unlocked状态</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/%E7%BA%BF%E7%A8%8B15.png" alt></p><p>死锁：双方都在等待对方的条件满足</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/%E7%BA%BF%E7%A8%8B16.png" alt></p><p>避免死锁的方法：1、添加超时事件  2、 尽量避免（银行家算法）</p><p>Threadlocal：保存当前线程的专有状态，这个状态对其他线程不可见。</p><p>全局变量local就是一个ThreadLocal对象，每个Thread对它都可以读写student属性，但互不影响。你可以把local看成全局变量，但每个属性如local.student都是线程的局部变量，可以任意读写而互不干扰，也不用管理锁的问题，ThreadLocal内部会处理。一个ThreadLocal变量虽然是全局变量，但每个线程都只能读写自己线程的独立副本，互不干扰。ThreadLocal解决了参数在一个线程中各个函数之间互相传递的问题。</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/%E7%BA%BF%E7%A8%8B17.png" alt></p><p>线程池：threadpool模块或concerrent.futures模块</p><p>threadpool模块比较老旧，不是主流。</p><p>threadpool.ThreadPool(poolsize)：定义一个线程池，创建了poolsize个线程。</p><p>threadpool.makeRequest(开启多线程的函数，函数相关参数，[回调函数])</p><p>putRequest:将所有要运行多线程的请求扔进线程池。</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/%E7%BA%BF%E7%A8%8B18.png" alt></p><p>concerrent.futures：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/%E7%BA%BF%E7%A8%8B19.png" alt></p><p>ThreadPoolExecutor构造实例的时候，传入max_workers参数来设置线程池中最多能同时运行的线程数目。</p><p>使用submit函数来提交线程需要执行的任务（函数名和参数）到线程池中，并返回该任务的句柄（类似于文件、画图），注意submit()不是阻塞的，而是立即返回。</p><p>通过submit函数返回的任务句柄，能够使用done()方法判断该任务是否结束。上面的例子可以看出，由于任务有2s的延时，在task1提交后立刻判断，task1还未完成，而在延时4s之后判断，task1就完成了。</p><p>使用cancel()方法可以取消提交的任务，如果任务已经在线程池中运行了，就取消不了。这个例子中，线程池的大小设置为2，任务已经在运行了，所以取消失败。如果改变线程池的大小为1，那么先提交的是task1，task2还在排队等候，这是时候就可以成功取消。</p><p>使用result()方法可以获取任务的返回值。查看内部代码，发现这个方法是阻塞的</p><p>as_completed:一次取出所有任务的结果。as_completed()方法是一个生成器，在没有任务完成的时候，会阻塞，在有某个任务完成的时候，会yield这个任务，就能执行for循环下面的语句，然后继续阻塞住，循环到所有的任务结束。从结果也可以看出，先完成的任务会先通知主线程。</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/%E7%BA%BF%E7%A8%8B20.png" alt></p><p>map的作用和submit一样，但略有不同。输出顺序和参数列表的顺序相同</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/%E7%BA%BF%E7%A8%8B21.png" alt></p><p>wait方法接受三个参数，等待的任务序列，超时时间，以及等待条件。等待条件return_when默认为ALL_COMPLTED，表明要等待所有的任务都结束。还可以设为FIRST_COMPLETED，表示第一个任务完成就结束等待。FITST_EXCEPTION(注意要导入)</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/%E7%BA%BF%E7%A8%8B22.png" alt></p><p>通过类创建线程：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/%E7%BA%BF%E7%A8%8B23.png" alt></p><p>t.start后一定调用run函数，不定义run函数该线程不执行。对其他函数的调用只能在run函数里执行。多线程可以共享全局变量，但当数据量大时，数据会出错（产生资源竞争）。</p><p>线程是真的多，看到最后。迷迷糊糊，有错一定要提醒我。而且很多我还没有用过。后面用到的话，会补充上去的。接下来说最后一个：GIL。何为GIL？</p><p>GIL：全局解释器锁</p><p>单CPU的系统中运行多个进程那样，内存中可以存放多个程序，但任意时刻，只有一个程序在CPU中运行。同样地，虽然Python解释器中可以“运行”多个线程，但在任意时刻，只有一个线程在解释器中运行。</p><p>GIL保证了多线程时只有一个线程被调用。 所以多进程效率比多线程高，但是进程间通信比线程难。</p><p>解决方法：用C语言写关键部分。模块（ctypes）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;重要的话写在前面：进程间不共享全局变量，线程间共享全局变量。&lt;/p&gt;
&lt;p&gt;同步：按预定的先后次序进行运行                异步：不确定的次序&lt;/p&gt;
&lt;p&gt;对于操作系统来说，一个任务就是一个进程。进程内的子任务成为线程 ，一个进程至少有一个线程&lt;/p&gt;
&lt;p
      
    
    </summary>
    
      <category term="python" scheme="http://yoursite.com/categories/python/"/>
    
      <category term="线程" scheme="http://yoursite.com/categories/python/%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="python线程" scheme="http://yoursite.com/tags/python%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>numpy</title>
    <link href="http://yoursite.com/2019/08/06/numpy/"/>
    <id>http://yoursite.com/2019/08/06/numpy/</id>
    <published>2019-08-06T01:54:18.000Z</published>
    <updated>2019-08-06T02:31:13.537Z</updated>
    
    <content type="html"><![CDATA[<p>​    最近这几年，机器学习和深度学习大火。而这其中的数据计算是非常多，而这得益于python的numpy模块。多提一句：numpy是没有GIL（多线程解释器锁）的。所以，numpy中的计算是非常快的。那什么是GIL呢？请看python的多线程。话不多说，让我们开启今天的数学之旅。PS：numpy很多API，我还没有学完。我只是总结了一部分，后面会补充的。</p><p>通过array生成矩阵：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/numpy1.png" alt></p><p>可以通过dtype设置矩阵数据的类型。astype可以修改数据类型。</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/numpy3.png" alt></p><p>还有其他生成矩阵的方式：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/numpy5.png" alt></p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/numpy6.png" alt></p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/numpy7.png" alt></p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/numpy8.png" alt></p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/numpy9.png" alt></p><p>numpy生成随机数：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/numpy10.png" alt></p><p>seed的使用方法：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/numpy11.png" alt></p><p>可以通过reshape修改列表的行数和列数，resize改变数组的尺寸大小。根据reshape传入的参数判断转为哪种数组。</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/numpy13.png" alt></p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/numpy14.png" alt></p><p>numpy运算：加、减、乘、除类似。如果两个矩阵形状相同，两个矩阵对应的元素做操作。若两个矩阵形状不相同，其中一个矩阵的维度与另一个矩阵的维度相同，可以在该维度上做操作。</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/numpy15.png" alt></p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/numpy.png" alt></p><p>通过axis求每行（列）的元素和或最大、最小值。0代表列，1代表行。</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/numpy16.png" alt></p><p>还可以获得最大、最小值：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/numpy17.png" alt></p><p>其他一些计算：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/numpy18.png" alt></p><p>对clip函数的解释：小于5的元素都设为5，大于9的元素都设为9</p><p>flatten：对数组展开为一维数组</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/numpy19.png" alt></p><p>numpy的合并：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/numpy20.png" alt></p><p>numpy的分割：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/numpy21.png" alt></p><p>转置矩阵：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/numpy22.png" alt></p><p>未完待续……</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;​    最近这几年，机器学习和深度学习大火。而这其中的数据计算是非常多，而这得益于python的numpy模块。多提一句：numpy是没有GIL（多线程解释器锁）的。所以，numpy中的计算是非常快的。那什么是GIL呢？请看python的多线程。话不多说，让我们开启今天的
      
    
    </summary>
    
      <category term="python" scheme="http://yoursite.com/categories/python/"/>
    
      <category term="数学计算" scheme="http://yoursite.com/categories/python/%E6%95%B0%E5%AD%A6%E8%AE%A1%E7%AE%97/"/>
    
      <category term="numpy" scheme="http://yoursite.com/categories/python/%E6%95%B0%E5%AD%A6%E8%AE%A1%E7%AE%97/numpy/"/>
    
    
      <category term="python的数学计算模块" scheme="http://yoursite.com/tags/python%E7%9A%84%E6%95%B0%E5%AD%A6%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9D%97/"/>
    
  </entry>
  
  <entry>
    <title>网络编程</title>
    <link href="http://yoursite.com/2019/08/06/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    <id>http://yoursite.com/2019/08/06/网络编程/</id>
    <published>2019-08-06T01:00:03.000Z</published>
    <updated>2019-08-06T01:52:11.873Z</updated>
    
    <content type="html"><![CDATA[<p>​    今天，我们来讲一下网络编程。这里面用到一个库：<strong>socket</strong>。网络通信其实就是两个进程之间在编程。先说两个重要的协议：TCP协议 和 UDP协议。TCP协议是传输控制协议，UDP协议是数据传输协议。TCP和UDP的区别：TCP慢但是稳定，因为它经过了三次握手和四次挥手，不会丢失数据。UDP快。</p><p>socket:注意参数是一个tuple，包含地址和端口号。</p><p>在同一个os中，端口不允许相同，即如果某个端口已经被使用了，那么在这个进程释放之前，其他进程都不能使用这个端口。（端口用来区分进程，若相同，不能把数据发送到准确的进程）</p><p>创建Socket时，AF_INET指定使用IPv4协议，如果要用更先进的IPv6，就指定为AF_INET6。SOCK_STREAM指定使用面向流的TCP协议，这样，一个Socket对象就创建成功，但是还没有建立连接。</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/%E7%BD%91%E7%BB%9C1.png" alt></p><p>coding：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/%E7%BD%91%E7%BB%9C2.png" alt></p><p>主机名可以通过调用socket.gethostname()获得</p><p>接收数据时，调用recv(max)方法，一次最多接收指定的字节数，因此，在一个while循环中反复接收，直到recv()返回空数据，表示接收完毕，退出循环。当我们接收完数据后，调用close()方法关闭Socket，这样，一次完整的网络通信就结束了</p><p>创建TCP连接时，主动发起连接的叫客户端，被动响应连接的叫服务器。 客户端要主动发起TCP连接，必须知道服务器的IP地址和端口号。</p><p>TCP服务端建立步骤：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/%E7%BD%91%E7%BB%9C3.png" alt></p><p><strong>一般是服务器（接受方）绑定端口，客户端（发送方）不绑定</strong></p><p>UDP不需要调用listen（）方法。可以直接接收数据</p><p>TCP调用listen()方法开始监听端口，将主动套接字（默认）变为被动套接字，传入的参数指定等待连接的最大数量</p><p>TCP服务端：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/%E7%BD%91%E7%BB%9C4.png" alt></p><p>TCP客户端：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/%E7%BD%91%E7%BB%9C5.png" alt></p><p>一般send()和recv()用于TCP，sendto()及recvfrom()用于UDP。sendto和recvfrom一般用于UDP协议中,但是如果在TCP中connect函数调用后也可以用。</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/%E7%BD%91%E7%BB%9C6.png" alt></p><p>服务器编程首先要绑定一个端口并监听来自其他客户端的连接。如果某个客户端连接过来了，服务器就与该客户端建立Socket连接，随后的通信就靠这个Socket连接了。</p><p>由于服务器会有大量来自客户端的连接，所以，服务器要能够区分一个Socket连接是和哪个客户端绑定的。一个Socket依赖4项：<strong>服务器地址、服务器端口、客户端地址、客户端端口</strong>来唯一确定一个Socket。但是服务器还需要同时响应多个客户端的请求，所以，每个连接都需要一个新的进程或者新的线程来处理，否则，服务器一次就只能服务一个客户端了。</p><p>然后，我们要绑定监听的地址和端口()。服务器可能有多块网卡，可以绑定到某一块网卡的IP地址上，也可以用<strong>0.0.0.0绑定到所有的网络地址</strong>，还可以用127.0.0.1绑定到本机地址。<strong>127.0.0.1是一个特殊的IP地址，表示本机地址</strong>，如果绑定到这个地址，客户端必须同时在本机运行才能连接，也就是说，外部的计算机无法连接进来。</p><p>端口号需要预先指定。请注意，小于1024的端口号必须要有管理员权限才能绑定：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/%E7%BD%91%E7%BB%9C7.png" alt></p><p>每个连接都必须创建新线程（或进程）来处理，否则，单线程在处理连接的过程中，无法接受其他客户端的连接</p><p>利用多线程和socket进行聊天室的创建（UDP）：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/%E7%BD%91%E7%BB%9C14.png" alt></p><p>下面这段代码是单进程服务器，配合进程或线程也可以建立多任务服务器（TCP）：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/%E7%BD%91%E7%BB%9C9.png" alt></p><p>serverSocket：当这个套接字被关闭时，代表不再接收新的客户端连接</p><p>clientSocket：当这个套接字被关闭时，代表不能使用send和recv发收数据。</p><p>当利用线程建立多任务服务器时，clientSocket不能关闭。因为子线程共用数据</p><p>当利用进程建立时，clientSocket能关闭。子进程和父进程完全”一样“（实时拷贝）</p><p>单进程实现多任务：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/%E7%BD%91%E7%BB%9C10.png" alt></p><p>最后，讲一下单播，多播和广播。</p><p>单播：一对一</p><p>多播：一对多</p><p>广播：一对所有 </p><p>UDP有广播，TCP没有广播</p><p>UDP发送广播数据的条件：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/%E7%BD%91%E7%BB%9C11.png" alt></p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/%E7%BD%91%E7%BB%9C12.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;​    今天，我们来讲一下网络编程。这里面用到一个库：&lt;strong&gt;socket&lt;/strong&gt;。网络通信其实就是两个进程之间在编程。先说两个重要的协议：TCP协议 和 UDP协议。TCP协议是传输控制协议，UDP协议是数据传输协议。TCP和UDP的区别：TCP慢但是
      
    
    </summary>
    
      <category term="python" scheme="http://yoursite.com/categories/python/"/>
    
      <category term="网络编程（socket）" scheme="http://yoursite.com/categories/python/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%EF%BC%88socket%EF%BC%89/"/>
    
    
      <category term="python的网络编程" scheme="http://yoursite.com/tags/python%E7%9A%84%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>正则表达式</title>
    <link href="http://yoursite.com/2019/08/05/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>http://yoursite.com/2019/08/05/正则表达式/</id>
    <published>2019-08-05T07:37:42.000Z</published>
    <updated>2019-08-05T12:01:17.619Z</updated>
    
    <content type="html"><![CDATA[<p>正则表达式（不能随意添加空格，不然会改变原来含义）：</p><p>元字符(不能匹配自身): . $ ^ ( ) { } [ ] $ + \ | *，</p><p>|：A | B 会匹配 A 或 B 中出现的任何字符。为了能够更加合理的工作，| 的优先级非常低。例如 Fish|C 应该匹配 Fish 或 C，而不是匹配 Fis，然后一个 ‘h’ 或 ‘C’。同样，我们使用 | 来匹配 ‘|’ 字符本身；或者包含在一个字符类中，像这样 [|]。</p><p>^:匹配字符串的起始位置。如果设置了 MULTILINE 标志，就会变成匹配每一行的起始位置。在 MULTILINE 中，每当遇到换行符就会立刻进行匹配。</p><p>$:匹配字符串的结束位置，每当遇到换行符也会离开进行匹配。</p><p>+：用于指定前一个字符匹配一次或多次</p><p><em>：</em>匹配的是零次或多次</p><p>？：指定前一个字符匹配零次或者一次。</p><p>{m，n}(m和n都是十进制整数)：它的含义是前一个字符必须匹配m次到n（包括n次）次之间</p><p>原始字符串来表示正则表达式（就是在字符串前边加上 r）</p><p>\A:只匹配字符串的起始位置。如果没有设置 MULTILINE 标志的时候，\A 和 ^ 的功能是一样的；但如果设置了 MULTILINE 标志，则会有一些不同：\A 还是匹配字符串的起始位置，但 ^ 会对字符串中的每一行都进行匹配。</p><p>\Z:只匹配字符串的结束位置</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/%E6%AD%A3%E5%88%991.png" alt></p><p>\B:另一个零宽断言，与 \b 的含义相反，\B 表示非单词边界的位置。</p><p><strong>零宽断言：</strong></p><p>有些元字符它们不匹配任何字符，只是简单地表示成功或失败，因此这些字符也称之为零宽断言</p><p><strong>前向断言：</strong></p><p>（1）：前向肯定断言：如果当前包含的正则表达式（这里以 … 表示）在当前位置成功匹配，则代表成功，否则失败。一旦该部分正则表达式被匹配引擎尝试过，就不会继续进行匹配了；剩下的模式在此断言开始的地方继续尝试。</p><p>（2）：前向否定断言：这跟前向肯定断言相反（不匹配则表示成功，匹配表示失败）</p><p>假定我们要处理一段html，我们要替换掉相对url，例如<a href="abc.html">text</a> 这个a标签我们要替换成text，而对于<a href="http://outofmemory.cn/code-snippet/" target="_blank" rel="noopener">代码</a> 这样的a标签则要保留不做替换。这个应用场景下</p><p>就需要判断A标签的href属性如果不是以http://开头则匹配，即要做前向否定的断言.</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/%E6%AD%A3%E5%88%992.png" alt></p><p>脱字符：^ ,例如[^  5  ]会匹配任何字符 “5”之外的任何字符</p><p>[ ]他们指定一个字符类用于存放你需要的字符集合。可以单独列出需要匹配字符，也可以两个字符和一个横杆-指定匹配的范围。元字符在方括号中不会触发“特殊功能”，在字符类中，它们只匹配自身。</p><p>反斜杠 \：如果在反斜杠后边紧跟着一个元字符，那么元字符的“特殊功能”也不会被触发。例如你需要匹配符号[ 或 \，你可以在他们前面加上一个反斜杠，以消除他们的特殊功能：\[ ,\\</p><p>注意用小括号括住要重复的内容：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/%E6%AD%A3%E5%88%993.png" alt></p><p>匹配ip（万能版）：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/%E6%AD%A3%E5%88%99.png" alt></p><p>非捕获组和命名组：</p><p>非捕获组的语法是 (?:…)，这个 … 你可以替换为任何正则表达式。</p><p>“捕获”就是匹配的意思啦，普通的子组都是捕获组，因为它们能从字符串中匹配到数据</p><p>命名组：：(?P<name>)。很明显，&lt; &gt; 里边的 name 就是命名组的名字啦，除了使用名字访问，</name></p><p>命名组仍然可以使用数字序号进行访问</p><p>正则表达式使用以下方法修改字符串：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/%E6%AD%A3%E5%88%995.png" alt></p><p><strong>split(***</strong>string<strong>***[,</strong> <strong><em>maxsplit=0**</em></strong>])<em>*：通过正则表达式匹配来分割字符串。如果在 RE 中，你使用了捕获组，那么它们的内容会作为一个列表返回。你可以通过传入一个 *maxsplit</em> 参数来设置分割的数量。如果 <em>maxsplit</em> 的值是非 0，表示至多有 <em>maxsplit</em> 个分割会被处理，剩下的内容作为列表的最后一个元素返回。</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/%E6%AD%A3%E5%88%996.png" alt></p><p><strong>.sub(***</strong>replacement<strong>***,</strong> <strong><em>string**</em></strong>[,<em>* <strong><em>count=0**</em></strong>])*<em>返回一个字符串，这个字符串从最左边开始，所有 RE 匹配的地方都替换成 *replacement</em>。如果没有找到任何匹配，那么返回原字符串。可选参数 *count</em> 指定最多替换的次数，必须是一个非负值。默认值是 0，意思是替换所有找到的匹配。下边是使用 sub() 方法的例子，它会将所有的颜色替换成 color：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/%E6%AD%A3%E5%88%997.png" alt></p><p>subn:subn() 方法跟 sub() 方法干同样的事情，但区别是返回值为一个包含有两个元素的元组：一个是替换后的字符串，一个是替换的数目。</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/%E6%AD%A3%E5%88%998.png" alt></p><p>匹配方法：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/%E6%AD%A3%E5%88%999.png" alt></p><p>匹配的方法和属性：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/%E6%AD%A3%E5%88%9910.png" alt></p><p>group(N) 返回第N组括号匹配的字符，groups() 返回所有括号匹配的字符，以tuple格式</p><p>match匹配的m：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/%E6%AD%A3%E5%88%9912.png" alt></p><p>findall() 需要在返回前先创建一个列表，而 finditer() 则是将匹配对象作为一个迭代器返回</p><p>利用compile来先编译的方法是模式级别的方法（适用于多次使用该正则表达式），可以针对同一种模式做多次匹配，如下图：另一种是模式对象方法 </p><p>import re import re</p><p>p=re.compile() re.search(“”,””)</p><p>p.search()</p><p>贪婪模式和非贪婪模式：</p><p>贪婪模式是让正则表达式尽可能的匹配符合的内容</p><p>在匹配的字符后面加一个问号，启动非贪婪模式</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/%E6%AD%A3%E5%88%9913.png" alt></p><p>编译标志：编译标志让你可以修改正则表达式的工作方式。在 re模块下，编译标志均有两个名字：完整名和简写</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/%E6%AD%A3%E5%88%9915.png" alt></p><p>ASCII(re.A)</p><p>使得 \w，\W，\b，\B，\s 和 \S 只匹配 ASCII 字符，而不匹配完整的 Unicode 字符。这个标志仅对 Unicode 模式有意义，并忽略字节模式。</p><p>DOTALL(re.S)</p><p>使得 . 可以匹配任何字符，包括换行符。如果不使用这个标志，. 将匹配除了换行符的所有字符。</p><p>IGNORECASE(re.I)</p><p>字符类和文本字符串在匹配的时候不区分大小写。举个例子，正则表达式 [A-Z] 也将会匹配对应的小写字母，像 FishC 可以匹配 FishC，fishc 或 FISHC 等。如果你不设置 LOCALE，则不会考虑语言（区域）设置这方面的大小写问题。</p><p>LOCALE(re.L)</p><p>使得 \w，\W，\b 和 \B 依赖当前的语言（区域）环境，而不是 Unicode 数据库。区域设置是 C 语言的一个功能，主要作用是消除不同语言之间的差异。例如你正在处理的是法文文本，你想使用 \w+ 来匹配单词，但是 \w 只是匹配 [A-Za-z] 中的单词，并不会匹配 ‘é’ 或 ‘&#231;’。如果你的系统正确的设置了法语区域环境，那么 C 语言的函数就会告诉程序 ‘é’ 或 ‘&#231;’ 也应该被认为是一个字符。当编译正则表达式的时候设置了 LOCALE 的标志，\w+ 就可以识别法文了，但速度多少会受到影响。</p><p>MULTILINE(re.M)</p><p>通常 ^ 只匹配字符串的开头，而 $ 则匹配字符串的结尾。当这个标志被设置的时候，^ 不仅匹配字符串的开头，还匹配每一行的行首；&amp; 不仅匹配字符串的结尾，还匹配每一行的行尾。</p><p>VERBOSE(re.X)</p><p>这个标志使你的正则表达式可以写得更好看和更有条理，因为使用了这个标志，空格会被忽略（除了出现在字符类中和使用反斜杠转义的空格）；这个标志同时允许你在正则表达式字符串中使用注释， 符号后边的内容是注释，不会递交给匹配引擎（除了出现在字符类中和使用反斜杠转义的 ）</p><p>正则表达式特殊符号及用法：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/%E6%AD%A3%E5%88%9916.png" alt></p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/%E6%AD%A3%E5%88%9917.png" alt></p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/%E6%AD%A3%E5%88%9919.png" alt></p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/%E6%AD%A3%E5%88%9920.png" alt></p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/%E6%AD%A3%E5%88%9921.png" alt></p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/%E6%AD%A3%E5%88%9923.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;正则表达式（不能随意添加空格，不然会改变原来含义）：&lt;/p&gt;
&lt;p&gt;元字符(不能匹配自身): . $ ^ ( ) { } [ ] $ + \ | *，&lt;/p&gt;
&lt;p&gt;|：A | B 会匹配 A 或 B 中出现的任何字符。为了能够更加合理的工作，| 的优先级非常低。例如 Fi
      
    
    </summary>
    
      <category term="python" scheme="http://yoursite.com/categories/python/"/>
    
      <category term="正则表达式" scheme="http://yoursite.com/categories/python/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
    
      <category term="正则表达式" scheme="http://yoursite.com/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
  </entry>
  
</feed>
