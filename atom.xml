<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>DY的个人博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-09-04T14:30:34.203Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>湛蓝星空</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>数据库概述</title>
    <link href="http://yoursite.com/2019/09/04/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%A6%82%E8%BF%B0/"/>
    <id>http://yoursite.com/2019/09/04/数据库概述/</id>
    <published>2019-09-04T12:02:01.000Z</published>
    <updated>2019-09-04T14:30:34.203Z</updated>
    
    <content type="html"><![CDATA[<p>​    大三老狗已正式上线，这学期学了新的课程。其中一门就是数据库，总结一下所学的内容。</p><p>数据与信息的联系：数据是信息的符号表示或载体。信息是数据的内涵，是对数据的语义解释。</p><p>数据库数据具有永久存储、有组织、可共享三个基本特点。</p><p>数据库系统(DBS)由计算机硬件、数据库、数据库管理系统、应用软件和数据库管理系统组成。</p><p>数据库设计时面向数据模型对象、数据库系统的数据冗余度小、数据共享度高、数据库系统的数据和程序之间具有较高的独立性、数据库中数据的最小存取单位是数据项、数据库系统通过DBMS进行数据安全性、完整性、并发控制和数据恢复控制。</p><p>数据库数据物理独立性高是指当数据的物理结构（存储结构）发生变化时，应用程序不需要修改也可以正常工作</p><p>数据库数据逻辑独立性高是指当数据库系统的数据全局逻辑结构改变时，它们对应的应用程序不需要改变仍可以正常运行</p><p>DBMS的功能结构</p><p>​    数据定义功能：能够提供数据定义语言(DDL)和相应的建库机制。用户利用DDL可以方便建立数据库。</p><p>​    数据操纵功能：实现数据的插入、修改、删除、查询、统计等数据存取操作的功能称为数据操纵功能。数据库管理系统通过提供数据操纵语言(DML)实现其数据操纵功能。</p><p>​    运行管理功能：包括并发控制、数据的存取控制、数据完整性条件的检查和执行、数据库内部的维护等</p><p>​    建立和维护功能：指数据的载入、转储、重组织功能及数据库的恢复功能，指数据库结构的修改、变更及扩充功能。</p><p>从数据库管理系统的角度查看，数据库系统通常采用外模式、模式、内模式三级模式结构。从数据库最终用户的角度看，数据库系统的就够分为单用户结构、主从结构、分布式结构、客户/服务器结构。</p><p>外模式：也称为子模式或用户模式。它是数据库用户看见和使用的、对局部数据的逻辑结构和特征的描述，是与某一应用有关的数据的逻辑表示。</p><p>模式：模式是数据库中数据的逻辑结构和特征的描述。它仅仅涉及到<strong>型</strong>的描述，不涉及到具体的值。模式的具体值被称为模式的一个实例。同一模式可以有很多实例。模式是相对稳定的，实例是相对变动的。模式反映的是数据的结构及其关系，而实例反映的是数据某一时刻的状态。</p><p>内模式：也称存储模式，它是对数据的物理结构和存储结构的描述，是数据在数据库内部的表示方式。</p><p>为了能够在内部实现这三个抽象层次的联系和转换，数据库系统在这三级模式之间提供了两层映像：外模式/概念模式映像、概念模式/内模式映像。这两层映像保证了数据库系统中的数据能够具有较高的逻辑独立性和物理独立性。</p><p>外模式/模式映像保证了数据与程序间的逻辑独立性，模式/内模式映像保证了数据的物理独立性。</p><p>逻辑独立性：当数据库的整体逻辑结构发生变化时，通过调整外模式和模式之间的映像，使得外模式中的局部数据及其结构不变，程序不在修改。</p><p>物理独立性：当数据库的存储结构发生变化时，通过调整模式和内模式之间的映像，使得整体模式不变，当然外模式及应用程序不用改变。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;​    大三老狗已正式上线，这学期学了新的课程。其中一门就是数据库，总结一下所学的内容。&lt;/p&gt;
&lt;p&gt;数据与信息的联系：数据是信息的符号表示或载体。信息是数据的内涵，是对数据的语义解释。&lt;/p&gt;
&lt;p&gt;数据库数据具有永久存储、有组织、可共享三个基本特点。&lt;/p&gt;
&lt;p&gt;
      
    
    </summary>
    
      <category term="数据库" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="数据库概述" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%A6%82%E8%BF%B0/"/>
    
    
      <category term="数据库" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>激活函数以及作用</title>
    <link href="http://yoursite.com/2019/09/03/%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0/"/>
    <id>http://yoursite.com/2019/09/03/激活函数/</id>
    <published>2019-09-03T13:37:07.000Z</published>
    <updated>2019-09-03T14:01:05.002Z</updated>
    
    <content type="html"><![CDATA[<p>本片博客介绍以下激活函数以及激活函数的作用。</p><p>首先激活函数是非线性连续的，激活函数有Sigmoid、tanh、Relu、Leaky Relu、Maxout、ELU。</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/DL50.png" alt></p><p>激活函数（Activation functions）对于人工神经网络模型去学习、理解非常复杂和非线性的函数来说具有十分重要的作用。它们将非线性特性引入到我们的网络中。其主要目的是将A-NN模型中一个节点的输入信号转换成一个输出信号。该输出信号现在被用作堆叠中下一个层的输入。</p><p>问题一：为什么我们不能在不激活输入信号的情况下完成此操作呢？</p><p>如果我们不运用激活函数的话，则输出信号将仅仅是一个简单的线性函数。线性函数一个一级多项式。现如今，线性方程是很容易解决的，但是它们的复杂性有限，并且从数据中学习复杂函数映射的能力更小。一个没有激活函数的神经网络将只不过是一个线性回归模型（Linear regression Model）罢了，它功率有限，并且大多数情况下执行得并不好。我们希望我们的神经网络不仅仅可以学习和计算线性函数，而且还要比这复杂得多。同样是因为没有激活函数，我们的神经网络将无法学习和模拟其他复杂类型的数据，例如图像、视频、音频、语音等。这就是为什么我们要使用人工神经网络技术，诸如深度学习（Deep learning），来理解一些复杂的事情，一些相互之间具有很多隐藏层的非线性问题，而这也可以帮助我们了解复杂的数据。</p><p>问题二：那么为什么我们需要非线性函数？</p><p>非线性函数是那些一级以上的函数，而且当绘制非线性函数时它们具有曲率。现在我们需要一个可以学习和表示几乎任何东西的神经网络模型，以及可以将输入映射到输出的任意复杂函数。神经网络被认为是通用函数近似器（Universal Function Approximators）。这意味着他们可以计算和学习任何函数。几乎我们可以想到的任何过程都可以表示为神经网络中的函数计算。</p><p>接下来介绍一下常用的激活函数：sigmoid、tanh、Relu</p><p>sigmoid：该函数是将取值为 (−∞,+∞)(−∞,+∞) 的数映射到 (0,1)(0,1) 之间。sigmoid函数的公式以及图形如下：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/DL45.png" alt></p><p>缺点：当 zz 值<strong>非常大</strong>或者<strong>非常小</strong>时，通过上图我们可以看到，sigmoid函数的导数 g′(z)将接近 00 。这会导致权重 W 的梯度将接近 00 ，使得梯度更新十分缓慢，即<strong>梯度消失</strong></p><p>tanh：该函数是将取值为 (−∞,+∞)(−∞,+∞) 的数映射到 (−1,1)(−1,1) 之间，其公式与图形为：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/DL42.png" alt></p><p>tanh函数的缺点同sigmoid函数的第一个缺点一样，当 zz <strong>很大或很小</strong>时，g′(z)接近于 0 ，会导致梯度很小，权重更新非常缓慢，即<strong>梯度消失问题</strong>。</p><p>Relu函数：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/DL41.png" alt></p><p>Leaky Relu：这是一种对ReLU函数改进的函数，又称为PReLU函数，但其并不常用。其公式与图形如下：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/DL43.png" alt></p><p>  其中a取值在（0，1）之间</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本片博客介绍以下激活函数以及激活函数的作用。&lt;/p&gt;
&lt;p&gt;首先激活函数是非线性连续的，激活函数有Sigmoid、tanh、Relu、Leaky Relu、Maxout、ELU。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.
      
    
    </summary>
    
      <category term="深度学习" scheme="http://yoursite.com/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="激活函数" scheme="http://yoursite.com/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0/"/>
    
    
      <category term="激活函数" scheme="http://yoursite.com/tags/%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>SSD实战-tensorflow实现目标检测</title>
    <link href="http://yoursite.com/2019/09/03/SSD%E5%AE%9E%E6%88%98-tensorflow%E5%AE%9E%E7%8E%B0%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/"/>
    <id>http://yoursite.com/2019/09/03/SSD实战-tensorflow实现目标检测/</id>
    <published>2019-09-03T11:35:07.000Z</published>
    <updated>2019-09-03T14:05:37.345Z</updated>
    
    <content type="html"><![CDATA[<p>​    因为caffe的环境实在是难搭，所以将实战的框架改为tensorflow</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;​    因为caffe的环境实在是难搭，所以将实战的框架改为tensorflow&lt;/p&gt;

      
    
    </summary>
    
      <category term="目标检测" scheme="http://yoursite.com/categories/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/"/>
    
      <category term="one-stage" scheme="http://yoursite.com/categories/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/one-stage/"/>
    
      <category term="SSD" scheme="http://yoursite.com/categories/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/one-stage/SSD/"/>
    
      <category term="SSD实战" scheme="http://yoursite.com/categories/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/one-stage/SSD/SSD%E5%AE%9E%E6%88%98/"/>
    
    
      <category term="SSD实战" scheme="http://yoursite.com/tags/SSD%E5%AE%9E%E6%88%98/"/>
    
  </entry>
  
  <entry>
    <title>人脸检测数据集构造</title>
    <link href="http://yoursite.com/2019/08/28/%E4%BA%BA%E8%84%B8%E6%A3%80%E6%B5%8B%E6%95%B0%E6%8D%AE%E9%9B%86%E6%9E%84%E9%80%A0/"/>
    <id>http://yoursite.com/2019/08/28/人脸检测数据集构造/</id>
    <published>2019-08-28T07:08:15.000Z</published>
    <updated>2019-09-03T11:33:26.161Z</updated>
    
    <content type="html"><![CDATA[<p>在这次实战中，我们使用了caffe来作为我们的框架。所以，在打包数据格式的时候，打包成VOC数据格式的数据集，得到的数据集将采用LMDB的格式对数据进行封装。如果用的是tensorflow来训练SSD模型，那就将数据打包成TFRecoder数据格式的数据。</p><p>Caffe-SSD数据集构造流程：</p><p>1、生成VOC个数数据集（图片、XML标注信息文件）</p><p>2、修改Caffe-SSD数据打包脚本相关路径配置</p><p>3、运行Caffe-SSD数据打包脚本</p><p>VOC格式数据集的目录下有三个文件夹：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/SSD6.png" alt></p><p>Annotation中保存的是xml格式的label信息</p><p>ImageSet中Main目录中存放不同照片列表文件</p><p>​    train.txt：训练图片文件名列表</p><p>​    val.txt：验证图片文件名列表</p><p>​    trianval.txt：训练和验证的图片文件名列表</p><p>​    test.txt：测试图片文件名列表</p><p>JPEGImages目录存放所有的图片集。Annotation和JPEGImages一一对应。</p><p>WIDERFace数据集：打开<a href="http://mmlab.ie.cuhk.edu.hk/project/WIDERFace" target="_blank" rel="noopener">人脸检测数据集地址</a>下载数据集。</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/SSD7.png" alt></p><p>下载数据的训练集、验证集、测试集和标注信息。</p><p>打开标注信息，可以看到文件夹中有很多txt文件，打开看一下：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/SSD9.png" alt>****</p><p>对于VOC格式的数据集，最主要的是生成两个文件。一个是图片的标注数据，另一个是图片数据。对于图片数据，我们只需要将wider_face的图片放到对应目录下，而对于标注数据，我们需要将上面图片的文件进行解析来重新生成针对每张图片的标注信息，这个信息用XML格式存储。</p><p>对于wider_face转为voc，首先创建Annotation、ImageSets、JPEGImages三个文件夹，其中ImageSets中再创建一个Main文件夹。</p><p>将wider_face转为voc的coding：</p><p><code>import os,cv2,sys,shutilfrom xml.dom.minidom import Documentdef writexml(filename,saveing,bboxes,xmlpath):  doc=Document()  annotation=doc.createElement(&quot;annotation&quot;)  doc.appendChild(annotation)  folder=doc.createElement(&quot;folder&quot;)  folder_name=doc.createTextNode(&quot;widerface&quot;)  folder.appendChild(folder_name)  annotation.appendChild(folder)  filenamenode=doc.createElement(&quot;filename&quot;)  filename_name=doc.createTextNode(filename)  filenamenode.appendChild(filename_name)  annotation.appendChild(filenamenode)  source=doc.createElement(&quot;source&quot;)  annotation.appendChild(source)  database=doc.createElement(&quot;database&quot;)  database.appendChild(doc.createTextNode(&quot;wider face database&quot;))  source.appendChild(database)  annotation_s=doc.createElement(&quot;annotation&quot;)  annotation_s.appendChild(doc.createTextNode(&quot;PASCAL VOC2007&quot;))  source.appendChild(annotation_s)  image=doc.createElement(&quot;image&quot;)  image.appendChild(doc.createTextNode(&quot;flickr&quot;))  source.appendChild(image)  flickrid=doc.createElement(&quot;flickrid&quot;)  source.appendChild(doc.createTextNode(&quot;-1&quot;))  source.appendChild(flickrid)  owner=doc.createElement(&quot;owner&quot;)  annotation.appendChild(owner)  flickrid_o=doc.createElement(&quot;flickrid&quot;)  flickrid_o.appendChild(doc.createTextNode(&quot;yanyu&quot;))  owner.appendChild(flickrid_o)  name_o=doc.createElement(&quot;name&quot;)  name_o.appendChild(doc.createTextNode(&quot;yanyu&quot;))  owner.appendChild(name_o)  size=doc.createElement(&quot;size&quot;)  annotation.appendChild(size)  width=doc.createElement(&quot;width&quot;)  width.appendChild(doc.createTextNode(str(saveing.shape[1])))  height=doc.createElement(&quot;height&quot;)  height.appendChild(doc.createTextNode(str(saveing.shape[0])))  depth=doc.createElement(&quot;depth&quot;)  depth.appendChild(doc.createTextNode(str(saveing.shape[2])))  size.appendChild(width)  size.appendChild(height)  size.appendChild(depth)  segmented=doc.createElement(&quot;segmented&quot;)  segmented.appendChild(doc.createTextNode(&quot;0&quot;))  annotation.appendChild(segmented)  for i in range(len(bboxes)):    bbox=bboxes[i]    objects=doc.createElement(&quot;object&quot;)    annotation.appendChild(objects)    object_name=doc.createElement(&quot;name&quot;)    object_name.appendChild(doc.createTextNode(&quot;face&quot;))    objects.appendChild(object_name)    pose=doc.createElement(&quot;pose&quot;)    pose.appendChild(doc.createTextNode(&quot;Unspecified&quot;))    objects.appendChild(pose)    truncated=doc.createElement(&quot;truncated&quot;)    truncated.appendChild(doc.createTextNode(&quot;1&quot;))    objects.appendChild(truncated)    difficult=doc.createElement(&quot;difficult&quot;)    difficult.appendChild(difficult)    difficult.appendChild(doc.createTextNode(&quot;0&quot;))    objects.appendChild(difficult)    bndbox=doc.createElement(&quot;bndbox&quot;)    objects.appendChild(bndbox)    xmin=doc.createElement(&quot;xmin&quot;)    xmin.appendChild(doc.createTextNode(str(bbox[0])))    bndbox.appendChild(xmin)    ymin=doc.createElement(&quot;ymin&quot;)    ymin.appendChild(doc.createTextNode(str(bbox[1])))    bndbox.appendChild(ymin)    xmax=doc.createElement(&quot;xmax&quot;)    xmax.appendChild(doc.createTextNode(str(bbox[0]+bbox[2])))    bndbox.appendChild(xmax)    ymax=doc.createElement(&quot;ymax&quot;)    ymax.appendChild(doc.createTextNode(str(bbox[1]+bbox[3])))    bndbox.appendChild(ymax)  f=open(xmlpath,&quot;w&quot;)  f.write(doc.toprettyxml(indent=&quot; &quot;))  f.close()rootdir=&quot;./wider_face&quot;def convertimgset(img_set):  imgdir=rootdir+&quot;/WIDER_&quot;+img_set+&quot;/images&quot;  gtfilepath=rootdir+&quot;/wider_face_split/wider_face_&quot;+img_set+&quot;_bbx_gt.txt&quot;  fwrite=open(rootdir+&quot;/ImageSets/Main&quot;+img_set+&quot;.txt&quot;,&quot;w&quot;)  index=0  with open(gtfilepath,&quot;r&quot;) as gtfiles:    while(index&lt;1000):      filename=gtfiles.readline()[:-1]      if (filename==&quot;&quot;):        continue      imgpath=imgdir+&quot;/&quot;+filename      img=cv2.imread(imgpath)      if not img.data:        break      numbbox=int(gtfiles.readline())      bboxes=[]      for i in range(numbbox):        line=gtfiles.readline()        lines=line.split()        lines=lines[0:4]        bbox=(int(lines[0]),int(lines[1]),int(lines[2]),int(lines[3]))        bboxes.append(bbox)      filename=filename.replace(&quot;/&quot;,&quot; &quot;)      if len(bboxes)==0:        print(&quot;no face&quot;)      cv2.imwrite(&quot;{}/JPEGImages/{}&quot;.format(rootdir,filename),img)      fwrite.write(filename.split(&quot;.&quot;)[0]+&quot;\n&quot;)      xmlpath=&quot;{}/Annotations/{}&quot;.format(rootdir,filename.split(&quot;.&quot;)[0])      writexml(filename,img,bboxes,xmlpath)      print(&quot;第%d张成功的图片&quot; % index)      index+=1    fwrite.close()if __name__==&quot;__main__&quot;:  img_sets=[&quot;train&quot;,&quot;val&quot;]  for img_set in img_sets:    convertimgset(img_set)  shutil.move(rootdir+&quot;/ImageSets/Main/&quot;+&quot;train.txt&quot;,rootdir+&quot;/ImageSets/Main/&quot;+&quot;trainval.txt&quot;)  shutil.move(rootdir+&quot;/ImageSets/Main/&quot;+&quot;val.txt&quot;,rootdir+&quot;/ImageSets/Main/&quot;+&quot;test.txt&quot;)</code></p><p>这篇博客废了。。。。caffe的环境太难搭了。。。。</p><p>我将框架换成tensorflow，进行另一个实战</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在这次实战中，我们使用了caffe来作为我们的框架。所以，在打包数据格式的时候，打包成VOC数据格式的数据集，得到的数据集将采用LMDB的格式对数据进行封装。如果用的是tensorflow来训练SSD模型，那就将数据打包成TFRecoder数据格式的数据。&lt;/p&gt;
&lt;p&gt;C
      
    
    </summary>
    
      <category term="目标检测" scheme="http://yoursite.com/categories/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/"/>
    
      <category term="one—stage" scheme="http://yoursite.com/categories/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/one%E2%80%94stage/"/>
    
      <category term="SSD" scheme="http://yoursite.com/categories/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/one%E2%80%94stage/SSD/"/>
    
      <category term="SSD实战" scheme="http://yoursite.com/categories/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/one%E2%80%94stage/SSD/SSD%E5%AE%9E%E6%88%98/"/>
    
      <category term="构造数据集" scheme="http://yoursite.com/categories/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/one%E2%80%94stage/SSD/SSD%E5%AE%9E%E6%88%98/%E6%9E%84%E9%80%A0%E6%95%B0%E6%8D%AE%E9%9B%86/"/>
    
    
      <category term="SSD算法" scheme="http://yoursite.com/tags/SSD%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>SSD实战-人脸检测</title>
    <link href="http://yoursite.com/2019/08/28/SSD%E5%AE%9E%E6%88%98-%E4%BA%BA%E8%84%B8%E6%A3%80%E6%B5%8B/"/>
    <id>http://yoursite.com/2019/08/28/SSD实战-人脸检测/</id>
    <published>2019-08-28T01:51:26.000Z</published>
    <updated>2019-09-01T11:56:18.670Z</updated>
    
    <content type="html"><![CDATA[<p>人脸标注方法：矩形标注和椭圆形标注</p><p>矩形标注都是用一个矩形框将画面中的人脸区域包含在内，这种标记方法很难给出一个恰好包含面部的矩形框。而人脸天然呈现椭圆形，椭圆形标注是一种较为准确的方法。椭圆形标注返回值包括：椭圆的长轴半径、椭圆的短轴半径、椭圆长轴偏转角度、椭圆圆心x坐标、椭圆圆心y坐标。</p><p>判断算法性能好坏：</p><p>每一个标记只允许有一个检测与之相对应，也就是说，我们检测出来的每一个人脸图像只能同我们在标注中人脸图像中数据中的一个相对应。如果有多个，就会视为重复检测。重复检测会被视为错误检测。接着我们就可以得出正确率和错误率，可以画出ROC曲线和PR曲线。可以根据曲线看出算法的好坏。</p><p>人脸采集常用方法：</p><p><strong>活体检测</strong>  判断用户是否为正常操作，通过指定用户做随机动作，一搬有张嘴、摇头、点头、凝视、眨眼等等，防止照片攻击。判断用户是否真实在操作，指定用户上下移动手机，防止视频攻击和非正常动作的攻击。</p><p><strong>3D检测</strong>  验证采集到的是否为立体人像，能够防止平面照片、不同弯曲程度的照片等。</p><p><strong>连续检测</strong>  通过连续的检测，验证运动轨迹是否正常，防止跳过活体检测直接替换采集的照片，也能防止中途换人。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;人脸标注方法：矩形标注和椭圆形标注&lt;/p&gt;
&lt;p&gt;矩形标注都是用一个矩形框将画面中的人脸区域包含在内，这种标记方法很难给出一个恰好包含面部的矩形框。而人脸天然呈现椭圆形，椭圆形标注是一种较为准确的方法。椭圆形标注返回值包括：椭圆的长轴半径、椭圆的短轴半径、椭圆长轴偏转角度、
      
    
    </summary>
    
      <category term="目标检测" scheme="http://yoursite.com/categories/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/"/>
    
      <category term="one-stage" scheme="http://yoursite.com/categories/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/one-stage/"/>
    
      <category term="SSD" scheme="http://yoursite.com/categories/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/one-stage/SSD/"/>
    
      <category term="SSD实战" scheme="http://yoursite.com/categories/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/one-stage/SSD/SSD%E5%AE%9E%E6%88%98/"/>
    
      <category term="人脸检测综述" scheme="http://yoursite.com/categories/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/one-stage/SSD/SSD%E5%AE%9E%E6%88%98/%E4%BA%BA%E8%84%B8%E6%A3%80%E6%B5%8B%E7%BB%BC%E8%BF%B0/"/>
    
    
      <category term="SSD算法" scheme="http://yoursite.com/tags/SSD%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>目标检测常用名词</title>
    <link href="http://yoursite.com/2019/08/22/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E5%B8%B8%E7%94%A8%E5%90%8D%E8%AF%8D/"/>
    <id>http://yoursite.com/2019/08/22/目标检测常用名词/</id>
    <published>2019-08-22T01:49:17.000Z</published>
    <updated>2019-09-03T12:17:18.677Z</updated>
    
    <content type="html"><![CDATA[<p>图像分类：一张图像中是否包含某种物体</p><p>物体检测识别：若细分该任务可得到两个子任务，即目标检测，与目标识别，首先检测是视觉感知得第一步，它尽可能搜索出图像中某一块存在目标（形状、位置）。而目标识别类似于图像分类，用于判决当前找到得图像块得目标具体是什么类别。</p><p>语义分割：按对象得内容进行图像得分割，分割的依据是内容，即对象类别。</p><p>实例分割：按对象个体进行分割，分割的依据是单个目标。</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/%E7%9B%AE%E6%A0%8717.png" alt></p><p><strong>滑动窗口</strong>——为什么要有候选区域？既然目标是在图像中的某一区域，那么最直接的方法就是滑窗法（sliding window approach），就是遍历图像的所有区域，用不同大小的窗口在整个图像上滑动，那么就会产生所有的矩形区域，然后再后续排查，思路很简单，但是开销巨大。</p><p>region proposal（RP）：候选区域</p><p>IOU：region proposal与Ground Truth的窗口的交集比并集的比值，相当于准确率。‘</p><p>SPP：Spatial Pyramid Pooling  空间金字塔采样  在pooing的过程中计算pooling后的结果对应的两个像素点映射到feature map上所占的范围，然后在那个范围中进行max或者average。</p><p>ROI Pooling：就是将一个个大小不同的box矩形框，都映射到大小为w*h的矩形框。</p><p>Anchor：请看<a href="[https://brickexperts.github.io/2019/08/18/Two-stage%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D/#more](https://brickexperts.github.io/2019/08/18/Two-stage基本介绍/#more)">Two-stage基本介绍</a></p><p>GT box:Ground Truth box</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/%E7%9B%AE%E6%A0%8722.png" alt></p><p>如上图所示，绿色的框为飞机的Ground Truth，红色的框是提取的Region Proposal。那么即便红色的框被分类器识别为飞机，但是由于红色的框定位不准(IoU&lt;0.5)，那么这张图相当于没有正确的检测出飞机。如果我们能对红色的框进行微调，使得经过微调后的窗口跟Ground Truth更接近，这样岂不是定位会更准确。</p><p>带孔卷积：就是不增加参数数量和model复杂度的情况下扩大卷积的感受域，用dialation_rate设置扩张率。类似于形态学操作中的膨胀。</p><p>如下图所示，(a)是普通的3×33×3卷积，其视野就是3×33×3，(b)是扩张率为2，此时视野变成7×77×7，(c)扩张率为4时，视野扩大为15×1515×15，但是视野的特征更稀疏了。</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/SSD10.png" alt></p><p>后面遇见会继续完善。。。。。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;图像分类：一张图像中是否包含某种物体&lt;/p&gt;
&lt;p&gt;物体检测识别：若细分该任务可得到两个子任务，即目标检测，与目标识别，首先检测是视觉感知得第一步，它尽可能搜索出图像中某一块存在目标（形状、位置）。而目标识别类似于图像分类，用于判决当前找到得图像块得目标具体是什么类别。&lt;/
      
    
    </summary>
    
      <category term="目标检测" scheme="http://yoursite.com/categories/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/"/>
    
      <category term="常用名词解释" scheme="http://yoursite.com/categories/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/%E5%B8%B8%E7%94%A8%E5%90%8D%E8%AF%8D%E8%A7%A3%E9%87%8A/"/>
    
    
      <category term="目标检测" scheme="http://yoursite.com/tags/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/"/>
    
  </entry>
  
  <entry>
    <title>SSD系列算法</title>
    <link href="http://yoursite.com/2019/08/21/SSD%E7%B3%BB%E5%88%97%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2019/08/21/SSD系列算法/</id>
    <published>2019-08-21T01:05:48.000Z</published>
    <updated>2019-09-04T11:54:49.116Z</updated>
    
    <content type="html"><![CDATA[<h2 id="主干网络介绍"><a href="#主干网络介绍" class="headerlink" title="主干网络介绍"></a>主干网络介绍</h2><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/%E7%9B%AE%E6%A0%8720.png" alt></p><p>主干网络原始作者采用的VGG16，我们也可以将其他神经网络作为主干网络。例如：ResNet、MobileNets等</p><p>输入300<em>300的image，将VGG16网络FC6、FC7换成conv6和conv7，同时将池化层变为stride=1，pool_size=3\</em>3，这样做的目的是为了不减少feature map  size，为了配合这种变化，conv6会使用扩张率为6的带孔卷积。</p><p>​    <strong>带孔卷积</strong>：就是不增加参数数量和model复杂度的情况下扩大卷积的感受域，用dialation_rate设置扩张率。类似于形态学操作中的膨胀。具体看<a href="[https://brickexperts.github.io/2019/08/22/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E5%B8%B8%E7%94%A8%E5%90%8D%E8%AF%8D/#more](https://brickexperts.github.io/2019/08/22/目标检测常用名词/#more)">目标检测常用名词</a></p><p>接着然后移除dropout层和fc8层，并新增conv7，conv8，conv9，conv10，conv11，在检测数据集上做finetuing。其中VGG16中的Conv4_3层将作为用于检测的第一个特征图。conv4_3层特征图大小是38×38，但是该层比较靠前，其norm较大，所以在其后面增加了一个L2 Normalization层（参见ParseNet），以保证和后面的检测层差异不是很大，这个和Batch Normalization层不太一样，其仅仅是对每个像素点在channle维度做归一化，而Batch Normalization层是在[batch_size, width, height]三个维度上做归一化。归一化后一般设置一个可训练的放缩变量gamma。</p><h2 id="多尺度feature-map预测"><a href="#多尺度feature-map预测" class="headerlink" title="多尺度feature map预测"></a>多尺度feature map预测</h2><p>多尺度feature map预测，也就是在预测的时候，在接下来预测的时候，针对接下来六个不同的尺寸进行预测。如下图的六条连线，分别是38*38、19*19、10*10、5*5、3*3、1*1。将这六个不同尺度的feature map分别作为检测、预测层的输入，最后通过NMS进行筛选和合并。</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/%E7%9B%AE%E6%A0%8720.png" alt></p><p>对于六种不同尺度的网络，我们通常使用pooling来降采样。对于每一层的feature map，我们输入到相应的预测网络中。而预测网络中，我们会包括Prior box的提取过程。Prior box对应Fast R-CNN中Anchor的概念，也就是说，在Prior box中，feature map上的每一个点都作为一个cell（相当于Anchor）。以这个cell为中心，按照等比的放缩，找到它在原始图片的位置。接着以这个点为中心，提取不同尺度bounding box。而这些不同尺度的bounding box就是Prior box。然后对于每一个Prior box，我们通过和真值比较，就能够拿到它的label。对于每一个Prior box，我们都会分别预测它的类别概率和坐标（x，y，w，h）。也就是说，对于每一个cell，我们会将它对应到不同的Prior box，分别来预测当前这个Prior box所对应当前这个类别的概率分布和坐标。</p><p><strong>对Prior Box的具体定义：</strong></p><p>这里我们假设Prior Box的输入是m*n维的feature map。</p><p>如果每一个点都作为cell，那就会有m<em>n个cell。接着每个cell上生成固定尺寸和不同长宽比例的box。每个cell对应k个bounging box，每个bounding box预测c个类别分数和4个偏移坐标。其中c个类别分数实际上是当前bounding box所对应的不同类别的概率分布。如果输入大小为m\</em>n，那就会输出(c+4)*k*m*n。其中尺寸(scale)和比例(ratio)是超参数。</p><p>接下来我们看看Prior box是怎么生成的：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/%E7%9B%AE%E6%A0%8721.png" alt></p><p>每个feature map上的点定义了六种长宽比的default box。也就是说，最后对于每一个anchor都会获得六个不同尺寸和长宽比的default box。对于38<em>38层，每个feature map上的点，我们都会提取4个default box作为prior box。对于19\</em>19层、10*10层、5*5，提取6个default box也就是全部都是prior box。而3*3、1*1提取4个default作为prior box。所以最后得到8732个prior box(38*38*4+19*19*6+10*10*6+5*5*6+3*3*4+1*1*4)。<strong>prior box就是选择的default box</strong>。尺寸和比例都是可以通过SSD的配置文件进行配置，后面实战详解。</p><p>对default box进行筛选成为prior box：每一个feature map cell不是k个default box都取，prior box与GT box(<a href="https://brickexperts.github.io/" target="_blank" rel="noopener">Ground Truth box</a>)做匹配，IOU&gt;阈值为正样本。IOU&lt;阈值 为负样本。介于正样本和负样本中间阈值的default box去掉。</p><h2 id="SSD系列算法优化及扩展"><a href="#SSD系列算法优化及扩展" class="headerlink" title="SSD系列算法优化及扩展"></a>SSD系列算法优化及扩展</h2><p>SSD算法对小目标不够鲁棒，原因最主要是浅层feature map的表征能力不够强。</p><p>DSSD：</p><p>DSSD相当原来的SSD模型主要作了两大更新。一是替换掉VGG，而改用了Resnet-101作为特征提取网络并在对不同尺度feature maps特征进行default boxes检测时使用了更新的检测单元；二则在网络的后端使用了多个deconvolution layers以有效地扩展低维度信息的contextual information，从而有效地提高了小尺度目标的检测。</p><p>下图为DSSD模型与SSD模型的整体网络结构对比：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/SSD4.png" alt></p><p>DSOD：</p><p>SSD+DenseNet=DSOD</p><p>DSOD可以从0开始训练数据，不需要预训练模型。</p><p>FSSD：</p><p>借鉴了FPN的思想，重构了一组pyramid feature map（金字塔特征），使得算法的精度有了明显特征，速度也没有下降很多。具体是把网络中某些feature调整为同一size再contact（连接），得到一个像素层，以此层为base layer来生成pyramid feature map，作者称之为Feature Fusion Module。</p><p>Feature Fusion</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/SSD2.png" alt></p><p>对上面图的解读：</p><p>​    (a) image pyramid </p><p>​    (b) rcnn系列，只在最后一层feature预测 </p><p>​    (c) FPN，语义信息一层传递回去，而且有很多相加的计算 </p><p>​    (d) SSD，在各个level的feature上直接预测，每个level之间没联系 </p><p>​    (e) FSSD的做法，把各个level的feature concat，然后从fusion feature上生成feature pyramid</p><p>FSSD网络结构：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/SSD3.png" alt></p><p>RSSD：</p><p>rainbow concatenation方式(pooling加deconvolution)融合不同层的特征，再增加不同层之间feature map关系的同时也增加了不同层的feature map个数。这种融合方式不仅解决了传统SSD算法存在的重复框问题，同时一定程度上解决了small object的检测问题。</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/SSD1.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;主干网络介绍&quot;&gt;&lt;a href=&quot;#主干网络介绍&quot; class=&quot;headerlink&quot; title=&quot;主干网络介绍&quot;&gt;&lt;/a&gt;主干网络介绍&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Brickexper
      
    
    </summary>
    
      <category term="目标检测" scheme="http://yoursite.com/categories/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/"/>
    
      <category term="one-stage" scheme="http://yoursite.com/categories/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/one-stage/"/>
    
      <category term="SSD" scheme="http://yoursite.com/categories/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/one-stage/SSD/"/>
    
      <category term="SSD原理" scheme="http://yoursite.com/categories/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/one-stage/SSD/SSD%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="SSD算法" scheme="http://yoursite.com/tags/SSD%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>One-stage基本介绍</title>
    <link href="http://yoursite.com/2019/08/20/One-stage%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D/"/>
    <id>http://yoursite.com/2019/08/20/One-stage基本介绍/</id>
    <published>2019-08-20T01:44:40.000Z</published>
    <updated>2019-08-20T09:25:33.086Z</updated>
    
    <content type="html"><![CDATA[<p>​    One-stage也是使用CNN卷积特征，直接回归物体的类别概率和位置坐标值（无region proposal），准确度低、速度相对于Two-stage快。</p><p>One-stage常见算法：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/%E7%9B%AE%E6%A0%8715.png" alt></p><p>One-stage核心组件：</p><p>CNN网络</p><p>CNN网络设计原则：从简到繁到简的卷积神经网    多尺度特征融合的网络    更轻量级的CNN网络</p><p>回归网络    </p><p><strong>One-stage和Two-stage的区别在于是否存在RPN网络。</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;​    One-stage也是使用CNN卷积特征，直接回归物体的类别概率和位置坐标值（无region proposal），准确度低、速度相对于Two-stage快。&lt;/p&gt;
&lt;p&gt;One-stage常见算法：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.gi
      
    
    </summary>
    
      <category term="目标检测" scheme="http://yoursite.com/categories/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/"/>
    
      <category term="One-stage" scheme="http://yoursite.com/categories/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/One-stage/"/>
    
      <category term="One-stage基本介绍" scheme="http://yoursite.com/categories/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/One-stage/One-stage%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D/"/>
    
    
      <category term="One-stage" scheme="http://yoursite.com/tags/One-stage/"/>
    
  </entry>
  
  <entry>
    <title>Two-stage基本介绍</title>
    <link href="http://yoursite.com/2019/08/18/Two-stage%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D/"/>
    <id>http://yoursite.com/2019/08/18/Two-stage基本介绍/</id>
    <published>2019-08-18T09:09:22.000Z</published>
    <updated>2019-08-22T02:23:46.976Z</updated>
    
    <content type="html"><![CDATA[<p>​    Two-stage相对于one-stage准确度高，但是速度相对one-stage慢。</p><p>Two-stage常见算法：RCNN、Fast RCNN、Faster RCNN、Faster RCNN变种。</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/%E7%9B%AE%E6%A0%8714.png" alt></p><p>Two-stage核心组件：</p><p><strong>CNN网络</strong></p><p> CNN网络设计原则：</p><p>从简到繁再到简的卷积神经网</p><p>多尺度特征融合的网络</p><p>更轻量级的CNN网络</p><p><strong>RPN网络</strong></p><p>区域推荐（Anchor机制）：首先我们需要知道anchor的本质是什么，本质是SPP(spatial pyramid pooling)思想的逆向。而SPP本身是做什么的呢，就是将不同尺寸的输入resize成为相同尺寸的输出。所以SPP的逆向就是，将相同尺寸的输出，倒推得到不同尺寸的输入。当前的feature map的大小是n*c*w*h（n是张数，c是层数，w是宽，h是高），对于当前这个feature map上，也就是w<em>h上，选择其中的每一个点作为锚点（也就是候选区域的中心点），我们以每一个点作为中心点去提取候选区域。这样的每一个点都是Anchor。而这个候选区域通常都有比例：对于Fast  R-CNN三个面积尺寸（128^2，256^2，512^2），然后在每个面积尺寸下，取三种不同的长宽比例（1:1,1:2,2:1）。一个feature map可以提取w\</em>h*9个候选区域。我们示意图如下：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/%E7%9B%AE%E6%A0%8716.png" alt></p><p>ROI Pooling</p><p>分类和回归</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;​    Two-stage相对于one-stage准确度高，但是速度相对one-stage慢。&lt;/p&gt;
&lt;p&gt;Two-stage常见算法：RCNN、Fast RCNN、Faster RCNN、Faster RCNN变种。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://
      
    
    </summary>
    
      <category term="目标检测" scheme="http://yoursite.com/categories/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/"/>
    
      <category term="Two-stage算法" scheme="http://yoursite.com/categories/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/Two-stage%E7%AE%97%E6%B3%95/"/>
    
      <category term="Two-stage基本介绍" scheme="http://yoursite.com/categories/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/Two-stage%E7%AE%97%E6%B3%95/Two-stage%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D/"/>
    
    
      <category term="Two-stage" scheme="http://yoursite.com/tags/Two-stage/"/>
    
  </entry>
  
  <entry>
    <title>NMS算法</title>
    <link href="http://yoursite.com/2019/08/18/NMS%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2019/08/18/NMS算法/</id>
    <published>2019-08-18T08:33:12.000Z</published>
    <updated>2019-08-18T08:48:18.449Z</updated>
    
    <content type="html"><![CDATA[<p>​    NMS全称是非极大值抑制算法。</p><p>目的：为了消除多余的框，找到最佳的物体检测的位置。</p><p>思想:选取那些邻域里分数最高的窗口，同时抑制那些分数低的窗口。</p><p>其实NMS的处理不太合理。所以有人提出了Soft-NMS。</p><p>NMS和Soft-NMS的区别：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/%E7%9B%AE%E6%A0%8713.png" alt></p><p>相邻区域内的检测框的分数进行调整而非彻底抑制，从而提高了高检索率情况下的准确率。再低检索率时仍能对物体检测性能有明显提升。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;​    NMS全称是非极大值抑制算法。&lt;/p&gt;
&lt;p&gt;目的：为了消除多余的框，找到最佳的物体检测的位置。&lt;/p&gt;
&lt;p&gt;思想:选取那些邻域里分数最高的窗口，同时抑制那些分数低的窗口。&lt;/p&gt;
&lt;p&gt;其实NMS的处理不太合理。所以有人提出了Soft-NMS。&lt;/p&gt;
&lt;p&gt;
      
    
    </summary>
    
      <category term="目标检测" scheme="http://yoursite.com/categories/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/"/>
    
      <category term="NMS算法" scheme="http://yoursite.com/categories/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/NMS%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="目标检测算法" scheme="http://yoursite.com/tags/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>DPM算法</title>
    <link href="http://yoursite.com/2019/08/18/DPM%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2019/08/18/DPM算法/</id>
    <published>2019-08-18T07:52:34.000Z</published>
    <updated>2019-08-18T08:32:48.720Z</updated>
    
    <content type="html"><![CDATA[<p>​    DPM算法是传统目标检测方法的巅峰。</p><p>步骤：</p><p>1、计算DPM特征图</p><p>2、计算响应图</p><p>3、Latent SVM分类器训练</p><p>4、检测识别</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;​    DPM算法是传统目标检测方法的巅峰。&lt;/p&gt;
&lt;p&gt;步骤：&lt;/p&gt;
&lt;p&gt;1、计算DPM特征图&lt;/p&gt;
&lt;p&gt;2、计算响应图&lt;/p&gt;
&lt;p&gt;3、Latent SVM分类器训练&lt;/p&gt;
&lt;p&gt;4、检测识别&lt;/p&gt;

      
    
    </summary>
    
      <category term="目标检测" scheme="http://yoursite.com/categories/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/"/>
    
      <category term="传统目标检测" scheme="http://yoursite.com/categories/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/%E4%BC%A0%E7%BB%9F%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/"/>
    
      <category term="DPM算法" scheme="http://yoursite.com/categories/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/%E4%BC%A0%E7%BB%9F%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/DPM%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="传统目标检测" scheme="http://yoursite.com/tags/%E4%BC%A0%E7%BB%9F%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/"/>
    
  </entry>
  
  <entry>
    <title>HOG+SVM算法</title>
    <link href="http://yoursite.com/2019/08/18/HOG-SVM%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2019/08/18/HOG-SVM算法/</id>
    <published>2019-08-18T07:36:23.000Z</published>
    <updated>2019-08-18T07:51:56.371Z</updated>
    
    <content type="html"><![CDATA[<p>HOG+SVM算法主要用于行人检测。</p><p>步骤：</p><p>1、提取HOG特征。<strong>如果彩色图需要用HOG特征，则需要先转化为灰度图。</strong></p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/%E7%9B%AE%E6%A0%8711.png" alt></p><p>2、训练SVM分类器</p><p>３、利用滑动窗口提取目标区域，进行分类判断</p><p>4、NMS</p><p>5、输出检测结果</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;HOG+SVM算法主要用于行人检测。&lt;/p&gt;
&lt;p&gt;步骤：&lt;/p&gt;
&lt;p&gt;1、提取HOG特征。&lt;strong&gt;如果彩色图需要用HOG特征，则需要先转化为灰度图。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.
      
    
    </summary>
    
      <category term="目标检测" scheme="http://yoursite.com/categories/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/"/>
    
      <category term="传统目标检测算法" scheme="http://yoursite.com/categories/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/%E4%BC%A0%E7%BB%9F%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E7%AE%97%E6%B3%95/"/>
    
      <category term="HOG+SVM" scheme="http://yoursite.com/categories/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/%E4%BC%A0%E7%BB%9F%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E7%AE%97%E6%B3%95/HOG-SVM/"/>
    
    
      <category term="传统目标检测算法" scheme="http://yoursite.com/tags/%E4%BC%A0%E7%BB%9F%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>VJ算法</title>
    <link href="http://yoursite.com/2019/08/18/VJ%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2019/08/18/VJ算法/</id>
    <published>2019-08-18T07:22:05.000Z</published>
    <updated>2019-08-18T07:36:01.927Z</updated>
    
    <content type="html"><![CDATA[<p>​    VJ算法全称为Viola—Jones，多用于人脸检测。</p><p>步骤：</p><p>1、Haar特征抽取 </p><p>Haar特征分为三类：边缘特征、线性特征、中心特征和对角线特征，组合成特征模板。特征模板内有白色和黑色两种矩形，并定义该模板的特征值为白色矩形像素和减去黑色矩形像素和。Haar特征值反映了图像的灰度变化情况。例如：脸部的一些特征能由矩形特征简单的描述，如：眼睛要比脸颊颜色要深，鼻梁两侧比鼻梁颜色要深，嘴巴比周围颜色要深等。</p><p>2、训练人脸分类器（Adaboost算法等）</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/%E7%9B%AE%E6%A0%879.png" alt></p><p>3、滑动窗口</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;​    VJ算法全称为Viola—Jones，多用于人脸检测。&lt;/p&gt;
&lt;p&gt;步骤：&lt;/p&gt;
&lt;p&gt;1、Haar特征抽取 &lt;/p&gt;
&lt;p&gt;Haar特征分为三类：边缘特征、线性特征、中心特征和对角线特征，组合成特征模板。特征模板内有白色和黑色两种矩形，并定义该模板的特征值为
      
    
    </summary>
    
      <category term="目标检测" scheme="http://yoursite.com/categories/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/"/>
    
      <category term="传统目标检测算法" scheme="http://yoursite.com/categories/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/%E4%BC%A0%E7%BB%9F%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E7%AE%97%E6%B3%95/"/>
    
      <category term="VJ算法" scheme="http://yoursite.com/categories/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/%E4%BC%A0%E7%BB%9F%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E7%AE%97%E6%B3%95/VJ%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="传统目标检测算法" scheme="http://yoursite.com/tags/%E4%BC%A0%E7%BB%9F%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>mysql基础命令</title>
    <link href="http://yoursite.com/2019/08/13/mysql%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/"/>
    <id>http://yoursite.com/2019/08/13/mysql基础命令/</id>
    <published>2019-08-13T01:39:02.000Z</published>
    <updated>2019-08-13T02:19:28.350Z</updated>
    
    <content type="html"><![CDATA[<p>sql语句最后需要以；号结尾，sql语句最后需要以；号结尾，sql语句最后需要以；号结尾。重要的事说三遍。</p><h2 id="数据库操作"><a href="#数据库操作" class="headerlink" title="数据库操作"></a>数据库操作</h2><p>select version()：显示数据库版本</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/mysql34.png" alt></p><p>select now()：显示时间</p><p>show databases：查看所有数据库</p><p>show create database 数据库名：查看创建数据库的语句</p><p>create database 数据库名字：创建数据库</p><p>create database 数据库名字 charset=utf8：创建指定编码格式的数据库</p><p>drop database 数据库名：删除数据库</p><p>use 数据库名：使用数据库</p><p>select database ()：查看当前使用的数据库</p><h2 id="数据表操作"><a href="#数据表操作" class="headerlink" title="数据表操作"></a>数据表操作</h2><p>show tables:查看当前数据库中所有表</p><p>drop table 表名：删除表</p><p>show create table 表名：查看创建表的语句</p><p>create table 表名（字段 类型 约束[，字段 类型 约束]）：创建表</p><p>参数：auto_increment表示自动增长、not null表示不能为空、primary key表示主键、default 默认值</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/mysql35.png" alt></p><p>desc 表名：查看表的状态</p><p>insert into 表名 values()：向表插入数据，按照参数类型写参数</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/mysql33.png" alt></p><p>select * from 表名：查看表中所有的数据</p><p>alter table 表名 add 列名 类型：向表中添加字段</p><p>alter table 表名 modify 列名 类型 约束：不重命列名版</p><p>alter table 表名 change 列的原名 列的新名 类型 约束 ：重命列名版</p><p>alter table 表名 drop 列名：删除字段</p><h2 id="数据的增删改查"><a href="#数据的增删改查" class="headerlink" title="数据的增删改查"></a>数据的增删改查</h2><h3 id="增加"><a href="#增加" class="headerlink" title="增加"></a>增加</h3><p>全列插入：insert into 表名 values(数据)</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/mysql33.png" alt></p><p>主键字段：可以用0 null default 来占位。因为auto_increment是自动增加的</p><p>部分插入：insert into 表名(列名1) values(值1) 没有的值取默认值</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/mysql1.png" alt></p><p>多行插入：insert into 表名 values (数据1)，(数据2)</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/mysql2.png" alt></p><p>update 表名 set 列名 ：整列都改</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/mysql3.png" alt></p><p>update 表名 set  列名  where 条件：根据条件改</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/mysql5.png" alt></p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/mysql6.png" alt></p><p>通过其他表来更新一个表：</p><p>update 其他表 as 新名 inner join 被更新的表 as 新名 on  条件 set 需要改的数据</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/mysql7.png" alt></p><h3 id="查询："><a href="#查询：" class="headerlink" title="查询："></a>查询：</h3><p>select * from 表名：查询整个表，*号代表全部</p><p>select * from 表名 where ：根据条件查询</p><p>select 查询的列名 from 表名：根据列名查询。查询多列时，列名间用,隔开</p><p>select 查询的列名 as 列的新名字 from 表名：将列查询后以新的名字显示出来</p><p>select 表名.列名 from 表名</p><p>select 表的新名字.列名 from 表名 as 表的新名字</p><p>select distinct 列名 from 表名：可以去重，只显示相同数据第一次数据出现的位置</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/mysql8.png" alt></p><h4 id="条件查询："><a href="#条件查询：" class="headerlink" title="条件查询："></a>条件查询：</h4><p>and、or、not都可以用，类似python的语法。判断是否为空，is NULL。</p><h4 id="模糊查询："><a href="#模糊查询：" class="headerlink" title="模糊查询："></a>模糊查询：</h4><p>like ：%代表一个或多个，_代表一个。</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/mysql9.png" alt></p><p>select name from 表名 where name like “%小%”：查询名字中有”小”字的名字</p><p>select name from 表名 where name like “__”：查询两个字的名字</p><p>select name from 表名 where name like “__%”：查询两个字以上的名字</p><h4 id="rlike：利用正则查询"><a href="#rlike：利用正则查询" class="headerlink" title="rlike：利用正则查询"></a>rlike：利用正则查询</h4><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/mysql10.png" alt></p><h4 id="范围查询："><a href="#范围查询：" class="headerlink" title="范围查询："></a>范围查询：</h4><p>in表示在一个非连续的范围内</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/mysql11.png" alt></p><p>between 数字 and 数字表示在一个连续的范围内</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/mysql12.png" alt></p><h3 id="排序：order-by-默认从小到大排序"><a href="#排序：order-by-默认从小到大排序" class="headerlink" title="排序：order by 默认从小到大排序"></a>排序：order by 默认从小到大排序</h3><p>asc：从小到大排</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/mysql13.png" alt></p><p>desc：从大到小排</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/mysql14.png" alt></p><p>如果排序字段相同，我们可以设置多个排序字段。若不设置，默认按照主键大小排。</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/mysql15.png" alt></p><h3 id="聚合函数-count，max，min，avg，sum，round-：不能跟其他字段一起用"><a href="#聚合函数-count，max，min，avg，sum，round-：不能跟其他字段一起用" class="headerlink" title="聚合函数(count，max，min，avg，sum，round)：不能跟其他字段一起用"></a>聚合函数(count，max，min，avg，sum，round)：不能跟其他字段一起用</h3><p>count：计算个数，其他类似</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/mysql16.png" alt></p><p>max：计算最大的</p><p>min：计算最小的</p><p>avg：计算平均值</p><p>sum：求和</p><p>round：四舍五入 ，round(123.23,1)保留一位小数=123.2</p><h3 id="分组：group-by"><a href="#分组：group-by" class="headerlink" title="分组：group by"></a>分组：group by</h3><p>按照性别分组：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/mysql17.png" alt></p><p>配合聚合函数使用计算每种性别的人数：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/mysql18.png" alt></p><p>计算男性的人数：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/mysql19.png" alt></p><p>group_concat():查询同一组的其他字段</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/mysql20.png" alt></p><p>还可以用字符串分割</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/mysql21.png" alt></p><p>having：将达到条件的组输出，可以配合聚合函数一起使用</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/mysql22.png" alt></p><p><strong>having和where的区别：having是在分组后进行筛选，where是在原表的基础上进行筛选</strong></p><h3 id="分页："><a href="#分页：" class="headerlink" title="分页："></a>分页：</h3><p>limit start，count   限制查询出来的数据个数。start代表从哪开始，count 代表查询的数据个数。start默认为0</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/mysql23.png" alt></p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/mysql24.png" alt></p><h3 id="链接查询：内链接、左链接、右链接"><a href="#链接查询：内链接、左链接、右链接" class="headerlink" title="链接查询：内链接、左链接、右链接"></a>链接查询：内链接、左链接、右链接</h3><h4 id="内链接：inner-join-……on"><a href="#内链接：inner-join-……on" class="headerlink" title="内链接：inner join ……on"></a>内链接：inner join ……on</h4><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/mysql25.png" alt></p><p>在两个表中取交集，如果存在则将两表数据合并。不存在则跳过。</p><p>可以利用as化简语句：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/mysql26.png" alt></p><p>可以根据需求修改需要显示的数据：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/mysql27.png" alt></p><p>还可以修改数据显示的位置：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/mysql28.png" alt></p><p>通过某个表的字段排序：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/mysql29.png" alt></p><h4 id="左链接：left-join……on。谁在左边，谁就是左表。"><a href="#左链接：left-join……on。谁在左边，谁就是左表。" class="headerlink" title="左链接：left join……on。谁在左边，谁就是左表。"></a>左链接：left join……on。谁在左边，谁就是左表。</h4><p>查询的结果为两个表匹配到的数据，左表特有的数据，对于右表不存在的数据使用null填充</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/mysql30.png" alt></p><p>将左表特有的数据提取出来：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/mysql31.png" alt></p><h4 id="右链接：right-join……on：类似左表。可以直接将右链接的表中左表和右表的显示交换即可得右链接。"><a href="#右链接：right-join……on：类似左表。可以直接将右链接的表中左表和右表的显示交换即可得右链接。" class="headerlink" title="右链接：right join……on：类似左表。可以直接将右链接的表中左表和右表的显示交换即可得右链接。"></a>右链接：right join……on：类似左表。可以直接将右链接的表中左表和右表的显示交换即可得右链接。</h4><p>自关联：补。。。。</p><p>子查询：查询里嵌套一个查询</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/mysql32.png" alt></p><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><p>删除分为物理删除和逻辑删除：</p><p>物理删除：</p><p>delete from 表名:删除整个表</p><p>delete from 表名 where 条件：删除符合条件的数据</p><p>逻辑删除：（用一个字段表示，这条信息是否还能用）</p><p>alter table 表名 add 字段 类型 default 默认值</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;sql语句最后需要以；号结尾，sql语句最后需要以；号结尾，sql语句最后需要以；号结尾。重要的事说三遍。&lt;/p&gt;
&lt;h2 id=&quot;数据库操作&quot;&gt;&lt;a href=&quot;#数据库操作&quot; class=&quot;headerlink&quot; title=&quot;数据库操作&quot;&gt;&lt;/a&gt;数据库操作&lt;/h2&gt;
      
    
    </summary>
    
      <category term="数据库" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="mysql" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/"/>
    
      <category term="基础命令" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/"/>
    
    
      <category term="mysql" scheme="http://yoursite.com/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>网络知识散记</title>
    <link href="http://yoursite.com/2019/08/13/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E6%95%A3%E8%AE%B0/"/>
    <id>http://yoursite.com/2019/08/13/网络知识散记/</id>
    <published>2019-08-13T01:20:46.000Z</published>
    <updated>2019-08-13T01:28:13.242Z</updated>
    
    <content type="html"><![CDATA[<h2 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h2><p>端口是英文port的意译，可以认为是设备与外界通讯交流的出口。端口可分为虚拟端口和物理端口，其中虚拟端口指计算机内部或交换机路由器内的端口，不可见。例如计算机中的80端口、21端口、23端口等。物理端口又称为接口，是可见端口，计算机背板的RJ45网口，交换机路由器集线器等RJ45端口。电话使用RJ11插口也属于物理端口的范畴。（用来区分哪个进程）   同一台电脑用pid区分进程，不同电脑用端口区分进程。</p><p>端口范围是0到65535</p><p>知名端口是众所周知的端口，范围是0到1023</p><p>动态端口的范围是1024到65535</p><p>查看端口状态：用netstat -an查看</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/net1.png" alt></p><h2 id="TCP-IP协议"><a href="#TCP-IP协议" class="headerlink" title="TCP/IP协议"></a>TCP/IP协议</h2><p>TCP/IP:这不是两个协议，这是一个协议族，包含很多协议。主要是TCP/IP协议。</p><p>四层：物理层、网络层、传输层、应用层</p><p>七层：物理层、链路层、网络层、传输层、 会话层、表示层、应用层</p><h2 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h2><p>用来标记唯一一台电脑。每一个IP地址都包括网络地址和主机地址</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/net2.png" alt></p><p>网络地址相同，则处于同一个网段，主机地址用来标记网里的电脑</p><p>A类网络的IP地址范围为：1.0.0.1－126.255.255.254； </p><p>B类网络的IP地址范围为：128.1.0.1－191.255.255.254； </p><p>C类网络的IP地址范围为：192.0.1.1－223.255.255.254</p><p>1．A类IP地址</p><p>一个A类IP地址由1字节（每个字节是8位）的网络地址和3个字节主机地址组成,即第一段数字范围为1～126。每个A类地址可连接16387064台主机(不能用0(产生冲突)和255(广播地址)，Internet有126个A类地址。</p><p>2．B类IP地址</p><p>一个B类IP地址由2个字节的网络地址和2个字节的主机地址组成，第一段数字范围为128～191。每个B类地址可连接64516(254*254)台主机(不能用0(产生冲突)和255(广播地址))，Internet有16256个B类地址。</p><p>3．C类IP地址</p><p>一个C类地址是由3个字节的网络地址和1个字节的主机地址组成，第一段数字范围为192～223。每个C类地址可连接254台主机(不能用0(产生冲突)和255(广播地址)，Internet有2054512个C类地址。</p><p>4．D类地址用于多点播送。</p><p>第一个字节的数字范围为224～239，是多点播送地址，用于多目的地信息的传输，和作为备用。全零（“0.0.0.0”）地址对应于当前主机，全“1”的IP地址（“255.255.255.255”）是当前子网的广播地址。多播和广播的区别：广播在同一个局域网都能收到，多播是指定那些人可以收得到，其他人收不到，常用于视频会议。</p><p>5.E类地址</p><p>第一段数字范围为240～254。E类地址保留，仅作实验和开发用。</p><p>全零（“0．0．0．0”）地址对应于当前主机。全“1”的IP地址（“255．255．255．255”）是当前子网的广播地址。</p><p>在IP地址3种主要类型里，各保留了3个区域作为私有地址，常见于局域网中。</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/net3.png" alt></p><p>##常用术语</p><p>网络号：网络号等于ip地址和网络掩码按位与操作</p><p>网络掩码（子网掩码）的作用：取网络号、主机号</p><p>两台电脑能通信的前提是处于同一个网络号</p><p>集线器（hub）的作用：实现多台电脑连接在一起，组成一个小型局域网，交换机也是。</p><p>集线器和交换机的区别：集线器是广播发数据，交换机不是每次都是广播，效率高。</p><p>实际地址：代表网卡地址（MAC）。由六个字节组成，前三个字节代表厂商，后三个字节代表厂商生产</p><p>arp：根据ip找mac地址</p><p>rarp：根据mac地址找ip</p><p>icmp：ping的时候用</p><p>arp -a即是查看本地局域网内所有用户ip和mac地址绑定关系的一个命令。</p><p>ARP -d 就是清除缓存中的数据。也是删除ip和mac绑定的项目。</p><p>路由器：连接不同的网络，使他们之间能够通信</p><p>rip：路由解析协议</p><p>mac：标记实际转发数据时的地址</p><p>ip：标记逻辑上的地址</p><p>natmask：和ip地址一起确定网络号</p><p>默认网关：发送的ip不在同一个网段内，那么会把这个数据转发给默认网关。</p><p>为什么TCP比UDP稳定？在TCP中，如果有一方接收到对方的数据，一定会发送ack确认包给对方。而在UDP中，没有这个过程。</p><p>TCP三次握手：确定一定发送数据到对方    四次挥手：调用close时使用</p><p>TCP长连接、短连接：</p><p>TTL：表示经过的路由器数目。每经过一个路由器，TTL-1。</p><p>MSL：表示一个数据包存在的最多时间</p><p>CDN：内容分发</p><p>查看域名解析的IP地址：</p><p>nslookup 域名         例子：nslookup baidu.com</p><p>常见的网络攻击：</p><p>DDOS攻击：拒绝服务器攻击。</p><p>DNS攻击：1.DNS服务器被劫持：篡改IP</p><p>​                  2.DNS欺骗：</p><p>ARP攻击：中间人攻击</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;端口&quot;&gt;&lt;a href=&quot;#端口&quot; class=&quot;headerlink&quot; title=&quot;端口&quot;&gt;&lt;/a&gt;端口&lt;/h2&gt;&lt;p&gt;端口是英文port的意译，可以认为是设备与外界通讯交流的出口。端口可分为虚拟端口和物理端口，其中虚拟端口指计算机内部或交换机路由器内的端口，
      
    
    </summary>
    
      <category term="网络知识" scheme="http://yoursite.com/categories/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/"/>
    
      <category term="知识散记" scheme="http://yoursite.com/categories/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/%E7%9F%A5%E8%AF%86%E6%95%A3%E8%AE%B0/"/>
    
    
      <category term="网络知识散记" scheme="http://yoursite.com/tags/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E6%95%A3%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>目标检测概述</title>
    <link href="http://yoursite.com/2019/08/12/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E6%A6%82%E8%BF%B0/"/>
    <id>http://yoursite.com/2019/08/12/目标检测概述/</id>
    <published>2019-08-12T02:30:19.000Z</published>
    <updated>2019-08-18T07:20:44.266Z</updated>
    
    <content type="html"><![CDATA[<p>​    目标检测方法分为传统目标检测方法和深度学习目标检测方法。</p><p>传统目标检测方法：Viola-Jones、HOG+SVM、DPM等</p><p>Viola-Jones：采用积分图特征，进行人脸检测</p><p>HOG+SVM：行人检测。通过HOG特征结合SVM分类器进行检测。</p><p>DPM：同样通过HOG特征，并加入许多其他额外的策略进行检测。传统目标检测最好的方法。</p><p>深度学习目标检测方法：One-state、Two-stage</p><p>One-stage：YOLO和SSD系列，直接回归目标位置。</p><p>Two-stage：Faster RCNN系列，利用网络对候选区进行推荐。</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/%E7%9B%AE%E6%A0%871.png" alt></p><p>目标检测问题基本流程：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/%E7%9B%AE%E6%A0%8710.png" alt></p><p><strong>Viola-Jones（人脸检测）步骤</strong></p><p>1、Haar特征抽取</p><p>2、训练人脸分类器（Adaboost算法）</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/%E7%9B%AE%E6%A0%872.png" alt></p><p>3、滑动窗口</p><p><strong>HOG+SVM（行人检测）步骤</strong></p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/%E7%9B%AE%E6%A0%873.png" alt></p><p><strong>DPM（物体检测）步骤</strong></p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/%E7%9B%AE%E6%A0%874.png" alt></p><p>NMS（非极大值抑制算法）</p><p>目的：为了消除多余的框，找到最佳的物体检测的位置</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/%E7%9B%AE%E6%A0%87.png" alt></p><p>Soft-NMS是对NMS算法的改进</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/%E7%9B%AE%E6%A0%876.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;​    目标检测方法分为传统目标检测方法和深度学习目标检测方法。&lt;/p&gt;
&lt;p&gt;传统目标检测方法：Viola-Jones、HOG+SVM、DPM等&lt;/p&gt;
&lt;p&gt;Viola-Jones：采用积分图特征，进行人脸检测&lt;/p&gt;
&lt;p&gt;HOG+SVM：行人检测。通过HOG特征结
      
    
    </summary>
    
      <category term="目标检测" scheme="http://yoursite.com/categories/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/"/>
    
      <category term="目标检测概述" scheme="http://yoursite.com/categories/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E6%A6%82%E8%BF%B0/"/>
    
    
      <category term="目标检测" scheme="http://yoursite.com/tags/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/"/>
    
  </entry>
  
  <entry>
    <title>opencv颜色识别</title>
    <link href="http://yoursite.com/2019/08/12/opencv%E9%A2%9C%E8%89%B2%E8%AF%86%E5%88%AB/"/>
    <id>http://yoursite.com/2019/08/12/opencv颜色识别/</id>
    <published>2019-08-12T01:18:09.000Z</published>
    <updated>2019-08-18T01:08:11.659Z</updated>
    
    <content type="html"><![CDATA[<p>   数字图像处理中常用的采用模型是RGB（红，绿，蓝）模型和HSV（色调，饱和度，亮度），RGB广泛应用于彩色监视器和彩色视频摄像机，我们平时的图片一般都是RGB模型。而HSV模型更符合人描述和解释颜色的方式，HSV的彩色描述对人来说是自然且非常直观的。</p><p>这里的颜色识别是指根据人们的意愿提取图片中对应的颜色区域。</p><p>颜色识别步骤：</p><p>1、读取一张图片或视频.</p><p>2、用cvtcolor将它从RGB转为HSV。</p><p>3、通过inrange得出掩膜。</p><p>4、用 图像的”与”操作(bitwise_and)得出对应区域的图像。</p><p>coding：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/color.png" alt></p><p>读者可以加一些其他的操作提高效果，例如什么开运算、滤波之类的。这里就不赘述了，接下来，贴一张HSV的颜色阈值表，可以参考：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/color2.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;   数字图像处理中常用的采用模型是RGB（红，绿，蓝）模型和HSV（色调，饱和度，亮度），RGB广泛应用于彩色监视器和彩色视频摄像机，我们平时的图片一般都是RGB模型。而HSV模型更符合人描述和解释颜色的方式，HSV的彩色描述对人来说是自然且非常直观的。&lt;/p&gt;
&lt;p&gt;这
      
    
    </summary>
    
      <category term="python" scheme="http://yoursite.com/categories/python/"/>
    
      <category term="opencv" scheme="http://yoursite.com/categories/python/opencv/"/>
    
      <category term="颜色识别" scheme="http://yoursite.com/categories/python/opencv/%E9%A2%9C%E8%89%B2%E8%AF%86%E5%88%AB/"/>
    
    
      <category term="颜色识别" scheme="http://yoursite.com/tags/%E9%A2%9C%E8%89%B2%E8%AF%86%E5%88%AB/"/>
    
  </entry>
  
  <entry>
    <title>魔法方法</title>
    <link href="http://yoursite.com/2019/08/10/%E9%AD%94%E6%B3%95%E6%96%B9%E6%B3%95/"/>
    <id>http://yoursite.com/2019/08/10/魔法方法/</id>
    <published>2019-08-10T01:34:31.000Z</published>
    <updated>2019-08-10T02:12:25.513Z</updated>
    
    <content type="html"><![CDATA[<p>​    魔法方法是指Python内部已经包含的，被双下划线所包围的方法，这些方法在进行特定的操作时会自动被调用。使用Python的魔法方法可以是Python的自由度变得更高，当不需要重写魔法方法也可以在规定的默认情况下生效。在需要重写时也可以让使用者根据自己的需求来重写部分方法来达到自己的期待。</p><h2 id="常用的魔法方法："><a href="#常用的魔法方法：" class="headerlink" title="常用的魔法方法："></a>常用的魔法方法：</h2><p>__doc__：表示类的描述信息</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/magic1.png" alt></p><p>__module__:表示当前操作的对象在哪个模块</p><p>__class__:表示当前操作的对象的类是什么</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/magic2.png" alt></p><p>__call__：让对象直接调用call方法</p><p>__dict__：类或对象的所有属性</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/magic3.png" alt></p><p>__getitem__、__setitem__、__delitem__：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/magic4.png" alt></p><h2 id="魔法方法集合"><a href="#魔法方法集合" class="headerlink" title="魔法方法集合"></a>魔法方法集合</h2><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/magic5.png" alt></p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/magic6.png" alt></p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/magic7.png" alt></p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/magic8.png" alt></p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/magic9.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;​    魔法方法是指Python内部已经包含的，被双下划线所包围的方法，这些方法在进行特定的操作时会自动被调用。使用Python的魔法方法可以是Python的自由度变得更高，当不需要重写魔法方法也可以在规定的默认情况下生效。在需要重写时也可以让使用者根据自己的需求来重写部
      
    
    </summary>
    
      <category term="python" scheme="http://yoursite.com/categories/python/"/>
    
      <category term="魔法方法" scheme="http://yoursite.com/categories/python/%E9%AD%94%E6%B3%95%E6%96%B9%E6%B3%95/"/>
    
    
      <category term="魔法方法" scheme="http://yoursite.com/tags/%E9%AD%94%E6%B3%95%E6%96%B9%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>深度学习（3）</title>
    <link href="http://yoursite.com/2019/08/09/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%EF%BC%883%EF%BC%89/"/>
    <id>http://yoursite.com/2019/08/09/深度学习（3）/</id>
    <published>2019-08-09T05:03:29.000Z</published>
    <updated>2019-09-03T13:39:49.221Z</updated>
    
    <content type="html"><![CDATA[<p>​    感知机：有n个输入数据，通过权重与各数据之间的计算和，比较激活函数结果，得出输出。感知机是解决分类问题。</p><p>神经网络的基本组成包括输入层、隐藏层、输出层。卷积神经网络的特点在于隐藏层分为卷积层和池化层。</p><p>神经网络的种类：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/DL30.png" alt></p><p>神经网络的策略是交叉熵损失，优化是通过反向传播算法（相当于梯度下降 ）。</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/DL31.png" alt></p><p>简单神经网络：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/DL32.png" alt></p><p>卷积神经网络：</p><p>卷积层：通过在原始图像上平移来提取特征</p><p>零填充方式：SAME和VALID。</p><p>当填充方式为SAME时：全零填充，无法取整时，向上取值</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/DL33.png" alt></p><p>当填充方式为VALID时，不使用全零填充，无法取整时，向上取值</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/DL34.png" alt></p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/DL35.png" alt></p><p>卷积向下取整，池化向上取整</p><p>例：当卷积层100个filter，5*5，步长为1，零填充是2时。输入[28,28,1]大小的图像，输出[26,26,100]的图像。</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/DL36.png" alt></p><p>池化层：通过特征后稀疏参数来减少学习的参数，降低网络的复杂度（最大池化和平均值化）</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/DL37.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;​    感知机：有n个输入数据，通过权重与各数据之间的计算和，比较激活函数结果，得出输出。感知机是解决分类问题。&lt;/p&gt;
&lt;p&gt;神经网络的基本组成包括输入层、隐藏层、输出层。卷积神经网络的特点在于隐藏层分为卷积层和池化层。&lt;/p&gt;
&lt;p&gt;神经网络的种类：&lt;/p&gt;
&lt;p&gt;&lt;
      
    
    </summary>
    
      <category term="深度学习" scheme="http://yoursite.com/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="深度学习（3）" scheme="http://yoursite.com/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%EF%BC%883%EF%BC%89/"/>
    
    
      <category term="深度学习" scheme="http://yoursite.com/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>深度学习（2）</title>
    <link href="http://yoursite.com/2019/08/09/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%EF%BC%882%EF%BC%89/"/>
    <id>http://yoursite.com/2019/08/09/深度学习（2）/</id>
    <published>2019-08-09T04:53:25.000Z</published>
    <updated>2019-09-03T13:39:02.321Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数据读取"><a href="#数据读取" class="headerlink" title="数据读取"></a>数据读取</h2><p>通过线程和队列提高速度。可以边取数据边训练</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/DL19.png" alt></p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/DL20.png" alt></p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/DL@1.png" alt></p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/DL21.png" alt></p><h2 id="模型的保存和加载"><a href="#模型的保存和加载" class="headerlink" title="模型的保存和加载"></a>模型的保存和加载</h2><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/DL22.png" alt></p><p>模型保存：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/DL23.png" alt></p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/DL24.png" alt></p><p>模型加载：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/DL25.png" alt></p><h2 id="添加权重参数、损失值等的变化"><a href="#添加权重参数、损失值等的变化" class="headerlink" title="添加权重参数、损失值等的变化"></a>添加权重参数、损失值等的变化</h2><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/DL26.png" alt></p><p>首先收集变量：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/DL27.png" alt></p><p>而后在会话中运行：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/DL28.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;数据读取&quot;&gt;&lt;a href=&quot;#数据读取&quot; class=&quot;headerlink&quot; title=&quot;数据读取&quot;&gt;&lt;/a&gt;数据读取&lt;/h2&gt;&lt;p&gt;通过线程和队列提高速度。可以边取数据边训练&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubuserc
      
    
    </summary>
    
      <category term="深度学习" scheme="http://yoursite.com/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="深度学习（2）" scheme="http://yoursite.com/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%EF%BC%882%EF%BC%89/"/>
    
    
      <category term="深度学习" scheme="http://yoursite.com/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
</feed>
