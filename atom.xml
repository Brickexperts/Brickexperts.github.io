<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>DY的个人博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-08-28T07:09:55.945Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>湛蓝星空</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>人脸检测数据集构造</title>
    <link href="http://yoursite.com/2019/08/28/%E4%BA%BA%E8%84%B8%E6%A3%80%E6%B5%8B%E6%95%B0%E6%8D%AE%E9%9B%86%E6%9E%84%E9%80%A0/"/>
    <id>http://yoursite.com/2019/08/28/人脸检测数据集构造/</id>
    <published>2019-08-28T07:08:15.000Z</published>
    <updated>2019-08-28T07:09:55.945Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="目标检测" scheme="http://yoursite.com/categories/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/"/>
    
      <category term="one—stage" scheme="http://yoursite.com/categories/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/one%E2%80%94stage/"/>
    
      <category term="SSD" scheme="http://yoursite.com/categories/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/one%E2%80%94stage/SSD/"/>
    
      <category term="SSD实战" scheme="http://yoursite.com/categories/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/one%E2%80%94stage/SSD/SSD%E5%AE%9E%E6%88%98/"/>
    
      <category term="构造数据集" scheme="http://yoursite.com/categories/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/one%E2%80%94stage/SSD/SSD%E5%AE%9E%E6%88%98/%E6%9E%84%E9%80%A0%E6%95%B0%E6%8D%AE%E9%9B%86/"/>
    
    
      <category term="SSD算法" scheme="http://yoursite.com/tags/SSD%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>SSD实战-人脸检测</title>
    <link href="http://yoursite.com/2019/08/28/SSD%E5%AE%9E%E6%88%98-%E4%BA%BA%E8%84%B8%E6%A3%80%E6%B5%8B/"/>
    <id>http://yoursite.com/2019/08/28/SSD实战-人脸检测/</id>
    <published>2019-08-28T01:51:26.000Z</published>
    <updated>2019-08-28T07:07:05.868Z</updated>
    
    <content type="html"><![CDATA[<p>人脸标注方法：矩形标注和椭圆形标注</p><p>矩形标注都是用一个矩形框将画面中的人脸区域包含在内，这种标记方法很难给出一个恰好包含面部的矩形框。而人脸天然呈现椭圆形，椭圆形标注是一种较为准确的方法。椭圆形标注返回值包括：椭圆的长轴半径、椭圆的短轴半径、椭圆长轴偏转角度、椭圆圆心x坐标、椭圆圆心y坐标。</p><p>判断算法性能好坏：</p><p>每一个标记只允许有一个检测与之相对应，也就是说，我们检测出来的每一个人脸图像只能同我们在标注中人脸图像中数据中的一个相对应。如果有多个，就会视为重复检测。重复检测会被视为错误检测。接着我们就可以得出正确率和错误率，可以画出ROC曲线和PR曲线。可以根据曲线看出算法的好坏。</p><p>WIDERFace数据集：打开<a href="http://mmlab.ie.cuhk.edu.hk/project/WIDERFace" target="_blank" rel="noopener">人脸检测数据集地址</a>下载数据集。</p><p>人脸采集常用方法：</p><p><strong>活体检测</strong>  判断用户是否为正常操作，通过指定用户做随机动作，一搬有张嘴、摇头、点头、凝视、眨眼等等，防止照片攻击。判断用户是否真实在操作，指定用户上下移动手机，防止视频攻击和非正常动作的攻击。</p><p><strong>3D检测</strong>  验证采集到的是否为立体人像，能够防止平面照片、不同弯曲程度的照片等。</p><p><strong>连续检测</strong>  通过连续的检测，验证运动轨迹是否正常，防止跳过活体检测直接替换采集的照片，也能防止中途换人。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;人脸标注方法：矩形标注和椭圆形标注&lt;/p&gt;
&lt;p&gt;矩形标注都是用一个矩形框将画面中的人脸区域包含在内，这种标记方法很难给出一个恰好包含面部的矩形框。而人脸天然呈现椭圆形，椭圆形标注是一种较为准确的方法。椭圆形标注返回值包括：椭圆的长轴半径、椭圆的短轴半径、椭圆长轴偏转角度、
      
    
    </summary>
    
      <category term="目标检测" scheme="http://yoursite.com/categories/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/"/>
    
      <category term="one-stage" scheme="http://yoursite.com/categories/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/one-stage/"/>
    
      <category term="SSD" scheme="http://yoursite.com/categories/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/one-stage/SSD/"/>
    
      <category term="SSD实战" scheme="http://yoursite.com/categories/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/one-stage/SSD/SSD%E5%AE%9E%E6%88%98/"/>
    
      <category term="人脸检测综述" scheme="http://yoursite.com/categories/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/one-stage/SSD/SSD%E5%AE%9E%E6%88%98/%E4%BA%BA%E8%84%B8%E6%A3%80%E6%B5%8B%E7%BB%BC%E8%BF%B0/"/>
    
    
      <category term="SSD算法" scheme="http://yoursite.com/tags/SSD%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>目标检测常用名词</title>
    <link href="http://yoursite.com/2019/08/22/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E5%B8%B8%E7%94%A8%E5%90%8D%E8%AF%8D/"/>
    <id>http://yoursite.com/2019/08/22/目标检测常用名词/</id>
    <published>2019-08-22T01:49:17.000Z</published>
    <updated>2019-08-24T03:26:29.629Z</updated>
    
    <content type="html"><![CDATA[<p>图像分类：一张图像中是否包含某种物体</p><p>物体检测识别：若细分该任务可得到两个子任务，即目标检测，与目标识别，首先检测是视觉感知得第一步，它尽可能搜索出图像中某一块存在目标（形状、位置）。而目标识别类似于图像分类，用于判决当前找到得图像块得目标具体是什么类别。</p><p>语义分割：按对象得内容进行图像得分割，分割的依据是内容，即对象类别。</p><p>实例分割：按对象个体进行分割，分割的依据是单个目标。</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/%E7%9B%AE%E6%A0%8717.png" alt></p><p><strong>滑动窗口</strong>——为什么要有候选区域？既然目标是在图像中的某一区域，那么最直接的方法就是滑窗法（sliding window approach），就是遍历图像的所有区域，用不同大小的窗口在整个图像上滑动，那么就会产生所有的矩形区域，然后再后续排查，思路很简单，但是开销巨大。</p><p>region proposal（RP）：候选区域</p><p>IOU：region proposal与Ground Truth的窗口的交集比并集的比值，相当于准确率。‘</p><p>SPP：Spatial Pyramid Pooling  空间金字塔采样  在pooing的过程中计算pooling后的结果对应的两个像素点映射到feature map上所占的范围，然后在那个范围中进行max或者average。</p><p>ROI Pooling：就是将一个个大小不同的box矩形框，都映射到大小为w*h的矩形框。</p><p>Anchor：请看<a href="[https://brickexperts.github.io/2019/08/18/Two-stage%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D/#more](https://brickexperts.github.io/2019/08/18/Two-stage基本介绍/#more)">Two-stage基本介绍</a></p><p>GT box:Ground Truth box</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/%E7%9B%AE%E6%A0%8722.png" alt></p><p>如上图所示，绿色的框为飞机的Ground Truth，红色的框是提取的Region Proposal。那么即便红色的框被分类器识别为飞机，但是由于红色的框定位不准(IoU&lt;0.5)，那么这张图相当于没有正确的检测出飞机。如果我们能对红色的框进行微调，使得经过微调后的窗口跟Ground Truth更接近，这样岂不是定位会更准确。</p><p>后面遇见会继续完善。。。。。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;图像分类：一张图像中是否包含某种物体&lt;/p&gt;
&lt;p&gt;物体检测识别：若细分该任务可得到两个子任务，即目标检测，与目标识别，首先检测是视觉感知得第一步，它尽可能搜索出图像中某一块存在目标（形状、位置）。而目标识别类似于图像分类，用于判决当前找到得图像块得目标具体是什么类别。&lt;/
      
    
    </summary>
    
      <category term="目标检测" scheme="http://yoursite.com/categories/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/"/>
    
      <category term="常用名词解释" scheme="http://yoursite.com/categories/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/%E5%B8%B8%E7%94%A8%E5%90%8D%E8%AF%8D%E8%A7%A3%E9%87%8A/"/>
    
    
      <category term="目标检测" scheme="http://yoursite.com/tags/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/"/>
    
  </entry>
  
  <entry>
    <title>SSD系列算法</title>
    <link href="http://yoursite.com/2019/08/21/SSD%E7%B3%BB%E5%88%97%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2019/08/21/SSD系列算法/</id>
    <published>2019-08-21T01:05:48.000Z</published>
    <updated>2019-08-28T01:53:22.710Z</updated>
    
    <content type="html"><![CDATA[<p>SDD的网络架构：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/%E7%9B%AE%E6%A0%8718.png" alt></p><p>SSD以VGG16作为基础网络，并且在VGG上新增加了conv6、conv7、conv8、conv9、conv10、conv11这五层卷积层来获得更多的feature map。</p><h2 id="主干网络介绍"><a href="#主干网络介绍" class="headerlink" title="主干网络介绍"></a>主干网络介绍</h2><p>主干网络原始作者采用的VGG，我们也可以将其他神经网络作为主干网络。例如：ResNet、MobileNets等</p><p>将VGG网络最后两个FC层改成卷积，并增加4个卷积层。因为完整的VGG通常是用来处理分类任务的，对于分类任务而言，我们在最终输出的时候会采用FC层将最终的feature map来映射到向量。向量对应当前需要分类的物体在不同类别上的概率分布。而目标检测不需要分类，所以我们将全连接层去掉。</p><h2 id="多尺度feature-map预测"><a href="#多尺度feature-map预测" class="headerlink" title="多尺度feature map预测"></a>多尺度feature map预测</h2><p>多尺度feature map预测，也就是在预测的时候，在接下来预测的时候，针对接下来六个不同的尺寸进行预测。如下图的六条连线，分别是38*38、19*19、10*10、5*5、3*3、1*1。将这六个不同尺度的feature map分别作为检测、预测层的输入，最后通过NMS进行筛选和合并。</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/%E7%9B%AE%E6%A0%8720.png" alt></p><p>对于六种不同尺度的网络，我们通常使用pooling来降采样。对于每一层的feature map，我们输入到相应的预测网络中。而预测网络中，我们会包括Prior box的提取过程。Prior box对应Fast R-CNN中Anchor的概念，也就是说，在Prior box中，feature map上的每一个点都作为一个cell（相当于Anchor）。以这个cell为中心，按照等比的放缩，找到它在原始图片的位置。接着以这个点为中心，提取不同尺度bounding box。而这些不同尺度的bounding box就是Prior box。然后对于每一个Prior box，我们通过和真值比较，就能够拿到它的label。对于每一个Prior box，我们都会分别预测它的类别概率和坐标（x，y，w，h）。也就是说，对于每一个cell，我们会将它对应到不同的Prior box，分别来预测当前这个Prior box所对应当前这个类别的概率分布和坐标。</p><p><strong>对Prior Box的具体定义：</strong></p><p>这里我们假设Prior Box的输入是m*n维的feature map。</p><p>如果每一个点都作为cell，那就会有m<em>n个cell。接着每个cell上生成固定尺寸和不同长宽比例的box。每个cell对应k个bounging box，每个bounding box预测c个类别分数和4个偏移坐标。其中c个类别分数实际上是当前bounding box所对应的不同类别的概率分布。如果输入大小为m\</em>n，那就会输出(c+4)*k*m*n。其中尺寸(scale)和比例(ratio)是超参数。</p><p>接下来我们看看Prior box是怎么生成的：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/%E7%9B%AE%E6%A0%8721.png" alt></p><p>每个feature map上的点定义了六种长宽比的default box。也就是说，最后对于每一个anchor都会获得六个不同尺寸和长宽比的default box。对于38<em>38层，每个feature map上的点，我们都会提取4个default box作为prior box。对于19\</em>19层、10*10层、5*5，提取6个default box也就是全部都是prior box。而3*3、1*1提取4个default作为prior box。所以最后得到8732个prior box(38*38*4+19*19*6+10*10*6+5*5*6+3*3*4+1*1*4)。<strong>prior box就是选择的default box</strong>。尺寸和比例都是可以通过SSD的配置文件进行配置，后面实战详解。</p><p>对default box进行筛选成为prior box：每一个feature map cell不是k个default box都取，prior box与GT box(<a href="https://brickexperts.github.io/" target="_blank" rel="noopener">Ground Truth box</a>)做匹配，IOU&gt;阈值为正样本。IOU&lt;阈值 为负样本。介于正样本和负样本中间阈值的default box去掉。</p><h2 id="SSD系列算法优化及扩展"><a href="#SSD系列算法优化及扩展" class="headerlink" title="SSD系列算法优化及扩展"></a>SSD系列算法优化及扩展</h2><p>SSD算法对小目标不够鲁棒，原因最主要是浅层feature map的表征能力不够强。</p><p>DSSD：</p><p>DSSD相当原来的SSD模型主要作了两大更新。一是替换掉VGG，而改用了Resnet-101作为特征提取网络并在对不同尺度feature maps特征进行default boxes检测时使用了更新的检测单元；二则在网络的后端使用了多个deconvolution layers以有效地扩展低维度信息的contextual information，从而有效地提高了小尺度目标的检测。</p><p>下图为DSSD模型与SSD模型的整体网络结构对比：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/SSD4.png" alt></p><p>DSOD：</p><p>SSD+DenseNet=DSOD</p><p>DSOD可以从0开始训练数据，不需要预训练模型。</p><p>FSSD：</p><p>借鉴了FPN的思想，重构了一组pyramid feature map（金字塔特征），使得算法的精度有了明显特征，速度也没有下降很多。具体是把网络中某些feature调整为同一size再contact（连接），得到一个像素层，以此层为base layer来生成pyramid feature map，作者称之为Feature Fusion Module。</p><p>Feature Fusion</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/SSD2.png" alt></p><p>对上面图的解读：</p><p>​    (a) image pyramid </p><p>​    (b) rcnn系列，只在最后一层feature预测 </p><p>​    (c) FPN，语义信息一层传递回去，而且有很多相加的计算 </p><p>​    (d) SSD，在各个level的feature上直接预测，每个level之间没联系 </p><p>​    (e) FSSD的做法，把各个level的feature concat，然后从fusion feature上生成feature pyramid</p><p>FSSD网络结构：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/SSD3.png" alt></p><p>RSSD：</p><p>rainbow concatenation方式(pooling加deconvolution)融合不同层的特征，再增加不同层之间feature map关系的同时也增加了不同层的feature map个数。这种融合方式不仅解决了传统SSD算法存在的重复框问题，同时一定程度上解决了small object的检测问题。</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/SSD1.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;SDD的网络架构：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Brickexperts/Figurebed/master/%E7%9B%AE%E6%A0%8718.png&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;SSD以VGG1
      
    
    </summary>
    
      <category term="目标检测" scheme="http://yoursite.com/categories/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/"/>
    
      <category term="one-stage" scheme="http://yoursite.com/categories/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/one-stage/"/>
    
      <category term="SSD" scheme="http://yoursite.com/categories/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/one-stage/SSD/"/>
    
      <category term="SSD原理" scheme="http://yoursite.com/categories/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/one-stage/SSD/SSD%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="SSD算法" scheme="http://yoursite.com/tags/SSD%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>One-stage基本介绍</title>
    <link href="http://yoursite.com/2019/08/20/One-stage%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D/"/>
    <id>http://yoursite.com/2019/08/20/One-stage基本介绍/</id>
    <published>2019-08-20T01:44:40.000Z</published>
    <updated>2019-08-20T09:25:33.086Z</updated>
    
    <content type="html"><![CDATA[<p>​    One-stage也是使用CNN卷积特征，直接回归物体的类别概率和位置坐标值（无region proposal），准确度低、速度相对于Two-stage快。</p><p>One-stage常见算法：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/%E7%9B%AE%E6%A0%8715.png" alt></p><p>One-stage核心组件：</p><p>CNN网络</p><p>CNN网络设计原则：从简到繁到简的卷积神经网    多尺度特征融合的网络    更轻量级的CNN网络</p><p>回归网络    </p><p><strong>One-stage和Two-stage的区别在于是否存在RPN网络。</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;​    One-stage也是使用CNN卷积特征，直接回归物体的类别概率和位置坐标值（无region proposal），准确度低、速度相对于Two-stage快。&lt;/p&gt;
&lt;p&gt;One-stage常见算法：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.gi
      
    
    </summary>
    
      <category term="目标检测" scheme="http://yoursite.com/categories/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/"/>
    
      <category term="One-stage" scheme="http://yoursite.com/categories/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/One-stage/"/>
    
      <category term="One-stage基本介绍" scheme="http://yoursite.com/categories/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/One-stage/One-stage%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D/"/>
    
    
      <category term="One-stage" scheme="http://yoursite.com/tags/One-stage/"/>
    
  </entry>
  
  <entry>
    <title>Two-stage基本介绍</title>
    <link href="http://yoursite.com/2019/08/18/Two-stage%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D/"/>
    <id>http://yoursite.com/2019/08/18/Two-stage基本介绍/</id>
    <published>2019-08-18T09:09:22.000Z</published>
    <updated>2019-08-22T02:23:46.976Z</updated>
    
    <content type="html"><![CDATA[<p>​    Two-stage相对于one-stage准确度高，但是速度相对one-stage慢。</p><p>Two-stage常见算法：RCNN、Fast RCNN、Faster RCNN、Faster RCNN变种。</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/%E7%9B%AE%E6%A0%8714.png" alt></p><p>Two-stage核心组件：</p><p><strong>CNN网络</strong></p><p> CNN网络设计原则：</p><p>从简到繁再到简的卷积神经网</p><p>多尺度特征融合的网络</p><p>更轻量级的CNN网络</p><p><strong>RPN网络</strong></p><p>区域推荐（Anchor机制）：首先我们需要知道anchor的本质是什么，本质是SPP(spatial pyramid pooling)思想的逆向。而SPP本身是做什么的呢，就是将不同尺寸的输入resize成为相同尺寸的输出。所以SPP的逆向就是，将相同尺寸的输出，倒推得到不同尺寸的输入。当前的feature map的大小是n*c*w*h（n是张数，c是层数，w是宽，h是高），对于当前这个feature map上，也就是w<em>h上，选择其中的每一个点作为锚点（也就是候选区域的中心点），我们以每一个点作为中心点去提取候选区域。这样的每一个点都是Anchor。而这个候选区域通常都有比例：对于Fast  R-CNN三个面积尺寸（128^2，256^2，512^2），然后在每个面积尺寸下，取三种不同的长宽比例（1:1,1:2,2:1）。一个feature map可以提取w\</em>h*9个候选区域。我们示意图如下：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/%E7%9B%AE%E6%A0%8716.png" alt></p><p>ROI Pooling</p><p>分类和回归</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;​    Two-stage相对于one-stage准确度高，但是速度相对one-stage慢。&lt;/p&gt;
&lt;p&gt;Two-stage常见算法：RCNN、Fast RCNN、Faster RCNN、Faster RCNN变种。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://
      
    
    </summary>
    
      <category term="目标检测" scheme="http://yoursite.com/categories/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/"/>
    
      <category term="Two-stage算法" scheme="http://yoursite.com/categories/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/Two-stage%E7%AE%97%E6%B3%95/"/>
    
      <category term="Two-stage基本介绍" scheme="http://yoursite.com/categories/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/Two-stage%E7%AE%97%E6%B3%95/Two-stage%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D/"/>
    
    
      <category term="Two-stage" scheme="http://yoursite.com/tags/Two-stage/"/>
    
  </entry>
  
  <entry>
    <title>NMS算法</title>
    <link href="http://yoursite.com/2019/08/18/NMS%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2019/08/18/NMS算法/</id>
    <published>2019-08-18T08:33:12.000Z</published>
    <updated>2019-08-18T08:48:18.449Z</updated>
    
    <content type="html"><![CDATA[<p>​    NMS全称是非极大值抑制算法。</p><p>目的：为了消除多余的框，找到最佳的物体检测的位置。</p><p>思想:选取那些邻域里分数最高的窗口，同时抑制那些分数低的窗口。</p><p>其实NMS的处理不太合理。所以有人提出了Soft-NMS。</p><p>NMS和Soft-NMS的区别：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/%E7%9B%AE%E6%A0%8713.png" alt></p><p>相邻区域内的检测框的分数进行调整而非彻底抑制，从而提高了高检索率情况下的准确率。再低检索率时仍能对物体检测性能有明显提升。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;​    NMS全称是非极大值抑制算法。&lt;/p&gt;
&lt;p&gt;目的：为了消除多余的框，找到最佳的物体检测的位置。&lt;/p&gt;
&lt;p&gt;思想:选取那些邻域里分数最高的窗口，同时抑制那些分数低的窗口。&lt;/p&gt;
&lt;p&gt;其实NMS的处理不太合理。所以有人提出了Soft-NMS。&lt;/p&gt;
&lt;p&gt;
      
    
    </summary>
    
      <category term="目标检测" scheme="http://yoursite.com/categories/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/"/>
    
      <category term="NMS算法" scheme="http://yoursite.com/categories/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/NMS%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="目标检测算法" scheme="http://yoursite.com/tags/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>DPM算法</title>
    <link href="http://yoursite.com/2019/08/18/DPM%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2019/08/18/DPM算法/</id>
    <published>2019-08-18T07:52:34.000Z</published>
    <updated>2019-08-18T08:32:48.720Z</updated>
    
    <content type="html"><![CDATA[<p>​    DPM算法是传统目标检测方法的巅峰。</p><p>步骤：</p><p>1、计算DPM特征图</p><p>2、计算响应图</p><p>3、Latent SVM分类器训练</p><p>4、检测识别</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;​    DPM算法是传统目标检测方法的巅峰。&lt;/p&gt;
&lt;p&gt;步骤：&lt;/p&gt;
&lt;p&gt;1、计算DPM特征图&lt;/p&gt;
&lt;p&gt;2、计算响应图&lt;/p&gt;
&lt;p&gt;3、Latent SVM分类器训练&lt;/p&gt;
&lt;p&gt;4、检测识别&lt;/p&gt;

      
    
    </summary>
    
      <category term="目标检测" scheme="http://yoursite.com/categories/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/"/>
    
      <category term="传统目标检测" scheme="http://yoursite.com/categories/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/%E4%BC%A0%E7%BB%9F%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/"/>
    
      <category term="DPM算法" scheme="http://yoursite.com/categories/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/%E4%BC%A0%E7%BB%9F%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/DPM%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="传统目标检测" scheme="http://yoursite.com/tags/%E4%BC%A0%E7%BB%9F%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/"/>
    
  </entry>
  
  <entry>
    <title>HOG+SVM算法</title>
    <link href="http://yoursite.com/2019/08/18/HOG-SVM%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2019/08/18/HOG-SVM算法/</id>
    <published>2019-08-18T07:36:23.000Z</published>
    <updated>2019-08-18T07:51:56.371Z</updated>
    
    <content type="html"><![CDATA[<p>HOG+SVM算法主要用于行人检测。</p><p>步骤：</p><p>1、提取HOG特征。<strong>如果彩色图需要用HOG特征，则需要先转化为灰度图。</strong></p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/%E7%9B%AE%E6%A0%8711.png" alt></p><p>2、训练SVM分类器</p><p>３、利用滑动窗口提取目标区域，进行分类判断</p><p>4、NMS</p><p>5、输出检测结果</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;HOG+SVM算法主要用于行人检测。&lt;/p&gt;
&lt;p&gt;步骤：&lt;/p&gt;
&lt;p&gt;1、提取HOG特征。&lt;strong&gt;如果彩色图需要用HOG特征，则需要先转化为灰度图。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.
      
    
    </summary>
    
      <category term="目标检测" scheme="http://yoursite.com/categories/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/"/>
    
      <category term="传统目标检测算法" scheme="http://yoursite.com/categories/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/%E4%BC%A0%E7%BB%9F%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E7%AE%97%E6%B3%95/"/>
    
      <category term="HOG+SVM" scheme="http://yoursite.com/categories/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/%E4%BC%A0%E7%BB%9F%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E7%AE%97%E6%B3%95/HOG-SVM/"/>
    
    
      <category term="传统目标检测算法" scheme="http://yoursite.com/tags/%E4%BC%A0%E7%BB%9F%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>VJ算法</title>
    <link href="http://yoursite.com/2019/08/18/VJ%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2019/08/18/VJ算法/</id>
    <published>2019-08-18T07:22:05.000Z</published>
    <updated>2019-08-18T07:36:01.927Z</updated>
    
    <content type="html"><![CDATA[<p>​    VJ算法全称为Viola—Jones，多用于人脸检测。</p><p>步骤：</p><p>1、Haar特征抽取 </p><p>Haar特征分为三类：边缘特征、线性特征、中心特征和对角线特征，组合成特征模板。特征模板内有白色和黑色两种矩形，并定义该模板的特征值为白色矩形像素和减去黑色矩形像素和。Haar特征值反映了图像的灰度变化情况。例如：脸部的一些特征能由矩形特征简单的描述，如：眼睛要比脸颊颜色要深，鼻梁两侧比鼻梁颜色要深，嘴巴比周围颜色要深等。</p><p>2、训练人脸分类器（Adaboost算法等）</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/%E7%9B%AE%E6%A0%879.png" alt></p><p>3、滑动窗口</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;​    VJ算法全称为Viola—Jones，多用于人脸检测。&lt;/p&gt;
&lt;p&gt;步骤：&lt;/p&gt;
&lt;p&gt;1、Haar特征抽取 &lt;/p&gt;
&lt;p&gt;Haar特征分为三类：边缘特征、线性特征、中心特征和对角线特征，组合成特征模板。特征模板内有白色和黑色两种矩形，并定义该模板的特征值为
      
    
    </summary>
    
      <category term="目标检测" scheme="http://yoursite.com/categories/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/"/>
    
      <category term="传统目标检测算法" scheme="http://yoursite.com/categories/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/%E4%BC%A0%E7%BB%9F%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E7%AE%97%E6%B3%95/"/>
    
      <category term="VJ算法" scheme="http://yoursite.com/categories/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/%E4%BC%A0%E7%BB%9F%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E7%AE%97%E6%B3%95/VJ%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="传统目标检测算法" scheme="http://yoursite.com/tags/%E4%BC%A0%E7%BB%9F%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>mysql基础命令</title>
    <link href="http://yoursite.com/2019/08/13/mysql%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/"/>
    <id>http://yoursite.com/2019/08/13/mysql基础命令/</id>
    <published>2019-08-13T01:39:02.000Z</published>
    <updated>2019-08-13T02:19:28.350Z</updated>
    
    <content type="html"><![CDATA[<p>sql语句最后需要以；号结尾，sql语句最后需要以；号结尾，sql语句最后需要以；号结尾。重要的事说三遍。</p><h2 id="数据库操作"><a href="#数据库操作" class="headerlink" title="数据库操作"></a>数据库操作</h2><p>select version()：显示数据库版本</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/mysql34.png" alt></p><p>select now()：显示时间</p><p>show databases：查看所有数据库</p><p>show create database 数据库名：查看创建数据库的语句</p><p>create database 数据库名字：创建数据库</p><p>create database 数据库名字 charset=utf8：创建指定编码格式的数据库</p><p>drop database 数据库名：删除数据库</p><p>use 数据库名：使用数据库</p><p>select database ()：查看当前使用的数据库</p><h2 id="数据表操作"><a href="#数据表操作" class="headerlink" title="数据表操作"></a>数据表操作</h2><p>show tables:查看当前数据库中所有表</p><p>drop table 表名：删除表</p><p>show create table 表名：查看创建表的语句</p><p>create table 表名（字段 类型 约束[，字段 类型 约束]）：创建表</p><p>参数：auto_increment表示自动增长、not null表示不能为空、primary key表示主键、default 默认值</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/mysql35.png" alt></p><p>desc 表名：查看表的状态</p><p>insert into 表名 values()：向表插入数据，按照参数类型写参数</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/mysql33.png" alt></p><p>select * from 表名：查看表中所有的数据</p><p>alter table 表名 add 列名 类型：向表中添加字段</p><p>alter table 表名 modify 列名 类型 约束：不重命列名版</p><p>alter table 表名 change 列的原名 列的新名 类型 约束 ：重命列名版</p><p>alter table 表名 drop 列名：删除字段</p><h2 id="数据的增删改查"><a href="#数据的增删改查" class="headerlink" title="数据的增删改查"></a>数据的增删改查</h2><h3 id="增加"><a href="#增加" class="headerlink" title="增加"></a>增加</h3><p>全列插入：insert into 表名 values(数据)</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/mysql33.png" alt></p><p>主键字段：可以用0 null default 来占位。因为auto_increment是自动增加的</p><p>部分插入：insert into 表名(列名1) values(值1) 没有的值取默认值</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/mysql1.png" alt></p><p>多行插入：insert into 表名 values (数据1)，(数据2)</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/mysql2.png" alt></p><p>update 表名 set 列名 ：整列都改</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/mysql3.png" alt></p><p>update 表名 set  列名  where 条件：根据条件改</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/mysql5.png" alt></p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/mysql6.png" alt></p><p>通过其他表来更新一个表：</p><p>update 其他表 as 新名 inner join 被更新的表 as 新名 on  条件 set 需要改的数据</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/mysql7.png" alt></p><h3 id="查询："><a href="#查询：" class="headerlink" title="查询："></a>查询：</h3><p>select * from 表名：查询整个表，*号代表全部</p><p>select * from 表名 where ：根据条件查询</p><p>select 查询的列名 from 表名：根据列名查询。查询多列时，列名间用,隔开</p><p>select 查询的列名 as 列的新名字 from 表名：将列查询后以新的名字显示出来</p><p>select 表名.列名 from 表名</p><p>select 表的新名字.列名 from 表名 as 表的新名字</p><p>select distinct 列名 from 表名：可以去重，只显示相同数据第一次数据出现的位置</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/mysql8.png" alt></p><h4 id="条件查询："><a href="#条件查询：" class="headerlink" title="条件查询："></a>条件查询：</h4><p>and、or、not都可以用，类似python的语法。判断是否为空，is NULL。</p><h4 id="模糊查询："><a href="#模糊查询：" class="headerlink" title="模糊查询："></a>模糊查询：</h4><p>like ：%代表一个或多个，_代表一个。</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/mysql9.png" alt></p><p>select name from 表名 where name like “%小%”：查询名字中有”小”字的名字</p><p>select name from 表名 where name like “__”：查询两个字的名字</p><p>select name from 表名 where name like “__%”：查询两个字以上的名字</p><h4 id="rlike：利用正则查询"><a href="#rlike：利用正则查询" class="headerlink" title="rlike：利用正则查询"></a>rlike：利用正则查询</h4><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/mysql10.png" alt></p><h4 id="范围查询："><a href="#范围查询：" class="headerlink" title="范围查询："></a>范围查询：</h4><p>in表示在一个非连续的范围内</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/mysql11.png" alt></p><p>between 数字 and 数字表示在一个连续的范围内</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/mysql12.png" alt></p><h3 id="排序：order-by-默认从小到大排序"><a href="#排序：order-by-默认从小到大排序" class="headerlink" title="排序：order by 默认从小到大排序"></a>排序：order by 默认从小到大排序</h3><p>asc：从小到大排</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/mysql13.png" alt></p><p>desc：从大到小排</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/mysql14.png" alt></p><p>如果排序字段相同，我们可以设置多个排序字段。若不设置，默认按照主键大小排。</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/mysql15.png" alt></p><h3 id="聚合函数-count，max，min，avg，sum，round-：不能跟其他字段一起用"><a href="#聚合函数-count，max，min，avg，sum，round-：不能跟其他字段一起用" class="headerlink" title="聚合函数(count，max，min，avg，sum，round)：不能跟其他字段一起用"></a>聚合函数(count，max，min，avg，sum，round)：不能跟其他字段一起用</h3><p>count：计算个数，其他类似</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/mysql16.png" alt></p><p>max：计算最大的</p><p>min：计算最小的</p><p>avg：计算平均值</p><p>sum：求和</p><p>round：四舍五入 ，round(123.23,1)保留一位小数=123.2</p><h3 id="分组：group-by"><a href="#分组：group-by" class="headerlink" title="分组：group by"></a>分组：group by</h3><p>按照性别分组：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/mysql17.png" alt></p><p>配合聚合函数使用计算每种性别的人数：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/mysql18.png" alt></p><p>计算男性的人数：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/mysql19.png" alt></p><p>group_concat():查询同一组的其他字段</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/mysql20.png" alt></p><p>还可以用字符串分割</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/mysql21.png" alt></p><p>having：将达到条件的组输出，可以配合聚合函数一起使用</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/mysql22.png" alt></p><p><strong>having和where的区别：having是在分组后进行筛选，where是在原表的基础上进行筛选</strong></p><h3 id="分页："><a href="#分页：" class="headerlink" title="分页："></a>分页：</h3><p>limit start，count   限制查询出来的数据个数。start代表从哪开始，count 代表查询的数据个数。start默认为0</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/mysql23.png" alt></p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/mysql24.png" alt></p><h3 id="链接查询：内链接、左链接、右链接"><a href="#链接查询：内链接、左链接、右链接" class="headerlink" title="链接查询：内链接、左链接、右链接"></a>链接查询：内链接、左链接、右链接</h3><h4 id="内链接：inner-join-……on"><a href="#内链接：inner-join-……on" class="headerlink" title="内链接：inner join ……on"></a>内链接：inner join ……on</h4><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/mysql25.png" alt></p><p>在两个表中取交集，如果存在则将两表数据合并。不存在则跳过。</p><p>可以利用as化简语句：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/mysql26.png" alt></p><p>可以根据需求修改需要显示的数据：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/mysql27.png" alt></p><p>还可以修改数据显示的位置：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/mysql28.png" alt></p><p>通过某个表的字段排序：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/mysql29.png" alt></p><h4 id="左链接：left-join……on。谁在左边，谁就是左表。"><a href="#左链接：left-join……on。谁在左边，谁就是左表。" class="headerlink" title="左链接：left join……on。谁在左边，谁就是左表。"></a>左链接：left join……on。谁在左边，谁就是左表。</h4><p>查询的结果为两个表匹配到的数据，左表特有的数据，对于右表不存在的数据使用null填充</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/mysql30.png" alt></p><p>将左表特有的数据提取出来：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/mysql31.png" alt></p><h4 id="右链接：right-join……on：类似左表。可以直接将右链接的表中左表和右表的显示交换即可得右链接。"><a href="#右链接：right-join……on：类似左表。可以直接将右链接的表中左表和右表的显示交换即可得右链接。" class="headerlink" title="右链接：right join……on：类似左表。可以直接将右链接的表中左表和右表的显示交换即可得右链接。"></a>右链接：right join……on：类似左表。可以直接将右链接的表中左表和右表的显示交换即可得右链接。</h4><p>自关联：补。。。。</p><p>子查询：查询里嵌套一个查询</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/mysql32.png" alt></p><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><p>删除分为物理删除和逻辑删除：</p><p>物理删除：</p><p>delete from 表名:删除整个表</p><p>delete from 表名 where 条件：删除符合条件的数据</p><p>逻辑删除：（用一个字段表示，这条信息是否还能用）</p><p>alter table 表名 add 字段 类型 default 默认值</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;sql语句最后需要以；号结尾，sql语句最后需要以；号结尾，sql语句最后需要以；号结尾。重要的事说三遍。&lt;/p&gt;
&lt;h2 id=&quot;数据库操作&quot;&gt;&lt;a href=&quot;#数据库操作&quot; class=&quot;headerlink&quot; title=&quot;数据库操作&quot;&gt;&lt;/a&gt;数据库操作&lt;/h2&gt;
      
    
    </summary>
    
      <category term="数据库" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="mysql" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/"/>
    
      <category term="基础命令" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/"/>
    
    
      <category term="mysql" scheme="http://yoursite.com/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>网络知识散记</title>
    <link href="http://yoursite.com/2019/08/13/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E6%95%A3%E8%AE%B0/"/>
    <id>http://yoursite.com/2019/08/13/网络知识散记/</id>
    <published>2019-08-13T01:20:46.000Z</published>
    <updated>2019-08-13T01:28:13.242Z</updated>
    
    <content type="html"><![CDATA[<h2 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h2><p>端口是英文port的意译，可以认为是设备与外界通讯交流的出口。端口可分为虚拟端口和物理端口，其中虚拟端口指计算机内部或交换机路由器内的端口，不可见。例如计算机中的80端口、21端口、23端口等。物理端口又称为接口，是可见端口，计算机背板的RJ45网口，交换机路由器集线器等RJ45端口。电话使用RJ11插口也属于物理端口的范畴。（用来区分哪个进程）   同一台电脑用pid区分进程，不同电脑用端口区分进程。</p><p>端口范围是0到65535</p><p>知名端口是众所周知的端口，范围是0到1023</p><p>动态端口的范围是1024到65535</p><p>查看端口状态：用netstat -an查看</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/net1.png" alt></p><h2 id="TCP-IP协议"><a href="#TCP-IP协议" class="headerlink" title="TCP/IP协议"></a>TCP/IP协议</h2><p>TCP/IP:这不是两个协议，这是一个协议族，包含很多协议。主要是TCP/IP协议。</p><p>四层：物理层、网络层、传输层、应用层</p><p>七层：物理层、链路层、网络层、传输层、 会话层、表示层、应用层</p><h2 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h2><p>用来标记唯一一台电脑。每一个IP地址都包括网络地址和主机地址</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/net2.png" alt></p><p>网络地址相同，则处于同一个网段，主机地址用来标记网里的电脑</p><p>A类网络的IP地址范围为：1.0.0.1－126.255.255.254； </p><p>B类网络的IP地址范围为：128.1.0.1－191.255.255.254； </p><p>C类网络的IP地址范围为：192.0.1.1－223.255.255.254</p><p>1．A类IP地址</p><p>一个A类IP地址由1字节（每个字节是8位）的网络地址和3个字节主机地址组成,即第一段数字范围为1～126。每个A类地址可连接16387064台主机(不能用0(产生冲突)和255(广播地址)，Internet有126个A类地址。</p><p>2．B类IP地址</p><p>一个B类IP地址由2个字节的网络地址和2个字节的主机地址组成，第一段数字范围为128～191。每个B类地址可连接64516(254*254)台主机(不能用0(产生冲突)和255(广播地址))，Internet有16256个B类地址。</p><p>3．C类IP地址</p><p>一个C类地址是由3个字节的网络地址和1个字节的主机地址组成，第一段数字范围为192～223。每个C类地址可连接254台主机(不能用0(产生冲突)和255(广播地址)，Internet有2054512个C类地址。</p><p>4．D类地址用于多点播送。</p><p>第一个字节的数字范围为224～239，是多点播送地址，用于多目的地信息的传输，和作为备用。全零（“0.0.0.0”）地址对应于当前主机，全“1”的IP地址（“255.255.255.255”）是当前子网的广播地址。多播和广播的区别：广播在同一个局域网都能收到，多播是指定那些人可以收得到，其他人收不到，常用于视频会议。</p><p>5.E类地址</p><p>第一段数字范围为240～254。E类地址保留，仅作实验和开发用。</p><p>全零（“0．0．0．0”）地址对应于当前主机。全“1”的IP地址（“255．255．255．255”）是当前子网的广播地址。</p><p>在IP地址3种主要类型里，各保留了3个区域作为私有地址，常见于局域网中。</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/net3.png" alt></p><p>##常用术语</p><p>网络号：网络号等于ip地址和网络掩码按位与操作</p><p>网络掩码（子网掩码）的作用：取网络号、主机号</p><p>两台电脑能通信的前提是处于同一个网络号</p><p>集线器（hub）的作用：实现多台电脑连接在一起，组成一个小型局域网，交换机也是。</p><p>集线器和交换机的区别：集线器是广播发数据，交换机不是每次都是广播，效率高。</p><p>实际地址：代表网卡地址（MAC）。由六个字节组成，前三个字节代表厂商，后三个字节代表厂商生产</p><p>arp：根据ip找mac地址</p><p>rarp：根据mac地址找ip</p><p>icmp：ping的时候用</p><p>arp -a即是查看本地局域网内所有用户ip和mac地址绑定关系的一个命令。</p><p>ARP -d 就是清除缓存中的数据。也是删除ip和mac绑定的项目。</p><p>路由器：连接不同的网络，使他们之间能够通信</p><p>rip：路由解析协议</p><p>mac：标记实际转发数据时的地址</p><p>ip：标记逻辑上的地址</p><p>natmask：和ip地址一起确定网络号</p><p>默认网关：发送的ip不在同一个网段内，那么会把这个数据转发给默认网关。</p><p>为什么TCP比UDP稳定？在TCP中，如果有一方接收到对方的数据，一定会发送ack确认包给对方。而在UDP中，没有这个过程。</p><p>TCP三次握手：确定一定发送数据到对方    四次挥手：调用close时使用</p><p>TCP长连接、短连接：</p><p>TTL：表示经过的路由器数目。每经过一个路由器，TTL-1。</p><p>MSL：表示一个数据包存在的最多时间</p><p>CDN：内容分发</p><p>查看域名解析的IP地址：</p><p>nslookup 域名         例子：nslookup baidu.com</p><p>常见的网络攻击：</p><p>DDOS攻击：拒绝服务器攻击。</p><p>DNS攻击：1.DNS服务器被劫持：篡改IP</p><p>​                  2.DNS欺骗：</p><p>ARP攻击：中间人攻击</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;端口&quot;&gt;&lt;a href=&quot;#端口&quot; class=&quot;headerlink&quot; title=&quot;端口&quot;&gt;&lt;/a&gt;端口&lt;/h2&gt;&lt;p&gt;端口是英文port的意译，可以认为是设备与外界通讯交流的出口。端口可分为虚拟端口和物理端口，其中虚拟端口指计算机内部或交换机路由器内的端口，
      
    
    </summary>
    
      <category term="网络知识" scheme="http://yoursite.com/categories/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/"/>
    
      <category term="知识散记" scheme="http://yoursite.com/categories/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/%E7%9F%A5%E8%AF%86%E6%95%A3%E8%AE%B0/"/>
    
    
      <category term="网络知识散记" scheme="http://yoursite.com/tags/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E6%95%A3%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>目标检测概述</title>
    <link href="http://yoursite.com/2019/08/12/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E6%A6%82%E8%BF%B0/"/>
    <id>http://yoursite.com/2019/08/12/目标检测概述/</id>
    <published>2019-08-12T02:30:19.000Z</published>
    <updated>2019-08-18T07:20:44.266Z</updated>
    
    <content type="html"><![CDATA[<p>​    目标检测方法分为传统目标检测方法和深度学习目标检测方法。</p><p>传统目标检测方法：Viola-Jones、HOG+SVM、DPM等</p><p>Viola-Jones：采用积分图特征，进行人脸检测</p><p>HOG+SVM：行人检测。通过HOG特征结合SVM分类器进行检测。</p><p>DPM：同样通过HOG特征，并加入许多其他额外的策略进行检测。传统目标检测最好的方法。</p><p>深度学习目标检测方法：One-state、Two-stage</p><p>One-stage：YOLO和SSD系列，直接回归目标位置。</p><p>Two-stage：Faster RCNN系列，利用网络对候选区进行推荐。</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/%E7%9B%AE%E6%A0%871.png" alt></p><p>目标检测问题基本流程：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/%E7%9B%AE%E6%A0%8710.png" alt></p><p><strong>Viola-Jones（人脸检测）步骤</strong></p><p>1、Haar特征抽取</p><p>2、训练人脸分类器（Adaboost算法）</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/%E7%9B%AE%E6%A0%872.png" alt></p><p>3、滑动窗口</p><p><strong>HOG+SVM（行人检测）步骤</strong></p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/%E7%9B%AE%E6%A0%873.png" alt></p><p><strong>DPM（物体检测）步骤</strong></p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/%E7%9B%AE%E6%A0%874.png" alt></p><p>NMS（非极大值抑制算法）</p><p>目的：为了消除多余的框，找到最佳的物体检测的位置</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/%E7%9B%AE%E6%A0%87.png" alt></p><p>Soft-NMS是对NMS算法的改进</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/%E7%9B%AE%E6%A0%876.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;​    目标检测方法分为传统目标检测方法和深度学习目标检测方法。&lt;/p&gt;
&lt;p&gt;传统目标检测方法：Viola-Jones、HOG+SVM、DPM等&lt;/p&gt;
&lt;p&gt;Viola-Jones：采用积分图特征，进行人脸检测&lt;/p&gt;
&lt;p&gt;HOG+SVM：行人检测。通过HOG特征结
      
    
    </summary>
    
      <category term="目标检测" scheme="http://yoursite.com/categories/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/"/>
    
      <category term="目标检测概述" scheme="http://yoursite.com/categories/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E6%A6%82%E8%BF%B0/"/>
    
    
      <category term="目标检测" scheme="http://yoursite.com/tags/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/"/>
    
  </entry>
  
  <entry>
    <title>opencv颜色识别</title>
    <link href="http://yoursite.com/2019/08/12/opencv%E9%A2%9C%E8%89%B2%E8%AF%86%E5%88%AB/"/>
    <id>http://yoursite.com/2019/08/12/opencv颜色识别/</id>
    <published>2019-08-12T01:18:09.000Z</published>
    <updated>2019-08-18T01:08:11.659Z</updated>
    
    <content type="html"><![CDATA[<p>   数字图像处理中常用的采用模型是RGB（红，绿，蓝）模型和HSV（色调，饱和度，亮度），RGB广泛应用于彩色监视器和彩色视频摄像机，我们平时的图片一般都是RGB模型。而HSV模型更符合人描述和解释颜色的方式，HSV的彩色描述对人来说是自然且非常直观的。</p><p>这里的颜色识别是指根据人们的意愿提取图片中对应的颜色区域。</p><p>颜色识别步骤：</p><p>1、读取一张图片或视频.</p><p>2、用cvtcolor将它从RGB转为HSV。</p><p>3、通过inrange得出掩膜。</p><p>4、用 图像的”与”操作(bitwise_and)得出对应区域的图像。</p><p>coding：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/color.png" alt></p><p>读者可以加一些其他的操作提高效果，例如什么开运算、滤波之类的。这里就不赘述了，接下来，贴一张HSV的颜色阈值表，可以参考：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/color2.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;   数字图像处理中常用的采用模型是RGB（红，绿，蓝）模型和HSV（色调，饱和度，亮度），RGB广泛应用于彩色监视器和彩色视频摄像机，我们平时的图片一般都是RGB模型。而HSV模型更符合人描述和解释颜色的方式，HSV的彩色描述对人来说是自然且非常直观的。&lt;/p&gt;
&lt;p&gt;这
      
    
    </summary>
    
      <category term="python" scheme="http://yoursite.com/categories/python/"/>
    
      <category term="opencv" scheme="http://yoursite.com/categories/python/opencv/"/>
    
      <category term="颜色识别" scheme="http://yoursite.com/categories/python/opencv/%E9%A2%9C%E8%89%B2%E8%AF%86%E5%88%AB/"/>
    
    
      <category term="颜色识别" scheme="http://yoursite.com/tags/%E9%A2%9C%E8%89%B2%E8%AF%86%E5%88%AB/"/>
    
  </entry>
  
  <entry>
    <title>魔法方法</title>
    <link href="http://yoursite.com/2019/08/10/%E9%AD%94%E6%B3%95%E6%96%B9%E6%B3%95/"/>
    <id>http://yoursite.com/2019/08/10/魔法方法/</id>
    <published>2019-08-10T01:34:31.000Z</published>
    <updated>2019-08-10T02:12:25.513Z</updated>
    
    <content type="html"><![CDATA[<p>​    魔法方法是指Python内部已经包含的，被双下划线所包围的方法，这些方法在进行特定的操作时会自动被调用。使用Python的魔法方法可以是Python的自由度变得更高，当不需要重写魔法方法也可以在规定的默认情况下生效。在需要重写时也可以让使用者根据自己的需求来重写部分方法来达到自己的期待。</p><h2 id="常用的魔法方法："><a href="#常用的魔法方法：" class="headerlink" title="常用的魔法方法："></a>常用的魔法方法：</h2><p>__doc__：表示类的描述信息</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/magic1.png" alt></p><p>__module__:表示当前操作的对象在哪个模块</p><p>__class__:表示当前操作的对象的类是什么</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/magic2.png" alt></p><p>__call__：让对象直接调用call方法</p><p>__dict__：类或对象的所有属性</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/magic3.png" alt></p><p>__getitem__、__setitem__、__delitem__：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/magic4.png" alt></p><h2 id="魔法方法集合"><a href="#魔法方法集合" class="headerlink" title="魔法方法集合"></a>魔法方法集合</h2><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/magic5.png" alt></p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/magic6.png" alt></p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/magic7.png" alt></p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/magic8.png" alt></p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/magic9.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;​    魔法方法是指Python内部已经包含的，被双下划线所包围的方法，这些方法在进行特定的操作时会自动被调用。使用Python的魔法方法可以是Python的自由度变得更高，当不需要重写魔法方法也可以在规定的默认情况下生效。在需要重写时也可以让使用者根据自己的需求来重写部
      
    
    </summary>
    
      <category term="python" scheme="http://yoursite.com/categories/python/"/>
    
      <category term="魔法方法" scheme="http://yoursite.com/categories/python/%E9%AD%94%E6%B3%95%E6%96%B9%E6%B3%95/"/>
    
    
      <category term="魔法方法" scheme="http://yoursite.com/tags/%E9%AD%94%E6%B3%95%E6%96%B9%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>深度学习（3）</title>
    <link href="http://yoursite.com/2019/08/09/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%EF%BC%883%EF%BC%89/"/>
    <id>http://yoursite.com/2019/08/09/深度学习（3）/</id>
    <published>2019-08-09T05:03:29.000Z</published>
    <updated>2019-08-09T05:09:52.613Z</updated>
    
    <content type="html"><![CDATA[<p>​    感知机：有n个输入数据，通过权重与各数据之间的计算和，比较激活函数结果，得出输出。感知机是解决分类问题。</p><p>神经网络的基本组成包括输入层、隐藏层、输出层。卷积神经网络的特点在于隐藏层分为卷积层和池化层。</p><p>神经网络的种类：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/DL30.png" alt></p><p>神经网络的策略是交叉熵损失，优化是通过反向传播算法（相当于梯度下降 ）。</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/DL31.png" alt></p><p>简单神经网络：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/DL32.png" alt></p><p>卷积神经网络：</p><p>卷积层：通过在原始图像上平移来提取特征</p><p>零填充方式：SAME和VALID。</p><p>当填充方式为SAME时：无法取整时，向上取值</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/DL33.png" alt></p><p>当填充方式为VALID时，无法取整时，向上取值</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/DL34.png" alt></p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/DL35.png" alt></p><p>卷积向下取整，池化向上取整</p><p>例：当卷积层100个filter，5*5，步长为1，零填充是2时。输入[28,28,1]大小的图像，输出[26,26,100]的图像。</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/DL36.png" alt></p><p>池化层：通过特征后稀疏参数来减少学习的参数，降低网络的复杂度（最大池化和平均值化）</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/DL37.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;​    感知机：有n个输入数据，通过权重与各数据之间的计算和，比较激活函数结果，得出输出。感知机是解决分类问题。&lt;/p&gt;
&lt;p&gt;神经网络的基本组成包括输入层、隐藏层、输出层。卷积神经网络的特点在于隐藏层分为卷积层和池化层。&lt;/p&gt;
&lt;p&gt;神经网络的种类：&lt;/p&gt;
&lt;p&gt;&lt;
      
    
    </summary>
    
      <category term="python" scheme="http://yoursite.com/categories/python/"/>
    
      <category term="深度学习" scheme="http://yoursite.com/categories/python/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="深度学习（3）" scheme="http://yoursite.com/categories/python/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%EF%BC%883%EF%BC%89/"/>
    
    
      <category term="深度学习" scheme="http://yoursite.com/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>深度学习（2）</title>
    <link href="http://yoursite.com/2019/08/09/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%EF%BC%882%EF%BC%89/"/>
    <id>http://yoursite.com/2019/08/09/深度学习（2）/</id>
    <published>2019-08-09T04:53:25.000Z</published>
    <updated>2019-08-09T05:03:13.437Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数据读取"><a href="#数据读取" class="headerlink" title="数据读取"></a>数据读取</h2><p>通过线程和队列提高速度。可以边取数据边训练</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/DL19.png" alt></p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/DL20.png" alt></p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/DL@1.png" alt></p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/DL21.png" alt></p><h2 id="模型的保存和加载"><a href="#模型的保存和加载" class="headerlink" title="模型的保存和加载"></a>模型的保存和加载</h2><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/DL22.png" alt></p><p>模型保存：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/DL23.png" alt></p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/DL24.png" alt></p><p>模型加载：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/DL25.png" alt></p><h2 id="添加权重参数、损失值等的变化"><a href="#添加权重参数、损失值等的变化" class="headerlink" title="添加权重参数、损失值等的变化"></a>添加权重参数、损失值等的变化</h2><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/DL26.png" alt></p><p>首先收集变量：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/DL27.png" alt></p><p>而后在会话中运行：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/DL28.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;数据读取&quot;&gt;&lt;a href=&quot;#数据读取&quot; class=&quot;headerlink&quot; title=&quot;数据读取&quot;&gt;&lt;/a&gt;数据读取&lt;/h2&gt;&lt;p&gt;通过线程和队列提高速度。可以边取数据边训练&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubuserc
      
    
    </summary>
    
      <category term="python" scheme="http://yoursite.com/categories/python/"/>
    
      <category term="深度学习" scheme="http://yoursite.com/categories/python/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="深度学习（2）" scheme="http://yoursite.com/categories/python/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%EF%BC%882%EF%BC%89/"/>
    
    
      <category term="深度学习" scheme="http://yoursite.com/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>深度学习（1）</title>
    <link href="http://yoursite.com/2019/08/09/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%EF%BC%881%EF%BC%89/"/>
    <id>http://yoursite.com/2019/08/09/深度学习（1）/</id>
    <published>2019-08-09T04:17:39.000Z</published>
    <updated>2019-08-09T04:52:39.127Z</updated>
    
    <content type="html"><![CDATA[<h2 id="tensorflow基本知识"><a href="#tensorflow基本知识" class="headerlink" title="tensorflow基本知识"></a>tensorflow基本知识</h2><p>在tensorflow中把数据称为张量（tensor）。</p><p>张量的阶：相当于数组的维度。    </p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/DL1.png" alt></p><p>张量的属性：graph、op、name、shape</p><p>tensorflow中张量形状分为动态形状和静态形状，其在于有没有生成一个新的张量数据。静态形状的修改不能跨维度修改</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/DL2.png" alt></p><p>把操作称为节点（OP），所有操作都是一个OP。</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/DL3.png" alt></p><p>整个程序的结构称为图（graph）</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/DL5.png" alt></p><p>运算程序的图称为会话（Session）。一次只能运行一个图</p><p>会话的作用：1、运行图的结构 2、分配资源运算 3、掌握资源</p><p>会话需要进行资源释放，需要run后进行close。否则可以使用with作为上下文管理器</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/DL6.png" alt></p><p>可以在会话当中指定图去运行</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/DL7.png" alt></p><p>sess.run(fetches，feed_dict=None,graph=None)启动整个图。</p><p>用来运行op和计算tensor</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/DL9.png" alt></p><p>feed_dict常与placeholder(占位符)一起使用</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/20190809123839.png" alt></p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/DL8.png" alt></p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/DL10.png" alt></p><p>变量：tensorflow中的变量也是一种op，是一种特殊的张量能够进行存储持久化，它的值就是张量，默认被训练。其中有个trainable参数默认为True，如果改为False，变量将不再变化。</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/DL11.png" alt></p><h2 id="tf-reduce-mean"><a href="#tf-reduce-mean" class="headerlink" title="tf.reduce_mean()"></a>tf.reduce_mean()</h2><p>函数用于计算张量tensor沿着指定的数轴（tensor的某一维度）上的的平均值，主要用作降维或者计算tensor（图像）的平均值。</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/DL12.png" alt></p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/DL13.png" alt></p><p>如果想设置为原来向量的维度，keep_dims=True。</p><h2 id="图的可视化（tensorboard）"><a href="#图的可视化（tensorboard）" class="headerlink" title="图的可视化（tensorboard）"></a>图的可视化（tensorboard）</h2><p>首先通过pip安装，而后在会话中进行写入事件。</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/DL14.png" alt></p><p>最后在命令行启动</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/DL15.png" alt></p><p>双引号中间填绝对路径，注意不要出现中文和空格。</p><h2 id="变量作用域："><a href="#变量作用域：" class="headerlink" title="变量作用域："></a>变量作用域：</h2><p>让模型更直观的显示。</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/DL16.png" alt></p><h2 id="深度学习中的线性回归："><a href="#深度学习中的线性回归：" class="headerlink" title="深度学习中的线性回归："></a>深度学习中的线性回归：</h2><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/DL17.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;tensorflow基本知识&quot;&gt;&lt;a href=&quot;#tensorflow基本知识&quot; class=&quot;headerlink&quot; title=&quot;tensorflow基本知识&quot;&gt;&lt;/a&gt;tensorflow基本知识&lt;/h2&gt;&lt;p&gt;在tensorflow中把数据称为张量（te
      
    
    </summary>
    
      <category term="python" scheme="http://yoursite.com/categories/python/"/>
    
      <category term="深度学习" scheme="http://yoursite.com/categories/python/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="深度学习（1）" scheme="http://yoursite.com/categories/python/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%EF%BC%881%EF%BC%89/"/>
    
    
      <category term="深度学习" scheme="http://yoursite.com/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>机器学习（2）</title>
    <link href="http://yoursite.com/2019/08/09/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%882%EF%BC%89/"/>
    <id>http://yoursite.com/2019/08/09/机器学习（2）/</id>
    <published>2019-08-09T03:48:50.000Z</published>
    <updated>2019-08-09T04:07:48.826Z</updated>
    
    <content type="html"><![CDATA[<h2 id="模型的保存和加载"><a href="#模型的保存和加载" class="headerlink" title="模型的保存和加载"></a>模型的保存和加载</h2><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/ML40.png" alt></p><p>joblib.dump():保存模型，第一个参数是估计器，第二个参数是保存模型的目录。模型的文件格式是pkl。</p><p>joblib.load()：读取模型。参数是模型的目录</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/ML56.png" alt></p><h2 id="线性回归"><a href="#线性回归" class="headerlink" title="线性回归"></a>线性回归</h2><p>线性回归通过一个或多个自变量和因变量之间进行建模的回归分析，其中可以为一个或多个自变量之间的线性组合</p><p>公式:h(w)=w0+w1x+w2x2+…</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/ML42.png" alt></p><p>正规方程和梯度下降的性能评估：均方误差</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/ML43.png" alt></p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/ML45.png" alt></p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/ML44.png" alt></p><p>过拟合：一个假设在训练数据上能够获得比其他假设更好的拟合，但是在训练数据外的数据集上却不能很好地拟合数据，此时认为这个假设出现了过拟合的现象。(模型过于复杂)</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/ML46.png" alt></p><p>解决方法：正则化。用岭回归实现</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/ML47.png" alt></p><p>欠拟合：一个假设在训练数据上不能获得更好的拟合，但是在训练数据外的数据集上也不能很好地拟合数据。此时认为这个假设出现了欠拟合的现象。(模型过于简单) 解决办法是添加数据的特征数量。</p><h2 id="分类算法-逻辑回归"><a href="#分类算法-逻辑回归" class="headerlink" title="分类算法-逻辑回归"></a>分类算法-逻辑回归</h2><p>解决二分类问题</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/ML48.png" alt></p><p>penalty是正则化的方式是l2，C是正则化力度</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/ML49.png" alt></p><h2 id="k—means"><a href="#k—means" class="headerlink" title="k—means"></a>k—means</h2><p>k代表数据划分为几个类别</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/ML50.png" alt></p><p>聚类评估标准：轮廓系数，范围在[-1,1]越接近1，效果越好</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/ML51.png" alt></p><h2 id="精确率和召回率"><a href="#精确率和召回率" class="headerlink" title="精确率和召回率"></a>精确率和召回率</h2><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/ML52.png" alt></p><p>分类模型评估API：F1-score,反应了模型的稳健性</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/ML53.png" alt></p><p>模型选择和调优：1、交叉验证 2、网格搜索</p><p>交叉验证为了让被评估的模型更加准确可信</p><p>网格搜索是用来调参数的。通常情况下，有很多参数是需要手动指定的（如k-近邻算法的k）但是手动过于繁杂。所以需要对模型预设几种超参数组合，每组超参数都采用交叉验证来进行评估。</p><p>sklearn.model_Selection.GridSearchCV</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/ML54.png" alt></p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/ML55.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;模型的保存和加载&quot;&gt;&lt;a href=&quot;#模型的保存和加载&quot; class=&quot;headerlink&quot; title=&quot;模型的保存和加载&quot;&gt;&lt;/a&gt;模型的保存和加载&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Br
      
    
    </summary>
    
      <category term="python" scheme="http://yoursite.com/categories/python/"/>
    
      <category term="机器学习" scheme="http://yoursite.com/categories/python/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="机器学习（2）" scheme="http://yoursite.com/categories/python/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%882%EF%BC%89/"/>
    
    
      <category term="机器学习" scheme="http://yoursite.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>机器学习（1）</title>
    <link href="http://yoursite.com/2019/08/09/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%881%EF%BC%89/"/>
    <id>http://yoursite.com/2019/08/09/机器学习（1）/</id>
    <published>2019-08-09T03:22:57.000Z</published>
    <updated>2019-08-09T03:48:20.778Z</updated>
    
    <content type="html"><![CDATA[<h2 id="机器学习算法分类"><a href="#机器学习算法分类" class="headerlink" title="机器学习算法分类"></a>机器学习算法分类</h2><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/20190809112544.png" alt></p><p>区分监督学习和非监督学习的方法：看是否有标准答案。无监督学习无标准答案，只有特征值。</p><p>区分分类问题和回归问题的方法:目标值是否是离散型。目标值是离散型，则是分类问题。目标值是连续型，则是回归问题。</p><h2 id="数据分割"><a href="#数据分割" class="headerlink" title="数据分割"></a>数据分割</h2><p>模型=算法+数据    数据分为训练集和测试集</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/ML24.png" alt></p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/ML25.png" alt></p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/ML26.png" alt></p><p>fit_transform=fit+transform：fit做的是计算平均值和标准差，transform做的是转化</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/ML27.png" alt></p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/ML28.png" alt></p><h2 id="分类算法-k近邻算法-KNN-："><a href="#分类算法-k近邻算法-KNN-：" class="headerlink" title="分类算法-k近邻算法(KNN)："></a>分类算法-k近邻算法(KNN)：</h2><p>如果一个样本在特征空间中的k个最相似(即特征空间中最邻近)的样本中的大多数属于某一个类别，则该样本也属于这个类别。</p><p>如何求距离：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/ML29.png" alt></p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/ML30.png" alt></p><p>k值取很小，容易受异常点影响</p><p>k值取很大,容易受k值数量的波动</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/ML31.png" alt></p><h2 id="分类算法—朴素贝叶斯"><a href="#分类算法—朴素贝叶斯" class="headerlink" title="分类算法—朴素贝叶斯"></a>分类算法—朴素贝叶斯</h2><p>朴素代表特征独立,不需要调参。这是基于概率的预测</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/ML39.png" alt></p><p>这里的C代表类别，W代表特征。</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/ML33.png" alt></p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/ML32.png" alt></p><h2 id="决策树"><a href="#决策树" class="headerlink" title="决策树"></a>决策树</h2><p>信息熵：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/ML34.png" alt></p><p>信息增益：就是熵和特征条件熵的差</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/ML35.png" alt></p><p>随机变量的不确定性（熵）越小，信息增益越大，这个特征的表现就越好</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/ML36.png" alt></p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/ML37.png" alt></p><p>随机森林：随机森林是一个包含多个决策树的分类器，并且其输出的类别是由个别树输出的类别的众数而定。</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/ML38.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;机器学习算法分类&quot;&gt;&lt;a href=&quot;#机器学习算法分类&quot; class=&quot;headerlink&quot; title=&quot;机器学习算法分类&quot;&gt;&lt;/a&gt;机器学习算法分类&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Br
      
    
    </summary>
    
      <category term="python" scheme="http://yoursite.com/categories/python/"/>
    
      <category term="机器学习" scheme="http://yoursite.com/categories/python/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="机器学习（1）" scheme="http://yoursite.com/categories/python/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%881%EF%BC%89/"/>
    
    
      <category term="机器学习" scheme="http://yoursite.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
</feed>
