<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>DY的个人博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-08-12T01:59:18.140Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>湛蓝星空</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>opencv颜色识别</title>
    <link href="http://yoursite.com/2019/08/12/opencv%E9%A2%9C%E8%89%B2%E8%AF%86%E5%88%AB/"/>
    <id>http://yoursite.com/2019/08/12/opencv颜色识别/</id>
    <published>2019-08-12T01:18:09.000Z</published>
    <updated>2019-08-12T01:59:18.140Z</updated>
    
    <content type="html"><![CDATA[<p>   数字图像处理中常用的采用模型是RGB（红，绿，蓝）模型和HSV（色调，饱和度，亮度），RGB广泛应用于彩色监视器和彩色视频摄像机，我们平时的图片一般都是RGB模型。而HSV模型更符合人描述和解释颜色的方式，HSV的彩色描述对人来说是自然且非常直观的。</p><p>颜色识别步骤：</p><p>1、读取一张图片或视频.</p><p>2、用cvtcolor将它从RGB转为HSV。</p><p>3、通过inrange得出掩膜。</p><p>4、用 图像的”与”操作(bitwise_and)得出对应区域的图像。</p><p>coding：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/color.png" alt></p><p>读者可以加一些其他的操作提高效果，例如什么开运算、滤波之类的。这里就不赘述了，接下来，贴一张HSV的颜色与制图，可以参考：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/color2.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;   数字图像处理中常用的采用模型是RGB（红，绿，蓝）模型和HSV（色调，饱和度，亮度），RGB广泛应用于彩色监视器和彩色视频摄像机，我们平时的图片一般都是RGB模型。而HSV模型更符合人描述和解释颜色的方式，HSV的彩色描述对人来说是自然且非常直观的。&lt;/p&gt;
&lt;p&gt;颜
      
    
    </summary>
    
      <category term="python" scheme="http://yoursite.com/categories/python/"/>
    
      <category term="opencv" scheme="http://yoursite.com/categories/python/opencv/"/>
    
      <category term="颜色识别" scheme="http://yoursite.com/categories/python/opencv/%E9%A2%9C%E8%89%B2%E8%AF%86%E5%88%AB/"/>
    
    
      <category term="颜色识别" scheme="http://yoursite.com/tags/%E9%A2%9C%E8%89%B2%E8%AF%86%E5%88%AB/"/>
    
  </entry>
  
  <entry>
    <title>魔法方法</title>
    <link href="http://yoursite.com/2019/08/10/%E9%AD%94%E6%B3%95%E6%96%B9%E6%B3%95/"/>
    <id>http://yoursite.com/2019/08/10/魔法方法/</id>
    <published>2019-08-10T01:34:31.000Z</published>
    <updated>2019-08-10T02:12:25.513Z</updated>
    
    <content type="html"><![CDATA[<p>​    魔法方法是指Python内部已经包含的，被双下划线所包围的方法，这些方法在进行特定的操作时会自动被调用。使用Python的魔法方法可以是Python的自由度变得更高，当不需要重写魔法方法也可以在规定的默认情况下生效。在需要重写时也可以让使用者根据自己的需求来重写部分方法来达到自己的期待。</p><h2 id="常用的魔法方法："><a href="#常用的魔法方法：" class="headerlink" title="常用的魔法方法："></a>常用的魔法方法：</h2><p>__doc__：表示类的描述信息</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/magic1.png" alt></p><p>__module__:表示当前操作的对象在哪个模块</p><p>__class__:表示当前操作的对象的类是什么</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/magic2.png" alt></p><p>__call__：让对象直接调用call方法</p><p>__dict__：类或对象的所有属性</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/magic3.png" alt></p><p>__getitem__、__setitem__、__delitem__：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/magic4.png" alt></p><h2 id="魔法方法集合"><a href="#魔法方法集合" class="headerlink" title="魔法方法集合"></a>魔法方法集合</h2><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/magic5.png" alt></p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/magic6.png" alt></p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/magic7.png" alt></p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/magic8.png" alt></p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/magic9.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;​    魔法方法是指Python内部已经包含的，被双下划线所包围的方法，这些方法在进行特定的操作时会自动被调用。使用Python的魔法方法可以是Python的自由度变得更高，当不需要重写魔法方法也可以在规定的默认情况下生效。在需要重写时也可以让使用者根据自己的需求来重写部
      
    
    </summary>
    
      <category term="python" scheme="http://yoursite.com/categories/python/"/>
    
      <category term="魔法方法" scheme="http://yoursite.com/categories/python/%E9%AD%94%E6%B3%95%E6%96%B9%E6%B3%95/"/>
    
    
      <category term="魔法方法" scheme="http://yoursite.com/tags/%E9%AD%94%E6%B3%95%E6%96%B9%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>深度学习（3）</title>
    <link href="http://yoursite.com/2019/08/09/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%EF%BC%883%EF%BC%89/"/>
    <id>http://yoursite.com/2019/08/09/深度学习（3）/</id>
    <published>2019-08-09T05:03:29.000Z</published>
    <updated>2019-08-09T05:09:52.613Z</updated>
    
    <content type="html"><![CDATA[<p>​    感知机：有n个输入数据，通过权重与各数据之间的计算和，比较激活函数结果，得出输出。感知机是解决分类问题。</p><p>神经网络的基本组成包括输入层、隐藏层、输出层。卷积神经网络的特点在于隐藏层分为卷积层和池化层。</p><p>神经网络的种类：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/DL30.png" alt></p><p>神经网络的策略是交叉熵损失，优化是通过反向传播算法（相当于梯度下降 ）。</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/DL31.png" alt></p><p>简单神经网络：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/DL32.png" alt></p><p>卷积神经网络：</p><p>卷积层：通过在原始图像上平移来提取特征</p><p>零填充方式：SAME和VALID。</p><p>当填充方式为SAME时：无法取整时，向上取值</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/DL33.png" alt></p><p>当填充方式为VALID时，无法取整时，向上取值</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/DL34.png" alt></p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/DL35.png" alt></p><p>卷积向下取整，池化向上取整</p><p>例：当卷积层100个filter，5*5，步长为1，零填充是2时。输入[28,28,1]大小的图像，输出[26,26,100]的图像。</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/DL36.png" alt></p><p>池化层：通过特征后稀疏参数来减少学习的参数，降低网络的复杂度（最大池化和平均值化）</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/DL37.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;​    感知机：有n个输入数据，通过权重与各数据之间的计算和，比较激活函数结果，得出输出。感知机是解决分类问题。&lt;/p&gt;
&lt;p&gt;神经网络的基本组成包括输入层、隐藏层、输出层。卷积神经网络的特点在于隐藏层分为卷积层和池化层。&lt;/p&gt;
&lt;p&gt;神经网络的种类：&lt;/p&gt;
&lt;p&gt;&lt;
      
    
    </summary>
    
      <category term="python" scheme="http://yoursite.com/categories/python/"/>
    
      <category term="深度学习" scheme="http://yoursite.com/categories/python/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="深度学习（3）" scheme="http://yoursite.com/categories/python/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%EF%BC%883%EF%BC%89/"/>
    
    
      <category term="深度学习" scheme="http://yoursite.com/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>深度学习（2）</title>
    <link href="http://yoursite.com/2019/08/09/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%EF%BC%882%EF%BC%89/"/>
    <id>http://yoursite.com/2019/08/09/深度学习（2）/</id>
    <published>2019-08-09T04:53:25.000Z</published>
    <updated>2019-08-09T05:03:13.437Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数据读取"><a href="#数据读取" class="headerlink" title="数据读取"></a>数据读取</h2><p>通过线程和队列提高速度。可以边取数据边训练</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/DL19.png" alt></p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/DL20.png" alt></p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/DL@1.png" alt></p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/DL21.png" alt></p><h2 id="模型的保存和加载"><a href="#模型的保存和加载" class="headerlink" title="模型的保存和加载"></a>模型的保存和加载</h2><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/DL22.png" alt></p><p>模型保存：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/DL23.png" alt></p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/DL24.png" alt></p><p>模型加载：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/DL25.png" alt></p><h2 id="添加权重参数、损失值等的变化"><a href="#添加权重参数、损失值等的变化" class="headerlink" title="添加权重参数、损失值等的变化"></a>添加权重参数、损失值等的变化</h2><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/DL26.png" alt></p><p>首先收集变量：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/DL27.png" alt></p><p>而后在会话中运行：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/DL28.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;数据读取&quot;&gt;&lt;a href=&quot;#数据读取&quot; class=&quot;headerlink&quot; title=&quot;数据读取&quot;&gt;&lt;/a&gt;数据读取&lt;/h2&gt;&lt;p&gt;通过线程和队列提高速度。可以边取数据边训练&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubuserc
      
    
    </summary>
    
      <category term="python" scheme="http://yoursite.com/categories/python/"/>
    
      <category term="深度学习" scheme="http://yoursite.com/categories/python/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="深度学习（2）" scheme="http://yoursite.com/categories/python/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%EF%BC%882%EF%BC%89/"/>
    
    
      <category term="深度学习" scheme="http://yoursite.com/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>深度学习（1）</title>
    <link href="http://yoursite.com/2019/08/09/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%EF%BC%881%EF%BC%89/"/>
    <id>http://yoursite.com/2019/08/09/深度学习（1）/</id>
    <published>2019-08-09T04:17:39.000Z</published>
    <updated>2019-08-09T04:52:39.127Z</updated>
    
    <content type="html"><![CDATA[<h2 id="tensorflow基本知识"><a href="#tensorflow基本知识" class="headerlink" title="tensorflow基本知识"></a>tensorflow基本知识</h2><p>在tensorflow中把数据称为张量（tensor）。</p><p>张量的阶：相当于数组的维度。    </p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/DL1.png" alt></p><p>张量的属性：graph、op、name、shape</p><p>tensorflow中张量形状分为动态形状和静态形状，其在于有没有生成一个新的张量数据。静态形状的修改不能跨维度修改</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/DL2.png" alt></p><p>把操作称为节点（OP），所有操作都是一个OP。</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/DL3.png" alt></p><p>整个程序的结构称为图（graph）</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/DL5.png" alt></p><p>运算程序的图称为会话（Session）。一次只能运行一个图</p><p>会话的作用：1、运行图的结构 2、分配资源运算 3、掌握资源</p><p>会话需要进行资源释放，需要run后进行close。否则可以使用with作为上下文管理器</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/DL6.png" alt></p><p>可以在会话当中指定图去运行</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/DL7.png" alt></p><p>sess.run(fetches，feed_dict=None,graph=None)启动整个图。</p><p>用来运行op和计算tensor</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/DL9.png" alt></p><p>feed_dict常与placeholder(占位符)一起使用</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/20190809123839.png" alt></p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/DL8.png" alt></p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/DL10.png" alt></p><p>变量：tensorflow中的变量也是一种op，是一种特殊的张量能够进行存储持久化，它的值就是张量，默认被训练。其中有个trainable参数默认为True，如果改为False，变量将不再变化。</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/DL11.png" alt></p><h2 id="tf-reduce-mean"><a href="#tf-reduce-mean" class="headerlink" title="tf.reduce_mean()"></a>tf.reduce_mean()</h2><p>函数用于计算张量tensor沿着指定的数轴（tensor的某一维度）上的的平均值，主要用作降维或者计算tensor（图像）的平均值。</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/DL12.png" alt></p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/DL13.png" alt></p><p>如果想设置为原来向量的维度，keep_dims=True。</p><h2 id="图的可视化（tensorboard）"><a href="#图的可视化（tensorboard）" class="headerlink" title="图的可视化（tensorboard）"></a>图的可视化（tensorboard）</h2><p>首先通过pip安装，而后在会话中进行写入事件。</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/DL14.png" alt></p><p>最后在命令行启动</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/DL15.png" alt></p><p>双引号中间填绝对路径，注意不要出现中文和空格。</p><h2 id="变量作用域："><a href="#变量作用域：" class="headerlink" title="变量作用域："></a>变量作用域：</h2><p>让模型更直观的显示。</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/DL16.png" alt></p><h2 id="深度学习中的线性回归："><a href="#深度学习中的线性回归：" class="headerlink" title="深度学习中的线性回归："></a>深度学习中的线性回归：</h2><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/DL17.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;tensorflow基本知识&quot;&gt;&lt;a href=&quot;#tensorflow基本知识&quot; class=&quot;headerlink&quot; title=&quot;tensorflow基本知识&quot;&gt;&lt;/a&gt;tensorflow基本知识&lt;/h2&gt;&lt;p&gt;在tensorflow中把数据称为张量（te
      
    
    </summary>
    
      <category term="python" scheme="http://yoursite.com/categories/python/"/>
    
      <category term="深度学习" scheme="http://yoursite.com/categories/python/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="深度学习（1）" scheme="http://yoursite.com/categories/python/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%EF%BC%881%EF%BC%89/"/>
    
    
      <category term="深度学习" scheme="http://yoursite.com/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>机器学习（2）</title>
    <link href="http://yoursite.com/2019/08/09/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%882%EF%BC%89/"/>
    <id>http://yoursite.com/2019/08/09/机器学习（2）/</id>
    <published>2019-08-09T03:48:50.000Z</published>
    <updated>2019-08-09T04:07:48.826Z</updated>
    
    <content type="html"><![CDATA[<h2 id="模型的保存和加载"><a href="#模型的保存和加载" class="headerlink" title="模型的保存和加载"></a>模型的保存和加载</h2><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/ML40.png" alt></p><p>joblib.dump():保存模型，第一个参数是估计器，第二个参数是保存模型的目录。模型的文件格式是pkl。</p><p>joblib.load()：读取模型。参数是模型的目录</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/ML56.png" alt></p><h2 id="线性回归"><a href="#线性回归" class="headerlink" title="线性回归"></a>线性回归</h2><p>线性回归通过一个或多个自变量和因变量之间进行建模的回归分析，其中可以为一个或多个自变量之间的线性组合</p><p>公式:h(w)=w0+w1x+w2x2+…</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/ML42.png" alt></p><p>正规方程和梯度下降的性能评估：均方误差</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/ML43.png" alt></p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/ML45.png" alt></p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/ML44.png" alt></p><p>过拟合：一个假设在训练数据上能够获得比其他假设更好的拟合，但是在训练数据外的数据集上却不能很好地拟合数据，此时认为这个假设出现了过拟合的现象。(模型过于复杂)</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/ML46.png" alt></p><p>解决方法：正则化。用岭回归实现</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/ML47.png" alt></p><p>欠拟合：一个假设在训练数据上不能获得更好的拟合，但是在训练数据外的数据集上也不能很好地拟合数据。此时认为这个假设出现了欠拟合的现象。(模型过于简单) 解决办法是添加数据的特征数量。</p><h2 id="分类算法-逻辑回归"><a href="#分类算法-逻辑回归" class="headerlink" title="分类算法-逻辑回归"></a>分类算法-逻辑回归</h2><p>解决二分类问题</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/ML48.png" alt></p><p>penalty是正则化的方式是l2，C是正则化力度</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/ML49.png" alt></p><h2 id="k—means"><a href="#k—means" class="headerlink" title="k—means"></a>k—means</h2><p>k代表数据划分为几个类别</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/ML50.png" alt></p><p>聚类评估标准：轮廓系数，范围在[-1,1]越接近1，效果越好</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/ML51.png" alt></p><h2 id="精确率和召回率"><a href="#精确率和召回率" class="headerlink" title="精确率和召回率"></a>精确率和召回率</h2><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/ML52.png" alt></p><p>分类模型评估API：F1-score,反应了模型的稳健性</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/ML53.png" alt></p><p>模型选择和调优：1、交叉验证 2、网格搜索</p><p>交叉验证为了让被评估的模型更加准确可信</p><p>网格搜索是用来调参数的。通常情况下，有很多参数是需要手动指定的（如k-近邻算法的k）但是手动过于繁杂。所以需要对模型预设几种超参数组合，每组超参数都采用交叉验证来进行评估。</p><p>sklearn.model_Selection.GridSearchCV</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/ML54.png" alt></p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/ML55.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;模型的保存和加载&quot;&gt;&lt;a href=&quot;#模型的保存和加载&quot; class=&quot;headerlink&quot; title=&quot;模型的保存和加载&quot;&gt;&lt;/a&gt;模型的保存和加载&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Br
      
    
    </summary>
    
      <category term="python" scheme="http://yoursite.com/categories/python/"/>
    
      <category term="机器学习" scheme="http://yoursite.com/categories/python/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="机器学习（2）" scheme="http://yoursite.com/categories/python/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%882%EF%BC%89/"/>
    
    
      <category term="机器学习" scheme="http://yoursite.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>机器学习（1）</title>
    <link href="http://yoursite.com/2019/08/09/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%881%EF%BC%89/"/>
    <id>http://yoursite.com/2019/08/09/机器学习（1）/</id>
    <published>2019-08-09T03:22:57.000Z</published>
    <updated>2019-08-09T03:48:20.778Z</updated>
    
    <content type="html"><![CDATA[<h2 id="机器学习算法分类"><a href="#机器学习算法分类" class="headerlink" title="机器学习算法分类"></a>机器学习算法分类</h2><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/20190809112544.png" alt></p><p>区分监督学习和非监督学习的方法：看是否有标准答案。无监督学习无标准答案，只有特征值。</p><p>区分分类问题和回归问题的方法:目标值是否是离散型。目标值是离散型，则是分类问题。目标值是连续型，则是回归问题。</p><h2 id="数据分割"><a href="#数据分割" class="headerlink" title="数据分割"></a>数据分割</h2><p>模型=算法+数据    数据分为训练集和测试集</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/ML24.png" alt></p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/ML25.png" alt></p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/ML26.png" alt></p><p>fit_transform=fit+transform：fit做的是计算平均值和标准差，transform做的是转化</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/ML27.png" alt></p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/ML28.png" alt></p><h2 id="分类算法-k近邻算法-KNN-："><a href="#分类算法-k近邻算法-KNN-：" class="headerlink" title="分类算法-k近邻算法(KNN)："></a>分类算法-k近邻算法(KNN)：</h2><p>如果一个样本在特征空间中的k个最相似(即特征空间中最邻近)的样本中的大多数属于某一个类别，则该样本也属于这个类别。</p><p>如何求距离：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/ML29.png" alt></p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/ML30.png" alt></p><p>k值取很小，容易受异常点影响</p><p>k值取很大,容易受k值数量的波动</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/ML31.png" alt></p><h2 id="分类算法—朴素贝叶斯"><a href="#分类算法—朴素贝叶斯" class="headerlink" title="分类算法—朴素贝叶斯"></a>分类算法—朴素贝叶斯</h2><p>朴素代表特征独立,不需要调参。这是基于概率的预测</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/ML39.png" alt></p><p>这里的C代表类别，W代表特征。</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/ML33.png" alt></p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/ML32.png" alt></p><h2 id="决策树"><a href="#决策树" class="headerlink" title="决策树"></a>决策树</h2><p>信息熵：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/ML34.png" alt></p><p>信息增益：就是熵和特征条件熵的差</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/ML35.png" alt></p><p>随机变量的不确定性（熵）越小，信息增益越大，这个特征的表现就越好</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/ML36.png" alt></p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/ML37.png" alt></p><p>随机森林：随机森林是一个包含多个决策树的分类器，并且其输出的类别是由个别树输出的类别的众数而定。</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/ML38.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;机器学习算法分类&quot;&gt;&lt;a href=&quot;#机器学习算法分类&quot; class=&quot;headerlink&quot; title=&quot;机器学习算法分类&quot;&gt;&lt;/a&gt;机器学习算法分类&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Br
      
    
    </summary>
    
      <category term="python" scheme="http://yoursite.com/categories/python/"/>
    
      <category term="机器学习" scheme="http://yoursite.com/categories/python/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="机器学习（1）" scheme="http://yoursite.com/categories/python/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%881%EF%BC%89/"/>
    
    
      <category term="机器学习" scheme="http://yoursite.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>特征工程</title>
    <link href="http://yoursite.com/2019/08/09/%E7%89%B9%E5%BE%81%E5%B7%A5%E7%A8%8B/"/>
    <id>http://yoursite.com/2019/08/09/特征工程/</id>
    <published>2019-08-09T02:53:28.000Z</published>
    <updated>2019-08-12T01:18:53.519Z</updated>
    
    <content type="html"><![CDATA[<p>​    前些天我把python的处理图像的库——opencv总结了一下，但这终究是传统方法处理图像。现在都是用深度学习网络处理图像。所以，在学深度学习之前，我看了些机器学习的知识。但在看机器学习的算法前，我们先来看看特征工程。</p><p>特征工程三大知识：特征抽取、特征预处理、特征降维。</p><h2 id="特征抽取"><a href="#特征抽取" class="headerlink" title="特征抽取"></a>特征抽取</h2><p>字典特征抽取，把数据中的以字符串标记的数据转化为one-hot编码。</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/ML1.png" alt></p><p>由上面代码可得下面的稀疏（sparse）矩阵：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/ML2.png" alt></p><p>将稀疏矩阵转为矩阵：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/ML3.png" alt></p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/ML4.png" alt></p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/ML6.png" alt></p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/ML7.png" alt></p><p>将矩阵转化为字典：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/ML8.png" alt></p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/ML9.png" alt></p><p>文本特征抽取：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/ML10.png" alt></p><p>和字典特征抽取不一样的是CountVectorizer没有sparse参数，只能通过矩阵的toarray转化为数组</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/ML12.png" alt></p><p>可得：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/ML11.png" alt></p><p><strong>注意：单个字母不统计。因为单个英文字母没有依据</strong></p><p>如果文本是中文，根据需要的词频给文本添加空格。同样，单个字无法统计</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/ML13.png" alt></p><p>利用jieba分词对数据进行one-hot编码：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/ML14.png" alt></p><p>TF-IDF特征抽取：用以评估一个词对于一个文件集或一个语料库中的其中一份文件的重要程度</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/ML15.png" alt></p><h2 id="特征预处理"><a href="#特征预处理" class="headerlink" title="特征预处理"></a>特征预处理</h2><p>数据归一化处理：通过对原始数据进行交换把数据映射到（默认为[0,1]）之间</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/ML16.png" alt></p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/ML17.png" alt></p><p>归一化缺点：注意在特定场景最大值最小值是变化的。另外，最大值与最小值非常容易受异常点的影响，所以这种方法的鲁棒性差，只适合传统精确小数据场景。</p><p>数据标准化处理:通过对原始数据进行变换把数据变换到均值为0，方差为1的范围。</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/ML18.png" alt></p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/ML19.png" alt></p><p>标准化总结：在已有样本足够多的情况下比较稳定，适合现代嘈杂大数据场景</p><p>缺失值处理方法:</p><p>删除：如果每列或者行数据缺失值达到一定比例时，建议放弃整行或者整列</p><p>插补：可以通过缺失值每行或者每列的平均值、中位数来填充</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/ML20.png" alt></p><h2 id="数据降维："><a href="#数据降维：" class="headerlink" title="数据降维："></a>数据降维：</h2><p>减少特征的数量。这里的维度代表特征的个数。两种方法：1.特征选择 2.主成分分析</p><p>特征选择：特征选择就是单纯地从提取到的所有特征中选择部分特征作为训练集特征，特征在选择前和选择后可以改变值、也不改变值。但是选择后的特征维数肯定比选择前小。主要方法：Filter（过滤式）、Embedded（嵌入式）、Wrapper（包裹式）</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/ML21.png" alt></p><p>主成分分析：PCA技术，PCA是一种分析、简化数据集的技术。特征数达到数百才会使用</p><p>目的：是数据维数压缩，尽可能降低原数据的维数，损失少量信息</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/ML22.png" alt></p><p>PCA语法：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/ML23.png" alt></p><p>n_components取值可以是小数和整数：小数的取值范围是0-1，代表降维后的维度是原本维度的0-1倍数，整数的值是降维降几个维。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;​    前些天我把python的处理图像的库——opencv总结了一下，但这终究是传统方法处理图像。现在都是用深度学习网络处理图像。所以，在学深度学习之前，我看了些机器学习的知识。但在看机器学习的算法前，我们先来看看特征工程。&lt;/p&gt;
&lt;p&gt;特征工程三大知识：特征抽取、特
      
    
    </summary>
    
      <category term="python" scheme="http://yoursite.com/categories/python/"/>
    
      <category term="机器学习" scheme="http://yoursite.com/categories/python/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="特征工程" scheme="http://yoursite.com/categories/python/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E7%89%B9%E5%BE%81%E5%B7%A5%E7%A8%8B/"/>
    
    
      <category term="机器学习" scheme="http://yoursite.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>opencv(7)</title>
    <link href="http://yoursite.com/2019/08/09/opencv-7/"/>
    <id>http://yoursite.com/2019/08/09/opencv-7/</id>
    <published>2019-08-09T02:33:14.000Z</published>
    <updated>2019-08-09T02:49:40.038Z</updated>
    
    <content type="html"><![CDATA[<h2 id="直方图"><a href="#直方图" class="headerlink" title="直方图"></a>直方图</h2><p>横坐标：图像中各个像素的灰度级</p><p>纵坐标：具有该灰度级的像素个数</p><p>归一化直方图：</p><p>横坐标：图像中各个像素的灰度级</p><p>纵坐标：出现这个灰度级的概率</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/opencv96.png" alt></p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/opencv97.png" alt></p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/opencv98.png" alt></p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/opencv99.png" alt></p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/opencv100.png" alt></p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/opencv101.png" alt></p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/opencv102.png" alt></p><p>掩膜：通过掩膜可以将一张图的某块区域的直方图画出来</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/opencv103.png" alt></p><p>直方图均值化：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/opencv104.png" alt></p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/opencv105.png" alt></p><p>注意:用cv2.equalizeHist进行直方图均衡化处理时，对彩色图像进行处理时，分通道进行。灰度图像直接均衡化</p><p>利用CLAHE有限对比适应性直方图均衡化，对彩色图像也是分通道进行。灰度图像直接均衡化。</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/opencv106.png" alt></p><h2 id="背景建模："><a href="#背景建模：" class="headerlink" title="背景建模："></a>背景建模：</h2><p>以高斯混合模型为基础的背景/前景分割算法</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/opencv107.png" alt></p><p>apply可以得到前景的掩膜</p><h2 id="傅里叶变换"><a href="#傅里叶变换" class="headerlink" title="傅里叶变换"></a>傅里叶变换</h2><p>补  。。。。。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;直方图&quot;&gt;&lt;a href=&quot;#直方图&quot; class=&quot;headerlink&quot; title=&quot;直方图&quot;&gt;&lt;/a&gt;直方图&lt;/h2&gt;&lt;p&gt;横坐标：图像中各个像素的灰度级&lt;/p&gt;
&lt;p&gt;纵坐标：具有该灰度级的像素个数&lt;/p&gt;
&lt;p&gt;归一化直方图：&lt;/p&gt;
&lt;p&gt;横坐标：图
      
    
    </summary>
    
      <category term="python" scheme="http://yoursite.com/categories/python/"/>
    
      <category term="opencv" scheme="http://yoursite.com/categories/python/opencv/"/>
    
      <category term="opencv(7)" scheme="http://yoursite.com/categories/python/opencv/opencv-7/"/>
    
    
      <category term="视觉处理" scheme="http://yoursite.com/tags/%E8%A7%86%E8%A7%89%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>opencv(6)</title>
    <link href="http://yoursite.com/2019/08/08/opencv-6/"/>
    <id>http://yoursite.com/2019/08/08/opencv-6/</id>
    <published>2019-08-08T07:03:02.000Z</published>
    <updated>2019-08-09T01:51:38.877Z</updated>
    
    <content type="html"><![CDATA[<h2 id="特征提取"><a href="#特征提取" class="headerlink" title="特征提取"></a>特征提取</h2><p>图像特征：可以表达图像中对象的主要信息、并且以此为依据可以从其他未知图像中检测出相似或者相同图像。</p><p>常见的图像特征：边缘、角点、纹理</p><p>角点检测：cv2.cornerHarris()</p><p>img:输入图像</p><p>blockSize：角点检测中要考虑的领域大小</p><p>ksize：Sobel求导中使用的窗口大小</p><p>k：方程参数，参数为[0.04，0.06]</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/opencv83.png" alt></p><p>亚像素级的角点检测：红色是原先的角点，绿色像素是修正后的像素</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/opencv84.png" alt></p><p>适合于跟踪的角点检测：cv2.goodFeaturesToTrack():</p><p>输入灰度图像、检测的角点数目、设置角点的质量水平，0-1之间，低于这个数的都会被忽略、设置两个角点间的最短欧式距离。</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/opencv85.png" alt></p><p>SIFT尺度不变特征变换匹配算法：</p><p>cv2.xfeatures2d.SIFT_create()：创建sift特征器</p><p>sift.detect()可以在图像找到关键点。如果想在图像的特定区域搜索，可以创建一个掩膜图像作为参数。属性如下：</p><p>pt：表示图像中关键点的x坐标和y坐标</p><p>size：表示特征的直径</p><p>angle：表示特征的方向</p><p>response：表示关键点强度</p><p>octave：表示特征所在金字塔的层级</p><p>class_id：表示关键点的ID</p><p>sift.compute():计算关键点的描述符，在sift.detect后使用。</p><p>sift.detectAndCompute()：直接找到关键点并计算出描述符</p><p>cv2.drawKeypoints():</p><p>image:原始图像</p><p>keypoints：特征点向量</p><p>outimage：特征点绘制的画布图像，可以是原图像</p><p>color：绘制的特征点颜色，可以是原图像。</p><p>flags：五种绘制模式：</p><p>DRAW_MATCHES_FLAGS_DRAW_RICH_KEYPOINTS:就会绘制代表关键点大小的圆圈甚至可以绘制除关键点的方向。 </p><p>DEFAULT：只绘制特征点的坐标点,显示在图像上就是一个个小圆点,每个小圆点的圆心坐标都是特征点的坐标。 </p><p>DRAW_OVER_OUTIMG：函数不创建输出的图像,而是直接在输出图像变量空间绘制,要求本身输出图像变量就是一个初始化好了的,size与type都是已经初始化好的变量 </p><p>NOT_DRAW_SINGLE_POINTS：单点的特征点不被绘制 </p><p>DRAW_RICH_KEYPOINTS：绘制特征点的时候绘制的是一个个带有方向的圆,这种方法同时显示图像的坐标,size，和方向,是最能显示特征的一种绘制方式</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/opencv86.png" alt></p><p>SURF：加速稳健特征算法，加快版的SIFT。与SIFT类似</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/opencv87.png" alt></p><p>BRIEF:这是一种特征描述符，他不提供查找特征的方法。所以我们需要使用其他的特征检测器。例如：SIFT或SURF。推荐使用STAR。</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/opencv88.png" alt></p><p>orb检测：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/opencv89.png" alt></p><p>bf暴力匹配：</p><p>cv2.BFMatcher()：创建一个BFMatcher对象。参数：</p><p>​     normType：指定使用的距离测试类型。默认值为cv2.NORM_L2。cv2.NORM_L1也行。这两种适用于SIFT和SURF。对于ORB,BRIEF，应使用cv2.NORM_HAMMING。如果VTA_K==3或4，normType应设置为cv2.NORM_HAMMING2。</p><p>​     crossCheck：默认为False。如果设置为True，匹配条件就会更加严格。</p><p>BFMatcher对象具有两个方法：match()和knnMatch()。第一种方法会返回最佳匹配，第二个方法为每个关键点返回k个最佳匹配（降序排列后取前k个）。</p><p>cv2.drawMatches cv2.drawMatchsKnn：就像使用 cv2.drawKeypoints() 绘制关点一样我们可以使用 cv2.drawMatches()来绘制匹配的点。它会将两幅图像先水平排列然后在最佳匹配的点之间绘制直线从原图像到目标图像。如果前面使用的是BFMatcher.knnMatch()现在我们可以使用函数 cv2.drawMatchsKnn 为每个关键点和它的 k 个最佳匹配点绘制匹配线。如果 k 等于 2就会为每个关键点绘制两条最佳匹配直线。如果我们选择性绘制就给函数传入一个掩模。</p><p> 对ORB描述符进行暴力匹配：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/opencv90.png" alt></p><p>match=bf.match(des1，des2)：返回值是一个DMatch对象列表。具有以下属性：</p><p> DMatch.distance - 描述符之间的距离。越小越好。 </p><p>• DMatch.trainIdx - 目标图像中描述符的索引。</p><p> • DMatch.queryIdx - 查询图像中描述符的索引。</p><p> • DMatch.imgIdx - 目标图像的索引</p><p>对SIFT描述符进行暴力匹配：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/opencv91.png" alt></p><p>FLANN匹配器：</p><p>cv2.FlannBasedMatcher( [, indexParams[, searchParams]] )</p><p>indexParams：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/opencv92.png" alt></p><p>searchParams：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/opencv93.png" alt></p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/opencv94.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;特征提取&quot;&gt;&lt;a href=&quot;#特征提取&quot; class=&quot;headerlink&quot; title=&quot;特征提取&quot;&gt;&lt;/a&gt;特征提取&lt;/h2&gt;&lt;p&gt;图像特征：可以表达图像中对象的主要信息、并且以此为依据可以从其他未知图像中检测出相似或者相同图像。&lt;/p&gt;
&lt;p&gt;常见的图像
      
    
    </summary>
    
      <category term="python" scheme="http://yoursite.com/categories/python/"/>
    
      <category term="opencv" scheme="http://yoursite.com/categories/python/opencv/"/>
    
      <category term="opencv(6)" scheme="http://yoursite.com/categories/python/opencv/opencv-6/"/>
    
    
      <category term="视觉处理" scheme="http://yoursite.com/tags/%E8%A7%86%E8%A7%89%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>opencv(5)</title>
    <link href="http://yoursite.com/2019/08/08/opencv-5/"/>
    <id>http://yoursite.com/2019/08/08/opencv-5/</id>
    <published>2019-08-08T06:35:27.000Z</published>
    <updated>2019-08-08T06:54:48.073Z</updated>
    
    <content type="html"><![CDATA[<h2 id="视频处理"><a href="#视频处理" class="headerlink" title="视频处理"></a>视频处理</h2><p>Videocapture：VideoCapture(args)：如果args=0，则打开摄像头。如果args=路径， 则打开视频源</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/opencv68.png" alt></p><p>摄像头设置和查询：</p><p>调用摄像头读取图像数据，以及使用</p><p>cap.set( propId ， value ) </p><p>cap.get( propId )</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/opencv69.png" alt></p><p>图片合成视频：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/opencv70.png" alt></p><p>视频分解图片：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/opencv71.png" alt></p><h2 id="normalize：归一化函数"><a href="#normalize：归一化函数" class="headerlink" title="normalize：归一化函数"></a>normalize：归一化函数</h2><p>为了消除指标之间的影响，需要对数据进行标准化处理，以解决数据指标之间的可比性</p><p>cv2.normalize(src[, dst[, alpha[, beta[, norm_type[, dtype[, mask]]]]]])</p><p>src:输入数组</p><p>dst:与src大小相同的输出数组</p><p>alpha:下限边界</p><p>beta:上限边界</p><p>norm_type:NORM_MINMAX  NORM_INF  NORM_L1 NORM_L2</p><p>dType:当输出为负时，输出数组具有与src相同的类型。否则，具有与src相同的信道数和深度</p><p>mask:掩膜</p><h2 id="画图"><a href="#画图" class="headerlink" title="画图"></a>画图</h2><p>cv2.rectangle（）：若将五改为-1，则填充整个矩形</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/opencv72.png" alt></p><p>cv2.circle：要画圆的话，只需要指定圆形的中心点坐标和半径大小，颜色和粗细</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/opencv73.png" alt></p><p>cv2.ellispe:一个参数是中心点的位置坐标。下一个参数是长轴和短轴的长度。椭圆沿逆时针方向旋转的角度。椭圆弧沿顺时针方向起始的角度和结束角度，如果是 0 到 360，就是整个椭圆。</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/opencv74.png" alt></p><h2 id="图像金字塔"><a href="#图像金字塔" class="headerlink" title="图像金字塔"></a>图像金字塔</h2><p>我们对同一图像的不同分辨率的子图像处理。比如我们在一幅图像中查找某个目标比如脸，我们不知目标在图像中的尺寸大小。这种情况下我们创建一组图，这些图像是具有不同分率的原始图像。我们把组图像叫做图像字塔简单来就是同一图像的不同分率的子图集合。如果我们把大的图像放在底部最小的放在顶部。看来像一座金字塔，故而得名图像金字塔。 </p><p>图像金字塔：高斯金字塔和拉普拉斯金字塔</p><p>向下采样：将图像缩小，图像信息丢失</p><p>向上采样：将图像放大，图像会变模糊</p><p>向下采样和向上采样不是可逆的，无法将图像变为原始图像。</p><p>向下采样函数：cv2.pyrDown(原始图像)</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/opencv75.png" alt></p><p>向上采样函数：cv2.pyrUP</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/opencv76.png" alt></p><p>拉普拉斯金字塔：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/opencv77.png" alt></p><h2 id="opencv删除窗口："><a href="#opencv删除窗口：" class="headerlink" title="opencv删除窗口："></a>opencv删除窗口：</h2><p>删除所有窗口 ：cv2.destroyAllWindow()        删除指定窗口：cv2.destroyWindow(“original”)</p><p>waitKey(x):参数为等待键盘触发的时间。单位为毫秒。如不输入参数，则输入任意键退出。</p><h2 id="setMouseCallback"><a href="#setMouseCallback" class="headerlink" title="setMouseCallback():"></a>setMouseCallback():</h2><p>event为事件</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/opencv78.png" alt></p><p>x，y代表鼠标位于窗口的（x，y）位置</p><p>flags：代表鼠标的拖曳事件以及鼠标和键盘联合的事件。共有32种</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/opencv79.png" alt></p><p>param：函数指针，标识所相应的事件函数。</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/opencv80.png" alt></p><h2 id="namewindow"><a href="#namewindow" class="headerlink" title="namewindow"></a>namewindow</h2><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/opencv82.png" alt></p><p>WINDOW_NORMAL    用户可以改变窗口的大小；</p><p>WINDOW_AUTOSIZE  窗口大小会根据显示图像自动调整，用户必能手动改变窗口大小；</p><p>WINDOW_OPENGL     支持OpenGL。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;视频处理&quot;&gt;&lt;a href=&quot;#视频处理&quot; class=&quot;headerlink&quot; title=&quot;视频处理&quot;&gt;&lt;/a&gt;视频处理&lt;/h2&gt;&lt;p&gt;Videocapture：VideoCapture(args)：如果args=0，则打开摄像头。如果args=路径， 则打开
      
    
    </summary>
    
      <category term="python" scheme="http://yoursite.com/categories/python/"/>
    
      <category term="opencv" scheme="http://yoursite.com/categories/python/opencv/"/>
    
      <category term="opencv(5)" scheme="http://yoursite.com/categories/python/opencv/opencv-5/"/>
    
    
      <category term="视觉处理" scheme="http://yoursite.com/tags/%E8%A7%86%E8%A7%89%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>opencv(4)</title>
    <link href="http://yoursite.com/2019/08/08/opencv-4/"/>
    <id>http://yoursite.com/2019/08/08/opencv-4/</id>
    <published>2019-08-08T06:15:03.000Z</published>
    <updated>2019-08-08T06:35:15.859Z</updated>
    
    <content type="html"><![CDATA[<h2 id="图像类型转换"><a href="#图像类型转换" class="headerlink" title="图像类型转换"></a>图像类型转换</h2><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/opencv63.png" alt></p><p>cvtColor:颜色空间转换函数</p><p>cv2.cvtColor()支持多种颜色空间之间的转换，其</p><p>需要注意的是cvtColor()函数不能直接将RGB图像转换为二值图像(Binary Image)，需要借助threshold()函数</p><p>HSV中：H为色彩，取值范围是[0,179]，S为饱和度，取值范围是[0,255],V是亮度，取值范围是[0,255]。</p><p>支持的转换类型和转换码如下：</p><p>1、RGB和BGR（opencv默认的彩色图像的颜色空间是BGR）颜色空间的转换</p><p>COLOR_BGR2RGB</p><p>COLOR_RGB2BGR</p><p>COLOR_RGBA2BGRA</p><p>COLOR_BGRA2RGBA</p><p>2、向RGB和BGR图像中增添alpha通道</p><p>COLOR_RGB2RGBA</p><p>COLOR_BGR2BGRA</p><p>3、从RGB和BGR图像中去除alpha通道</p><p>COLOR_RGBA2RGB</p><p>COLOR_BGRA2BGR</p><p>4、从RBG和BGR颜色空间转换到灰度空间</p><p>COLOR_RGB2GRAY</p><p>COLOR_BGR2GRAY</p><p>COLOR_RGBA2GRAY</p><p>COLOR_BGRA2GRAY</p><p>5、从灰度空间转换到RGB和BGR颜色空间</p><p>COLOR_GRAY2RGB</p><p>COLOR_GRAY2BGR</p><p>COLOR_GRAY2RGBA</p><p>COLOR_GRAY2BGRA</p><p>6、RGB和BGR颜色空间与BGR565颜色空间之间的转换</p><p>COLOR_RGB2BGR565</p><p>COLOR_BGR2BGR565</p><p>COLOR_BGR5652RGB</p><p>COLOR_BGR5652BGR</p><p>COLOR_RGBA2BGR565</p><p>COLOR_BGRA2BGR565</p><p>COLOR_BGR5652RGBA</p><p>COLOR_BGR5652BGRA</p><p>7、灰度空间域BGR565之间的转换</p><p>COLOR_GRAY2BGR555</p><p>COLOR_BGR5552GRAY</p><p>8、RGB和BGR颜色空间与CIE XYZ之间的转换</p><p>COLOR_RGB2XYZ</p><p>COLOR_BGR2XYZ</p><p>COLOR_XYZ2RGB</p><p>COLOR_XYZ2BGR</p><p>9、RGB和BGR颜色空间与uma色度（YCrCb空间）之间的转换</p><p>COLOR_RGB2YCrCb</p><p>COLOR_BGR2YCrCb</p><p>COLOR_YCrCb2RGB</p><p>COLOR_YCrCb2BGR</p><p>10、RGB和BGR颜色空间与HSV颜色空间之间的相互转换</p><p>COLOR_RGB2HSV</p><p>COLOR_BGR2HSV</p><p>COLOR_HSV2RGB</p><p>COLOR_HSV2BGR</p><p>11、RGB和BGR颜色空间与HLS颜色空间之间的相互转换</p><p>COLOR_RGB2HLS</p><p>COLOR_BGR2HLS</p><p>COLOR_HLS2RGB</p><p>COLOR_HLS2BGR</p><p>12、RGB和BGR颜色空间与CIE Lab颜色空间之间的相互转换</p><p>COLOR_RGB2Lab</p><p>COLOR_BGR2Lab</p><p>COLOR_Lab2RGB</p><p>COLOR_Lab2BGR</p><p>13、RGB和BGR颜色空间与CIE Luv颜色空间之间的相互转换</p><p>COLOR_RGB2Luv</p><p>COLOR_BGR2Luv</p><p>COLOR_Luv2RGB</p><p>COLOR_Luv2BGR</p><p>14、Bayer格式（raw data）向RGB或BGR颜色空间的转换</p><p>COLOR_BayerBG2RGB</p><p>COLOR_BayerGB2RGB</p><p>COLOR_BayerRG2RGB</p><p>COLOR_BayerGR2RGB</p><p>COLOR_BayerBG2BGR</p><p>COLOR_BayerGB2BGR</p><p>COLOR_BayerRG2BGR</p><p>COLOR_BayerGR2BGR</p><h2 id="inrange："><a href="#inrange：" class="headerlink" title="inrange："></a>inrange：</h2><p>实现二值化功能</p><p>image=cv2.inrance(hsv,lower_red,upper_red)</p><p>第一个参数：hsv指的是原图</p><p>第二个参数：lower_red指的是图像中低于这个lower_red的值，图像值变为0</p><p>第三个参数：upper_red指的是图像中高于这个upper_red的值，图像值变为0</p><p>而在lower_red～upper_red之间的值变成255</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/opencv64.png" alt></p><h2 id="图像中的与、或、异或、非操作"><a href="#图像中的与、或、异或、非操作" class="headerlink" title="图像中的与、或、异或、非操作"></a>图像中的与、或、异或、非操作</h2><p>opencv中的bitwise_not，bitwise_xor，bitwise_or，bitwise_and的使用方法与效果。</p><p>bitwise_and是对二进制数据进行“与”操作，即对图像（灰度图像或彩色图像均可）每个像素值进行二进制“与”操作，1&amp;1=1，1&amp;0=0，0&amp;1=0，0&amp;0=0。</p><p>bitwise_or是对二进制数据进行“或”操作，即对图像（灰度图像或彩色图像均可）每个像素值进行二进制“或”操作，1|1=1，1|0=0，0|1=0，0|0=0。</p><p>bitwise_xor是对二进制数据进行“异或”操作，即对图像（灰度图像或彩色图像均可）每个像素值进行二进制“异或”操作，1^1=0,1^0=1,0^1=1,0^0=0。</p><p>bitwise_not是对二进制数据进行“非”操作，即对图像（灰度图像或彩色图像均可）每个像素值进行二进制“非”操作，<del>1=0，</del>0=1。</p><h2 id="Hough直线变换"><a href="#Hough直线变换" class="headerlink" title="Hough直线变换"></a>Hough直线变换</h2><p>cv2.HoughLines()，返回值就是距离和角度。这个函数的第一个参数是一个二值化图像。第二个和第三个值代表距离和角度的精确度。第四个参数是阈值，只有累加其中的值高于阈值时才被认为是一条直线。</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/opencv65.png" alt></p><p>cv2.HoughLinesP():比上面多两个参数，minLineLength和MaxLineGap。比较简单</p><p>minLineLength：线的最短长度，比这个短的线都忽略</p><p>MaxLineGap：两条线段的最大间断，如果小于此值，这两条直线被看成一条直线</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/opencv66.png" alt></p><h2 id="Hough圆环变换："><a href="#Hough圆环变换：" class="headerlink" title="Hough圆环变换："></a>Hough圆环变换：</h2><p>HoughCircles(image, method, dp, minDist[, circles[, param1[, param2[, minRadius[, maxRadius]]]]])</p><p>image参数表示8位单通道灰度输入图像矩阵。</p><p>method参数表示圆检测方法，目前唯一实现的方法是HOUGH_GRADIENT。</p><p>dp参数表示累加器与原始图像相比的分辨率的反比参数。例如，如果dp = 1，则累加器具有与输入图像相同的分辨率。如果dp=2，累加器分辨率是元素图像的一半，宽度和高度也缩减为原来的一半。</p><p>minDist参数表示检测到的两个圆心之间的最小距离。如果参数太小，除了真实的一个圆圈之外，可能错误地检测到多个相邻的圆圈。如果太大，可能会遗漏一些圆圈。</p><p>circles参数表示检测到的圆的输出向量，向量内第一个元素是圆的横坐标，第二个是纵坐标，第三个是半径大小。</p><p>param1参数表示Canny边缘检测的高阈值，低阈值会被自动置为高阈值的一半。</p><p>param2参数表示圆心检测的累加阈值，参数值越小，可以检测越多的假圆圈，但返回的是与较大累加器值对应的圆圈。</p><p>minRadius参数表示检测到的圆的最小半径。</p><p>maxRadius参数表示检测到的圆的最大半径</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/opencv67.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;图像类型转换&quot;&gt;&lt;a href=&quot;#图像类型转换&quot; class=&quot;headerlink&quot; title=&quot;图像类型转换&quot;&gt;&lt;/a&gt;图像类型转换&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Brickexper
      
    
    </summary>
    
      <category term="python" scheme="http://yoursite.com/categories/python/"/>
    
      <category term="opencv" scheme="http://yoursite.com/categories/python/opencv/"/>
    
      <category term="opencv(4)" scheme="http://yoursite.com/categories/python/opencv/opencv-4/"/>
    
    
      <category term="视觉处理" scheme="http://yoursite.com/tags/%E8%A7%86%E8%A7%89%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>opencv(3)</title>
    <link href="http://yoursite.com/2019/08/08/opencv-3/"/>
    <id>http://yoursite.com/2019/08/08/opencv-3/</id>
    <published>2019-08-08T05:44:27.000Z</published>
    <updated>2019-08-09T02:25:19.615Z</updated>
    
    <content type="html"><![CDATA[<h2 id="图像轮廓"><a href="#图像轮廓" class="headerlink" title="图像轮廓"></a>图像轮廓</h2><p>和图像边缘不一样，边缘不连续。将边缘连接成一个整体构成轮廓。</p><p>提取图像轮廓的方法：先调用cv2.findContours()，后调用cv2.drawCont()</p><p>cv2.findCount函数使用方法:</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/opencv42.png" alt></p><p>参数mode的几种方式：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/opencv43.png" alt></p><p>参数method的几种方法：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/opencv44.png" alt></p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/opencv45.png" alt></p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/opencv46.png" alt></p><h2 id="轮廓特征："><a href="#轮廓特征：" class="headerlink" title="轮廓特征："></a>轮廓特征：</h2><p>cv2.moments()会将计算得到的<strong>矩</strong>以一个字典的形式返回。</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/20190808134950.png" alt></p><p><strong>轮廓面积</strong>可以使用函数 cv2.contourArea() 计算得到</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/opencv47.png" alt></p><p><strong>轮廓周长</strong>：cv2.arcLength(cnt，True) 函数的第二个参数用来指定对象的形状是闭合的(True)，还是打开的。</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/opencv448.png" alt></p><p><strong>轮廓近似</strong>：cv2.approxPolyDP(cnt，epsilon，True)</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/opencv54.png" alt></p><p><strong>凸包</strong>：函数cv2.convexHull() 可以用来检测一个曲线是否具有凸性缺陷并能纠正凸性缺陷。凸性曲线总是凸出来的，至少是平的。如果有地方凹去了就叫做凸性缺陷。</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/opencv49.png" alt></p><p><strong>凸性检测</strong>：cv2.isContourConvex()可以用来检测一个曲线是不是凸的，返回True和False。</p><p><strong>边界矩形</strong>：直边界矩形和旋转的边界矩形。</p><p><strong>直边界矩形</strong>：面积不是最小的。x,y,w,h=cv2.boundingRect()。x,y,为矩形左上角的坐标，w,h为矩形的宽和高</p><p><strong>旋转的边界矩形</strong>：面积最小。考虑了对象的旋转。cv2.minAreaRect())。返回的是一个 Box2D 结构，其中包含矩形左上点的坐标x，y矩形的宽和高w，h以及旋度。但是绘制个矩形矩形的 4 个点可以函数cv2.boxPoints() 获 得。</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/opencv50.png" alt></p><p><strong>最小外接圆</strong>：cv2.minEnlosingCircle()</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/opencv51.png" alt></p><p><strong>椭圆拟合</strong>：旋转边界矩形的内切圆   cv2.fitEllipse(cnt)</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/opencv52.png" alt></p><p><strong>形状匹配</strong>：cv2.matchShape()可以帮我们比较两个形状或轮廓的相似度。返回值越小，匹配越好。</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/opencv53.png" alt></p><h2 id="getStructuringElement"><a href="#getStructuringElement" class="headerlink" title="getStructuringElement"></a>getStructuringElement</h2><p>构建一个核。前面腐蚀膨胀的numpy构建的结构化元素是正方形的</p><p>getStructuringElement  与 Numpy 定义的元素结构是完全一样的这个函数的第一个参数表示内核的形状，有三种形状可以选择。</p><p>矩形：MORPH_RECT;</p><p>交叉形：MORPH_CROSS;</p><p>椭圆形：MORPH_ELLIPSE;</p><p>第二和第三个参数分别是内核的尺寸以及锚点的位置。对于锚点的位置，有默认值（-1,-1），表示锚点位于中心点。element形状唯一依赖锚点位置，其他情况下，锚点只是影响了形态学运算结果的偏移。</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/opencv55.png" alt></p><h2 id="透视变换"><a href="#透视变换" class="headerlink" title="透视变换"></a>透视变换</h2><p>在不同的视觉拍摄同一个物体，会有不同的图像。透视变换就是类似于改变拍摄物体的角度</p><p>仿射变换：由平移、错切、缩放、反转、旋转复合而成，是透视变换的特殊形式</p><p>OpenCV提供了两个变换函数cv2.warpAﬃne(仿射变换)和cv2.warpPerspective(透视变换) ，cv2.warpAﬃne 接收的参数是 2×3 的变换矩阵，而cv2.warpPerspective 接收的参数是 3×3 的变换矩阵。</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/opencv56.png" alt></p><p>函数cv2.warpAﬃne() 的第三个参数的是输出图像的大小。它的格式应是图像的(宽,高)。注意的是图像的宽对应的是列数，高对应的是行数。可以实现图片平移。可以和cv2.getAffineTransform配合使用</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/opencv57.png" alt></p><p>其中两个参数是变换前后的位置关系</p><p>函数cv2.warpPerspective配合cv2.getPerspectiveTransform()使用。同时可以用findHomography返回的单应性矩阵。</p><p>getPersonspectiveTransform得出变换矩阵：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/opencv58.png" alt></p><p>得出变换矩阵以后用warpPerspective()：第一个参数是输入图像，M是变换矩阵，第三个参数是输出图像的大小</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/opencv60.png" alt></p><p>findHomography：提供正确估计的好的匹配被叫做inliers，而其他的叫做outliers。cv2.findHomography()返回一个掩图来指定inline和outline。第一个和第二个参数分别是原图像和目的图像，第三个参数可选为cv2.RANSAC、cv2.LMEDS.第二个参数取值范围在1到10。</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/opencv95..png" alt></p><p>getPerspectiveTransform和findHomography的区别：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/opencv59.png" alt></p><h2 id="旋转：cv2-getRotationMatrix2D"><a href="#旋转：cv2-getRotationMatrix2D" class="headerlink" title="旋转：cv2.getRotationMatrix2D()"></a>旋转：cv2.getRotationMatrix2D()</h2><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/opencv62.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;图像轮廓&quot;&gt;&lt;a href=&quot;#图像轮廓&quot; class=&quot;headerlink&quot; title=&quot;图像轮廓&quot;&gt;&lt;/a&gt;图像轮廓&lt;/h2&gt;&lt;p&gt;和图像边缘不一样，边缘不连续。将边缘连接成一个整体构成轮廓。&lt;/p&gt;
&lt;p&gt;提取图像轮廓的方法：先调用cv2.findCon
      
    
    </summary>
    
      <category term="python" scheme="http://yoursite.com/categories/python/"/>
    
      <category term="opencv" scheme="http://yoursite.com/categories/python/opencv/"/>
    
      <category term="opencv(3)" scheme="http://yoursite.com/categories/python/opencv/opencv-3/"/>
    
    
      <category term="视觉处理" scheme="http://yoursite.com/tags/%E8%A7%86%E8%A7%89%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>opencv(2)</title>
    <link href="http://yoursite.com/2019/08/08/opencv-2/"/>
    <id>http://yoursite.com/2019/08/08/opencv-2/</id>
    <published>2019-08-08T05:12:56.000Z</published>
    <updated>2019-08-08T05:44:13.181Z</updated>
    
    <content type="html"><![CDATA[<p>图像滤波：即在尽量保留图像细节特征的条件下对目标图像的噪声进行抑制，是图像预处理中不可缺少的操作，其处理效果的好坏将直接影响到后续图像处理和分析的有效性和可靠性。</p><h2 id="图像滤波"><a href="#图像滤波" class="headerlink" title="图像滤波"></a>图像滤波</h2><p>图像滤波的目的   a、消除图像中混入的噪声       b、为图像识别抽取出图像特征</p><p><strong>均值滤波</strong>，用blur函数</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/opencv22.png" alt></p><p><strong>方框滤波</strong>：进行归一化处理后，和均值滤波相同。当normalize为零时，不进行归一化处理。当normalize为一时，进行归一化处理（默认）。目标图像深度通常于原始图像一样，值为-1。</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/opencv23.png" alt></p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/opencv24.png" alt></p><p><strong>高斯滤波</strong>：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/opencv25.png" alt></p><p><strong>注意</strong>：ksize：核大小必须为单数        sigmaX、sigmaY：控制权重</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/opencv26.png" alt></p><p><strong>中值滤波</strong>：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/opencv27.png" alt></p><p>两种边缘保留滤波：</p><p><strong>biateraFilter</strong>：能在保持边界清晰的情况下有效的去除噪音</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/opencv28.png" alt></p><p><strong>filter2D</strong>:对2D图像实施低通滤波。去除噪音，模糊图像</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/opencv29.png" alt></p><h2 id="膨胀和腐蚀"><a href="#膨胀和腐蚀" class="headerlink" title="膨胀和腐蚀"></a>膨胀和腐蚀</h2><p>膨胀、腐蚀时用到的kernel的形状一般有下面三种： </p><p>矩形: MORPH_RECT </p><p>交叉形: MORPH_CROSS </p><p>椭圆形: MORPH_ELLIPSE </p><p><strong>图像腐蚀</strong>：调用erode函数</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/opencv30.png" alt></p><p><strong>图像膨胀</strong>：调用dialate</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/opencv31.png" alt></p><p><strong>开运算</strong>：先通过图像腐蚀，后经过图像膨胀可以图像去噪。iteration表示次数</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/opencv32.png" alt></p><p><strong>闭运算</strong>：先是先通过图像膨胀，后经过图像腐蚀</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/opencv33.png" alt></p><p><strong>梯度运算</strong>：图像膨胀-图像腐蚀</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/opencv34.png" alt></p><p><strong>图像礼帽（图像顶帽）</strong>：原始图像-开运算图像，得到噪声图像</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/opencv35.png" alt></p><p><strong>图像黑帽</strong>：闭运算-原始图像</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/opencv36.png" alt></p><h2 id="求梯度"><a href="#求梯度" class="headerlink" title="求梯度"></a>求梯度</h2><p>梯度简单来说就是求导。Sobel，Scharr是求一阶导数或二阶导数。Scharr是对Sobel的优化。Laplacian是求二阶导数。</p><p>Sobel算子：当一个像素右边的值减去左边的值不为零，该像素为边界。</p><p>计算梯度的函数：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/opencv37.png" alt></p><p>ddepth通常取cv2.CV_64F。</p><p>dx=0,dy=1计算y轴的边界,dx=1,dy=0计算x轴的边界。满足条件dx&gt;=0&amp;&amp;dy&gt;=0&amp;&amp;dx+dy=1</p><p>将图像中的负值转为正：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/opencv38.png" alt></p><p>将一个图像的边缘提取出来：如果没有converScaleAbs，所有的负值都会被截断为0.换句话就是把边界丢掉。</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/opencv39.png" alt></p><p>Scharr算子：比sobel算子精准，使用方法基本一样</p><p>计算梯度调用函数：cv2.Scharr(src,ddpetch,dx,dy)</p><p>des=cv2.Scharr(src,ddpetch,dx,dy) 等价于des=cv2.Sobel(src,ddpetch,dx,dy,-1)</p><h2 id="为图像扩边：cv2-copyMakeBorder"><a href="#为图像扩边：cv2-copyMakeBorder" class="headerlink" title="为图像扩边：cv2.copyMakeBorder()"></a>为图像扩边：cv2.copyMakeBorder()</h2><p>src:原图图像</p><p>top,bottom,left,right分别表示在原图四周扩充边缘的大小</p><p>borderType：扩充边缘的类型，就是外插的类型，OpenCV中给出以下几种方式</p><p>  * BORDER_REPLICATE</p><p>  * BORDER_REFLECT</p><p>  * BORDER_REFLECT_101</p><p>  * BORDER_WRAP</p><p>  * BORDER_CONSTANT</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/opencv40.png" alt></p><h2 id="canny函数提取图片边缘"><a href="#canny函数提取图片边缘" class="headerlink" title="canny函数提取图片边缘"></a>canny函数提取图片边缘</h2><p>cv2.canny(img,threshold1,threshold2)    img代表原始图像，threshold1、threshold2为阈值。两个阈值越小，得出图像边缘越详细。反之，边框越边缘。</p><p>提取原理步骤：1、高斯模糊 - GaussianBlur  2、灰度转换 - cvtColor  3、计算梯度 – Sobel/Scharr  4、非最大信号抑制5、高低阈值输出二值图像</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/opencv41.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;图像滤波：即在尽量保留图像细节特征的条件下对目标图像的噪声进行抑制，是图像预处理中不可缺少的操作，其处理效果的好坏将直接影响到后续图像处理和分析的有效性和可靠性。&lt;/p&gt;
&lt;h2 id=&quot;图像滤波&quot;&gt;&lt;a href=&quot;#图像滤波&quot; class=&quot;headerlink&quot; ti
      
    
    </summary>
    
      <category term="python" scheme="http://yoursite.com/categories/python/"/>
    
      <category term="opencv" scheme="http://yoursite.com/categories/python/opencv/"/>
    
      <category term="opencv(2)" scheme="http://yoursite.com/categories/python/opencv/opencv-2/"/>
    
    
      <category term="视觉处理" scheme="http://yoursite.com/tags/%E8%A7%86%E8%A7%89%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>opencv(1)</title>
    <link href="http://yoursite.com/2019/08/08/opencv-1/"/>
    <id>http://yoursite.com/2019/08/08/opencv-1/</id>
    <published>2019-08-08T03:32:09.000Z</published>
    <updated>2019-08-08T05:28:39.361Z</updated>
    
    <content type="html"><![CDATA[<p>​    因为我是对图像处理的方面比较感兴趣的。所以我也是对python的视觉处理模块<strong>opencv</strong>进行了学习。这个模块虽然是传统方法，但还是蛮有用的。而且它有上千个API，我总结了以下我所学到的。开始吧。</p><p>cv2是opencv的扩展模块。</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/opencv1.png" alt>    </p><p>imread第二个参数类型:</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/opencv2.png" alt></p><p>cv2.imwrite:保存图片</p><p><strong>下文中：绝对路径代表绝对路径也行</strong> </p><p>改变图片某行某列的像素：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/opencv3.png" alt></p><p>批量改变图片像素：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/opencv4.png" alt></p><p>获取图像属性：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/opencv5.png" alt></p><p>拆分通道：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/opencv6.png" alt></p><p>合并通道：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/opencv8.png" alt></p><p>图片移位：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/opencv9.png" alt></p><p>将两张图片加在一起：1、取模加法   2、饱和运算</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/opencv10.png" alt></p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/opencv11.png" alt></p><p><strong>注意</strong>：两张图片的大小和类型相等</p><p>减法(subtract)、乘法(multiply)和除法(divide)和加法(add)类似</p><p>图像融合：将两张或两张以上的图片融合到一张图片上</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/20190808132723.png" alt></p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/opencv12.png" alt></p><p>图像缩放（参数必须为整数）：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/opencv13.png" alt></p><p>图像翻转：调用cv2.flip(原始图像，flipcode)</p><p>三种情况：</p><p>filpcode=0：以x轴为对称轴的上下翻转</p><p>flipcode&gt;0:以Y轴为对称轴的左右翻转</p><p>flipcode&lt;0:X、Y轴各翻转一次</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/opencv14.png" alt></p><p>图像颜色反转：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/opencv16.png" alt></p><p>图片打上马赛克：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/opencv17.png" alt></p><p>图片上写字：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/opencv18.png" alt></p><p>图片修补：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/opencv19.png" alt></p><p>图片亮度增强：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/opencv20.png" alt></p><p>图像阈值分割：调用了threshold函数</p><p>五种分割方法：</p><p>二进制阈值化（cv2.THRESH_BINARY）：选定一个阈值，用每一个像素的阈值和该阈值比较，大于该阈值则将该像素阈点值设为最大，若小于该阈值，则将该像素点阈值设为零。</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/opencv21.png" alt></p><p>反二进制阈值化（cv.THRESH_BINARY_INV）：选定一个阈值，用每一个像素的阈值和该阈值比较，大于该阈值则将该像素点的阈值设为零，若小于该阈值，则将该像素点阈值设为最大。</p><p>截断阈值化（cv.THRESH_TRUNC）：选定个阈值，用每一个像素的阈值和该阈值比较，大于该阈值则将该像素点的阈值设为该阈值，小于该阈值的像素点的阈值不变。</p><p>阈值化为0（THRESH_TOZERO）：先选定一个阈值，像素点的灰度值大于该阈值的不进行任何改变；像素点的灰度值小于该阈值的，其灰度值全部变为0。 </p><p>反阈值化为0(THRESH_TOZERO_INV)：先选定一个阈值，像素点的灰度值小于该阈值的不进行任何改变；像素点的灰度值大于该阈值的，其灰度值全部变为0。</p><p>还有另一种阈值分割函数：自适应阈值函数  <strong>cv2.adaptiveThreshold()</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;​    因为我是对图像处理的方面比较感兴趣的。所以我也是对python的视觉处理模块&lt;strong&gt;opencv&lt;/strong&gt;进行了学习。这个模块虽然是传统方法，但还是蛮有用的。而且它有上千个API，我总结了以下我所学到的。开始吧。&lt;/p&gt;
&lt;p&gt;cv2是opencv
      
    
    </summary>
    
      <category term="python" scheme="http://yoursite.com/categories/python/"/>
    
      <category term="opencv" scheme="http://yoursite.com/categories/python/opencv/"/>
    
      <category term="opencv(1)" scheme="http://yoursite.com/categories/python/opencv/opencv-1/"/>
    
    
      <category term="视觉处理" scheme="http://yoursite.com/tags/%E8%A7%86%E8%A7%89%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>时间模块</title>
    <link href="http://yoursite.com/2019/08/08/%E6%97%B6%E9%97%B4%E6%A8%A1%E5%9D%97/"/>
    <id>http://yoursite.com/2019/08/08/时间模块/</id>
    <published>2019-08-08T01:59:51.000Z</published>
    <updated>2019-08-08T03:27:50.758Z</updated>
    
    <content type="html"><![CDATA[<p>​    今天我们来讲一下python里面的时间模块。time 模块提供各种时间相关的功能。在 Python 中，与时间处理有关的模块包括：time，datetime 以及 calendar。</p><p>首先先来一波术语解释：</p><p>时间戳（timestamp）的方式：通常来说，时间戳表示的是从 1970 年 1 月 1 日 00:00:00 开始按秒计算的偏移量（time.gmtime(0)）此模块中的函数无法处理 1970 纪元年以前的日期和时间或太遥远的未来（处理极限取决于 C 函数库，对于 32 位系统来说，是 2038 年）</p><p>UTC（Coordinated Universal Time，世界协调时）也叫格林威治天文时间，是世界标准时间。在中国为 UTC+8</p><p>DST（Daylight Saving Time）即夏令时的意思。一些实时函数的计算精度可能低于它们建议的值或参数，例如在大部分 Unix 系统，时钟一秒钟“滴答”50~100 次</p><p>gmtime()，localtime()和 strptime() 以时间元祖（struct_time）的形式返回。</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/time1.png" alt></p><p><strong>注一</strong>：范围真的是0-61.这是基于历史原因。</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/time2.png" alt></p><p>##time</p><p> <strong>time.altzone</strong>：返回格林威治西部的夏令时地区的偏移秒数；如果该地区在格林威治东部会返回负值（如西欧，包括英国）；对夏令时启用地区才能使用。</p><p> <strong>time.asctime([t])</strong>：接受时间元组并返回一个可读的形式为”Tue Dec 11 18:07:14 2015”（2015年12月11日 周二 18时07分14秒）的 24 个字符的字符串。</p><p><strong>time.clock()</strong>：用以浮点数计算的秒数返回当前的 CPU 时间。用来衡量不同程序的耗时，比 time.time() 更有用。<em>Python 3.3 以后不被推荐，由于该方法依赖操作系统，建议使用 perf_counter() 或 process_time() 代替（一个返回系统运行时间，一个返回进程运行时间，请按照实际需求选择）</em></p><p><strong>time.ctime([secs])</strong> ：作用相当于 asctime(localtime(secs))，未给参数相当于 asctime()</p><p><strong>time.gmtime([secs])</strong>：接收时间辍（1970 纪元年后经过的浮点秒数）并返回格林威治天文时间下的时间元组 t（注：t.tm_isdst 始终为 0）</p><p><strong>time.daylight</strong>：如果夏令时被定义，则该值为非零。</p><p><strong>time.localtime([secs])</strong>：接收时间辍（1970 纪元年后经过的浮点秒数）并返回当地时间下的时间元组 t（t.tm_isdst 可取 0 或 1，取决于当地当时是不是夏令时）</p><p><strong>time.mktime(t)</strong>：接受时间元组并返回时间辍（1970纪元后经过的浮点秒数）</p><p><strong>time.perf_counter()</strong>：返回计时器的精准时间（系统的运行时间），包含整个系统的睡眠时间。由于返回值的基准点是未定义的，所以，只有连续调用的结果之间的差才是有效的。</p><p><strong>time.process_time()</strong> ：返回当前进程执行 CPU 的时间总和，不包含睡眠时间。由于返回值的基准点是未定义的，所以，只有连续调用的结果之间的差才是有效的。</p><p><strong>time.sleep(secs)</strong>：推迟调用线程的运行，secs 的单位是秒。 </p><p><strong>time.clock()</strong>：用以浮点数计算的秒数返回当前的 CPU 时间。用来衡量不同程序的耗时，比 time.time() 更有用。</p><p><em>Python 3.3</em> <em>以后不被推荐，由于该方法依赖操作系统，建议使用</em> <em>perf_counter()</em> <em>或</em> <em>process_time()</em> <em>代替（一个返回系统运行时间，一个返回进程运行时间，请按照实际需求选择）</em></p><p><strong>time.time()</strong>：返回当前时间的时间戳（1970 纪元年后经过的浮点秒数）</p><p><strong>time.timezone</strong>：time.timezone 属性是当地时区（未启动夏令时）距离格林威治的偏移秒数（美洲 &gt;0；大部分欧洲，亚洲，非洲 &lt;= 0）</p><p><strong>time.tzname</strong>：time.tzname 属性是包含两个字符串的元组：第一是当地非夏令时区的名称，第二个是当地的 DST 时区的名称。</p><p><strong>time.strftime(format[, t])</strong> ：把一个代表时间的元组或者 struct_time（如由 time.localtime() 和 time.gmtime() 返回）转化为格式化的时间字符串。如果 t 未指定，将传入 time.localtime()。如果元组中任何一个元素越界，将会抛出 ValueError 异常。</p><p><strong>time.strptime(string[, format])</strong>：把一个格式化时间字符串转化为 struct_time。实际上它和 strftime() 是逆操作</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/time5.png" alt></p><p>format 格式如下：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/time3.png" alt></p><p>注1：“%p”只有与“%I”配合使用才有效果。</p><p>注2：范围真的是*0 ~ 61（你没有看错哦）；60代表闰秒，61是基于历史原因保留。</p><p>注3：当使用 strptime() 函数时，只有当在这年中的周数和天数被确定的时候%U <em>和</em> %W 才会被计算。</p><h2 id="datetime"><a href="#datetime" class="headerlink" title="datetime"></a>datetime</h2><p><strong>datetime.today()</strong>：返回一个表示当前本地时间的 datetime 对象，等同于 datetime.fromtimestamp(time.time())</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/time6.png" alt></p><p><strong>datetime.now(tz=None)</strong>：返回一个表示当前本地时间的 datetime 对象；如果提供了参数 tz，则获取 tz 参数所指时区的本地时间</p><p><strong>datetime.utcnow()</strong>:返回一个当前 UTC 时间的 datetime 对象</p><p><strong>datetime.fromtimestamp(timestamp, tz=None)</strong>: 根据时间戮创建一个 datetime 对象，参数 tz 指定时区信息</p><p><strong>datetime.utcfromtimestamp(timestamp)</strong>: 根据时间戮创建一个 UTC 时间的 datetime 对象</p><p><strong>datetime.fromordinal(ordinal)</strong>: 返回对应 Gregorian 日历时间对应的 datetime 对象</p><p><strong>datetime.combine(date, time)</strong>: 根据参数 date 和 time，创建一个 datetime 对象</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/time10.png" alt></p><p><strong>datetime.strptime(date_string, format)</strong>: 将格式化字符串转换为 datetime 对象</p><p><strong>datetime.timedelta</strong>对象代表两个时间之间的时间差，两个date或datetime对象相减就可以返回一个timedelta对象。</p><p>*<em>datetime.timedelta([days[, seconds[, microseconds[, milliseconds[, minutes[, hours[, weeks]]]]]]]) *</em></p><p>往前算：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/time7.png" alt></p><p>往后算：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/time8.png" alt></p><p><strong>datetime.date()</strong>：返回一个 date 对象datetime.time() - 返回一个 time 对象（tzinfo 属性为 None）</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/time9.png" alt></p><p><strong>datetime.timetz()</strong>： 返回一个 time() 对象（带有 tzinfo 属性）</p><p><strong>datetime.replace([year[, month[, day[, hour[, minute[, second[, microsecond[, tzinfo]]]]]]]])</strong>： 生成一个新的日期对象，用参数指定日期和时间代替原有对象中的属性</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/time11.png" alt></p><p><strong>datetime.astimezone(tz=None)</strong>： 传入一个新的 tzinfo 属性，返回根据新时区调整好的 datetime 对象</p><p><strong>datetime.utcoffset()</strong>：如果 tzinfo 属性是 None，则返回 None；否则返回 self.tzinfo.utcoffset(self)</p><p><strong>datetime.dst()</strong>：如果 tzinfo 属性是 None，则返回 None；否则返回 self.tzinfo.dst(self)</p><p><strong>datetime.tzname()</strong>：如果 tzinfo 属性是 None，则返回 None；否则返回 self.tzinfo.tzname(self)</p><p><strong>datetime.timetuple()</strong>：返回日期对应的 time.struct_time 对象（类似于 time模块的 time.localtime()）</p><p><strong>datetime.utctimetuple()</strong>：返回 UTC 日期对应的 time.struct_time 对象</p><p><strong>datetime.toordinal()</strong>：返回日期对应的 Gregorian Calendar 日期（类似于 self.date().toordinal()）</p><p><strong>datetime.timestamp()</strong>：返回当前时间的时间戳（类似于 <a href="http://bbs.fishc.com/thread-51326-1-1.html" target="_blank" rel="noopener">time 模块</a>的 time.time()）</p><p><strong>datetime.weekday()</strong>：返回 0 ~ 6 表示星期几（星期一是 0，依此类推）</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/time12.png" alt></p><p><strong>datetime.isoweekday()</strong>： 返回 1 ~ 7 表示星期几（星期一是1， 依此类推）</p><p><strong>datetime.isocalendar()</strong> ：返回一个三元组格式 (year, month, day)</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/time13.png" alt></p><p><strong>datetime.isoformat(sep=’T’)</strong>：返回一个 ISO 8601 格式的日期字符串，如 “YYYY-MM-DD” 的字符串</p><p><strong>datetime.__str__()</strong>：对于 date 对象 d 来说，str(d) 相当于 d.isoformat()</p><p><strong>datetime.ctime()</strong>：返回一个表示日期的字符串，相当于 time模块的 time.ctime(time.mktime(d.timetuple()))</p><p><strong>datetime.strftime(format)</strong>:返回自定义格式化字符串表示日期。</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/time14.png" alt></p><p><strong>datetime.__format__(format)</strong>跟 datetime.strftime(format) 一样，这使得调用 str.format() 时可以指定 data 对象的字符串</p><h2 id="calendar"><a href="#calendar" class="headerlink" title="calendar"></a>calendar</h2><p>calendar.calendar(year,w,l,c)(year为年份，w是每日宽度，c为间隔距离，l为每星期行数) 日历</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/time15.png" alt></p><p>*<em>calendar.isleap(year) *</em>：如果是闰年就返回True，否则返回False</p><p><strong>calendar.leapdays(y1,y2)</strong>：返回y1与y2两年间的闰年总数</p><p>*<em>calendar.month(year,month,w,l) *</em>：year代表年份，month代表月日历，每行宽度间隔为w，l是每星期的行数</p><p>*<em>calendar.prcal *</em>：相当于print(calendar.calendar(year,w,l,c))</p><p><strong>calendar.prmonth(year,month,w,l)</strong>：相当于print(calendar.calendar(year,w,l,c))</p><p><strong>calendar.weekday(year,month,day)</strong>： 返回指定日期的日期码，0-6（星期），1-12（月份）</p><p><strong>calendar.firstweekday()</strong>返回当前起始日期的设置</p><p><strong>calendar.setfirstweekday()</strong>：设置每周的起始日期码</p><p><strong>calendar.timegm</strong>(时间元祖) 和time.gmtime相反</p><p><strong>calendar.monthrange(year,month)</strong>：返回两个整数。第一个是该月第一天是星期几的日期码，第二个是该月的日期码。日从0（星期一）到6（星期日）;月从1到12。</p><h2 id="timeit"><a href="#timeit" class="headerlink" title="timeit"></a>timeit</h2><p>测试一个函数的执行时间：timeit.timeit</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/time16.png" alt></p><p>timeit.repeat:返回一个包含了每次实验的执行时间的列表</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/time17.png" alt></p><p>三个时间模块的函数特别多，我也没有一一去试。用到的时候才会深究，各位看官根据自己的情况来试着使用起来吧。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;​    今天我们来讲一下python里面的时间模块。time 模块提供各种时间相关的功能。在 Python 中，与时间处理有关的模块包括：time，datetime 以及 calendar。&lt;/p&gt;
&lt;p&gt;首先先来一波术语解释：&lt;/p&gt;
&lt;p&gt;时间戳（timestamp）
      
    
    </summary>
    
      <category term="python" scheme="http://yoursite.com/categories/python/"/>
    
      <category term="时间管理" scheme="http://yoursite.com/categories/python/%E6%97%B6%E9%97%B4%E7%AE%A1%E7%90%86/"/>
    
    
      <category term="python时间管理" scheme="http://yoursite.com/tags/python%E6%97%B6%E9%97%B4%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>python常用模块（3）</title>
    <link href="http://yoursite.com/2019/08/07/python%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97%EF%BC%883%EF%BC%89/"/>
    <id>http://yoursite.com/2019/08/07/python常用模块（3）/</id>
    <published>2019-08-07T07:01:22.000Z</published>
    <updated>2019-08-07T07:36:34.051Z</updated>
    
    <content type="html"><![CDATA[<h2 id="textwrap"><a href="#textwrap" class="headerlink" title="textwrap"></a>textwrap</h2><p>用来重新格式化文本的输出</p><p>fill() 调整换行符,每行显示给定宽度</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/textwrap1.png" alt></p><p>dedent()：去除缩进</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/textwrap2.png" alt></p><p>indent():给定前缀</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/textwrap3.png" alt></p><p>首行缩进：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/textwrap4.png" alt></p><p>多余的省略号：shorter()</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/wraptext5.png" alt></p><p>wrap():wrap(s,width) 以单词为单位(包括字符)最大长度不超过width个字符</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/wraptext6.png" alt></p><h2 id="itertools"><a href="#itertools" class="headerlink" title="itertools"></a>itertools</h2><p>Python的内建模块itertools提供了非常有用的用于操作迭代对象的函数</p><p><strong>count</strong>()会创建一个无限的迭代器，所以下述代码会打印出自然数序列，根本停不下来，只能按Ctrl+C退出。</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/itertools.png" alt></p><p><strong>cycle()</strong>会把传入的一个序列无限重复下去：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/itertools1.png" alt></p><p><strong>repeat()</strong>负责把一个元素无限重复下去，不过如果提供第二个参数就可以限定重复次数：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/itertools2.png" alt></p><p><strong>chain()</strong>可以把一组迭代对象串联起来，形成一个更大的迭代器：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/itertools3.png" alt></p><p><strong>groupby()</strong>把迭代器中相邻的重复元素挑出来放在一起：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/itertools5.png" alt></p><p>实际上挑选规则是通过函数完成的，只要作用于函数的两个元素返回的值相等，这两个元素就被认为是在一组的，而函数返回值作为组的key。如果我们要忽略大小写分组，就可以让元素’A’和’a’都返回相同的key：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/itertools6.png" alt></p><p><strong>permutations()</strong>:输出输入序列的全排列,考虑顺序</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/itertools7.png" alt></p><p><strong>combinations()</strong>:同上，不过不考虑顺序</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/itertools8.png" alt></p><p><strong>product()</strong>:输出输入序列的笛卡儿积</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/itertools9.png" alt></p><p><strong>compress</strong>：可以对一个序列的筛选结果施加到另一个相关的序列上</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/itertools10.png" alt></p><p><strong>dropwhile()</strong>:筛选满足条件的元素</p><p><strong>islice()</strong>：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/itertools11.png" alt></p><p><strong>zip_longest</strong>：zip可产生元祖。当其中摸个输入序列中没有元素可以继续迭代时，迭代过程结束。所以整个迭代的长度和最短的输入序列相同。</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/itertools12.png" alt></p><p>如果不想这样就用zip_longest：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/itertools13.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;textwrap&quot;&gt;&lt;a href=&quot;#textwrap&quot; class=&quot;headerlink&quot; title=&quot;textwrap&quot;&gt;&lt;/a&gt;textwrap&lt;/h2&gt;&lt;p&gt;用来重新格式化文本的输出&lt;/p&gt;
&lt;p&gt;fill() 调整换行符,每行显示给定宽度&lt;/p&gt;

      
    
    </summary>
    
      <category term="python" scheme="http://yoursite.com/categories/python/"/>
    
      <category term="常用模块" scheme="http://yoursite.com/categories/python/%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/"/>
    
      <category term="常用模块（3）" scheme="http://yoursite.com/categories/python/%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97%EF%BC%883%EF%BC%89/"/>
    
    
      <category term="python常用模块" scheme="http://yoursite.com/tags/python%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/"/>
    
  </entry>
  
  <entry>
    <title>python常用模块（2）</title>
    <link href="http://yoursite.com/2019/08/07/python%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97%EF%BC%882%EF%BC%89/"/>
    <id>http://yoursite.com/2019/08/07/python常用模块（2）/</id>
    <published>2019-08-07T06:27:10.000Z</published>
    <updated>2019-08-07T07:00:53.343Z</updated>
    
    <content type="html"><![CDATA[<h2 id="collection："><a href="#collection：" class="headerlink" title="collection："></a>collection：</h2><p>collections是Python内建的一个集合模块，提供了许多有用的集合类。</p><p><strong>namedtuple</strong>是一个函数，它用来创建一个自定义的tuple对象，并且规定了tuple元素的个数，并可以用属性而不是索引来引用tuple的某个元素。这样一来，我们用namedtuple可以很方便地定义一种数据类型，它具备tuple的不变性，又可以根据属性来引用，使用十分方便。</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/collections1.png" alt></p><p>利用namedtuple定义和使用具名元祖：第一个参数为类名，第二个参数为类的各个字段的名字</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/collections2.png" alt></p><p>具名元祖有些专用的属性：类属性_fields,类方法_make(),实例方法_asdict()</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/collections3.png" alt></p><p>如果需要修改任何属性，可以通过使用nametupled实例的_replace方法来实现。该方法会创建按一个新的命名元祖，并对相应的值进行替换。</p><p><strong>deque</strong>：是为了高效实现插入和删除操作的双向列表，适合用于队列和栈。deque(maxlen=N)创建一个固定长度的队列，当有新记录加入而队列已满时会自动移除最老的那条记录。</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/collections5.png" alt></p><p><strong>defaultdict</strong>:使用dict时，如果引用的Key不存在，就会抛出KeyError。如果希望key不存在时，返回一个默认值，就可以用defaultdict。defaultdict的一个特点就是会自动初始化第一个值。</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/collections6.png" alt></p><p>用defaultdict的效率比不用高:</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/collections7.png" alt></p><p><strong>OrderedDict</strong></p><p>使用dict时，Key是无序的。在对dict做迭代时，我们无法确定Key的顺序。</p><p>如果要保持Key的顺序，可以用OrderedDict。</p><p>OrderDict的大小是普通字典的2倍多，这是由于它额外创建的链表所导致。</p><p>注意，OrderedDict的Key会按照插入的顺序排列，不是Key本身排序：OrderedDict可以实现一个FIFO（先进先出）的dict，当容量超出限制时，先删除最早添加的Key</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/collections8.png" alt></p><p><strong>Counter</strong>：一个简单的计数器</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/collections10.png" alt></p><p>计数器的更新包括增加和减少两种，增加使用update，减少用subtract。</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/collections11.png" alt></p><p>most_common(x):根据x返回频率前x的项。</p><p><strong>itemgetter</strong>：可以通过公共键对字典列表排序。</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/collections12.png" alt></p><p><strong>ChainMap</strong>：可接受多个映射然后再逻辑上是它们表现为一个单独的映射结构。如果有重复的键，那么会采用第一个映射中所对应的值。修改映射的操作总是会作用在列出的第一个映射结构上。</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/collections13.png" alt></p><h2 id="random"><a href="#random" class="headerlink" title="random"></a>random</h2><p>random.random() 产生0-1的随机浮点数</p><p>random.uniform(a, b) 产生指定范围内的随机浮点数</p><p>random.randint(a, b) 产生指定范围内的随机整数</p><p>random.randrange([start], stop[, step]) 从一个指定步长的集合中产生随机数</p><p>random.choice(sequence) 从序列中产生一个随机数</p><p>random.shuffle(x[, random]) 将一个列表中的元素打乱</p><p>random.sample(sequence, k) 从序列中随机获取指定长度的片断</p><h2 id="functools"><a href="#functools" class="headerlink" title="functools"></a>functools</h2><p><strong>reduce(function, sequence, value)</strong>：对sequence中的item顺序迭代调用function，如果有value，还可以作为初始值调用。function接收的参数个数只能为2，先把sequence中第一个值和第二个值当参数传给function，再把function的返回值和第三个值当参数传给function，然后只返回一个结果。</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/functools1.png" alt></p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/functoolss.png" alt></p><p><strong>partial</strong>：基于一个函数创建一个新的可调用对象，把原函数的某些参数固定。</p><p>偏函数：只需要传一次值，后面想传就传</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/functools2.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;collection：&quot;&gt;&lt;a href=&quot;#collection：&quot; class=&quot;headerlink&quot; title=&quot;collection：&quot;&gt;&lt;/a&gt;collection：&lt;/h2&gt;&lt;p&gt;collections是Python内建的一个集合模块，提供了许多有
      
    
    </summary>
    
      <category term="python" scheme="http://yoursite.com/categories/python/"/>
    
      <category term="常用模块" scheme="http://yoursite.com/categories/python/%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/"/>
    
      <category term="常用模块（2）" scheme="http://yoursite.com/categories/python/%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97%EF%BC%882%EF%BC%89/"/>
    
    
      <category term="python常用模块" scheme="http://yoursite.com/tags/python%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/"/>
    
  </entry>
  
  <entry>
    <title>python常用模块（1）</title>
    <link href="http://yoursite.com/2019/08/07/python%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97%EF%BC%881%EF%BC%89/"/>
    <id>http://yoursite.com/2019/08/07/python常用模块（1）/</id>
    <published>2019-08-07T05:51:37.000Z</published>
    <updated>2019-08-07T06:26:32.829Z</updated>
    
    <content type="html"><![CDATA[<p>​    这几年，python大火。其中的一个原因是python的库特别多，而且封装非常好。接下来我来总结以下我用过的一些库，虽然都不是很大的库，但还是有用的。</p><h2 id="json"><a href="#json" class="headerlink" title="json"></a>json</h2><p>json主要执行序列化和反序列化的功能，通过Python的json模块，可以将字符串形式的json数据转化为字典，也可以将Python中的字典数据转化为字符串形式的json数据。</p><p>通过json字符串转为字典 json.loads</p><p>字典转换为json：json.dumps</p><p>json.loads()、dumps解码python json格式 </p><p>json.load、dump加载json格式文件</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/json.png" alt></p><p>pickle使用方法与json一样</p><p>区别：</p><p>json是可以在不同语言之间交换数据的，而pickle只在python之间使用。</p><p>json只能序列化最基本的数据类型，而pickle可以序列化所有的数据类型，包括类，函数都可以序列化。</p><h2 id="hashlib"><a href="#hashlib" class="headerlink" title="hashlib"></a>hashlib</h2><p>该模块提供了常见的摘要算法。如MD5，SHA1……摘要算法又称哈希算法、散列算法，通过一个函数，把任意长度的数据转换为一个长度固定的数据串。</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/20190807140248.png" alt></p><p>摘要算法是一个单向函数，通过摘要函数f()对任意长度的数据data计算出固定长度的摘要digest，目的是发现原始数据是否被改动过。计算f(data)很容易，但通过digest反推data却非常困难，对原始数据做一个字节的修改，都会导致计算出来的摘要不同。</p><h2 id="string"><a href="#string" class="headerlink" title="string"></a>string</h2><p>string.digits:包含数字0-9的字符串</p><p>string.letters:包含所有字母（大写或小写）的字符串</p><p>string.lowercase:包含所有小写字母的字符串</p><p>string.printable:包含所有可打印字符的字符串</p><p>string.punctuation:包含所有标点的字符串</p><p>string.uppercase:包含所有大写字母的字符串</p><p>string.ascii_letters和string.digits方法，其中ascii_letters是生成所有字母，从a-z和A-Z,digits是生成所有数字0-9.</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/string%E6%A8%A1%E5%9D%97.png" alt></p><h2 id="词云"><a href="#词云" class="headerlink" title="词云"></a>词云</h2><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/wordcloud.png" alt></p><h2 id="decimal"><a href="#decimal" class="headerlink" title="decimal"></a>decimal</h2><p>如果期望获得更高的精度（并且愿意牺牲掉一些性能），可以使用decimal模块。</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/decimal.png" alt></p><h2 id="fractions"><a href="#fractions" class="headerlink" title="fractions"></a>fractions</h2><p>模块可以用来处理涉及分数的数学计算问题</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/fractions.png" alt></p><h2 id="copy"><a href="#copy" class="headerlink" title="copy"></a>copy</h2><p>完成深拷贝和浅拷贝</p><p>is和==的区别：==是看值，is看是否指向同一个</p><p>浅拷贝：拷贝内容的地址</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/copy1.png" alt></p><p>深拷贝：开发另一片空间存放要拷贝的内容</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/copy3.png" alt></p><p>copy会判断数据类型是否为可变类型，如元祖为不可变类型，则只会完成浅拷贝。</p><h2 id="fileinput"><a href="#fileinput" class="headerlink" title="fileinput"></a>fileinput</h2><p>可以快速对一个或多个文件进行循环遍历</p><p>fileinput.input([files[, inplace[, backup[, mode[, openhook]]]]]])功能:生成FileInput模块类的实例。能够返回用于for循环遍历的对象。注意:文件名可以提供多个</p><p>inplace：是否返回输出结果到源文件中，默认为零不返回。设置为1时返回。</p><p>backup：备份文件的扩展名</p><p>mode：读写模式。只能时读、写、读写、二进制四种模式。默认是读</p><p>openhook：必须是一个函数，有两个参数，文件名和模式。返回相应的打开文件对象</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/fileinput.png" alt></p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/fileinput2.png" alt></p><p>fileinput.filename()：返回当前正在读取的文件的名称。在读取第一行之前，返回None。</p><p>fileinput.fileno()：返回当前文件的整数“文件描述符”。如果没有打开文件（在第一行之前和文件之间），则返回-1。</p><p>fileinput.lineno()：返回刚读过的行的累计行号。在读取第一行之前，返回0。读取完最后一个文件的最后一行后，返回该行的行号。</p><p>fileinput.filelineno()：返回当前文件中的行号。在读取第一行之前，返回0。读取完最后一个文件的最后一行后，返回该文件中该行的行号。</p><p>fileinput.isfirstline()：如果刚刚读取的行是其文件的第一行，则返回true，否则返回false。</p><p>fileinput.isstdin()：如果读取了最后一行sys.stdin，则返回true，否则返回false。</p><p>fileinput.nextfile()：关闭当前文件，以便下一次迭代将读取下一个文件的第一行（如果有的话）; 未从文件中读取的行将不计入累计行数。直到读取下一个文件的第一行之后才会更改文件名。在读取第一行之前，此功能无效; 它不能用于跳过第一个文件。读取完最后一个文件的最后一行后，此功能无效。</p><p>fileinput.close()关闭序列</p><h2 id="subprocess："><a href="#subprocess：" class="headerlink" title="subprocess："></a>subprocess：</h2><p>subprocess模块可以让我们非常方便地启动一个子进程，然后控制其输入和输出。Popen()建立子进程的时候改变标准输入、标准输出和标准错误，并可以利用subprocess.PIPE将多个子进程的输入和输出连接在一起，构成管道(pipe)</p><p>subprocess.call():父进程等待子进程完成，返回退出信息(returncode，相当于Linux exit code)</p><p>subprocess.check_call():父进程等待子进程完成，返回0，检查退出信息，如果returncode不为0，则举出错误subprocess.CalledProcessError，该对象包含有returncode属性，可用try…except…来检查</p><p>subprocess.check_output():父进程等待子进程完成，返回子进程向标准输出的输出结果，检查退出信息，如果returncode不为0，则举出错误subprocess.CalledProcessError，该对象包含有returncode属性和output属性，output属性为标准输出的输出结果，可用try…except…来检查。</p><p>subprocess.Popen()，以下为参数：</p><p>args：shell命令，可以是字符串，或者序列类型，如list,tuple。</p><p>bufsize：缓冲区大小，可不用关心</p><p>stdin,stdout,stderr：分别表示程序的标准输入，标准输出及标准错误</p><p>shell：与上面方法中用法相同</p><p>cwd：用于设置子进程的当前目录</p><p>env：用于指定子进程的环境变量。如果env=None，则默认从父进程继承环境变量</p><p>universal_newlines：不同系统的的换行符不同，当该参数设定为true时，则表示使用\n作为换行符</p><p>常用方法：</p><p>poll() ： 检查子进程状态</p><p>kill() ： 终止子进程</p><p>send_signal() :向子进程发送信号</p><p>terminate() ： 终止子进程</p><p>communicate:从PIPE中读取PIPE的文本，该方法会阻塞父进程，直到子进程完成</p><p>常用属性：pid：子进程的pid，returncode：子进程的退出码。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;​    这几年，python大火。其中的一个原因是python的库特别多，而且封装非常好。接下来我来总结以下我用过的一些库，虽然都不是很大的库，但还是有用的。&lt;/p&gt;
&lt;h2 id=&quot;json&quot;&gt;&lt;a href=&quot;#json&quot; class=&quot;headerlink&quot; tit
      
    
    </summary>
    
      <category term="python" scheme="http://yoursite.com/categories/python/"/>
    
      <category term="常用模块" scheme="http://yoursite.com/categories/python/%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/"/>
    
      <category term="常用模块（1）" scheme="http://yoursite.com/categories/python/%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97%EF%BC%881%EF%BC%89/"/>
    
    
      <category term="python常用模块" scheme="http://yoursite.com/tags/python%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/"/>
    
  </entry>
  
  <entry>
    <title>元类</title>
    <link href="http://yoursite.com/2019/08/07/%E5%85%83%E7%B1%BB/"/>
    <id>http://yoursite.com/2019/08/07/元类/</id>
    <published>2019-08-07T05:39:47.000Z</published>
    <updated>2019-08-11T05:16:07.546Z</updated>
    
    <content type="html"><![CDATA[<p>​    今天来讲一下python里面较难的一个东西。我学到的python内容里面有两个东西是比较难的，一个是描述符，另一个就是今天讲的元类。</p><p>通过python知识散记我们知道global的功能是将局部变量转为全局变量，接下来要说的是globals()。这个globals()函数会以字典类型返回当前位置的全部全局变量。</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/%E5%85%83%E7%B1%BB4.png" alt></p><p>__builtins__模块是默认加载的，在ipython中打开。</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/%E5%85%83%E7%B1%BB5.png" alt></p><p><strong>python通过类创建对象，通过元类创建类。（类也是对象）</strong></p><p>动态创建类：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/%E5%85%83%E7%B1%BB7.png" alt></p><p>函数choose_class根据name的不同而动态的创建不同的类，但这种做法效率相当low。因为如果类多了就会要很多if-else来判断创建哪个类。</p><p>通过type动态创建类。命名规则：</p><p>type(类名，由父类名称构成的元祖（针对继承的情况，可以为空），包含属性的字典（名称和值）)</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/%E5%85%83%E7%B1%BB1.png" alt></p><p>继承：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/%E5%85%83%E7%B1%BB8.png" alt></p><p>添加实例方法：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/%E5%85%83%E7%B1%BB2.png" alt></p><p>添加类方法：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/%E5%85%83%E7%B1%BB9.png" alt></p><p>添加静态方法：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/%E5%85%83%E7%B1%BB10.png" alt></p><p>元类应用：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/%E5%85%83%E7%B1%BB11.png" alt></p><p>metaclass用来指定按照upper_attr来创建，如果不指定，则默认使用type创建。Foo传到class_name，父类(object)传到class_name，新的字典传到class_attr。</p><p>用类完成以上代码：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/%E5%85%83%E7%B1%BB12.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;​    今天来讲一下python里面较难的一个东西。我学到的python内容里面有两个东西是比较难的，一个是描述符，另一个就是今天讲的元类。&lt;/p&gt;
&lt;p&gt;通过python知识散记我们知道global的功能是将局部变量转为全局变量，接下来要说的是globals()。这个g
      
    
    </summary>
    
      <category term="python" scheme="http://yoursite.com/categories/python/"/>
    
      <category term="元类" scheme="http://yoursite.com/categories/python/%E5%85%83%E7%B1%BB/"/>
    
    
      <category term="python的元类" scheme="http://yoursite.com/tags/python%E7%9A%84%E5%85%83%E7%B1%BB/"/>
    
  </entry>
  
</feed>
