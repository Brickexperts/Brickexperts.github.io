<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>DY的个人博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-08-21T01:05:49.046Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>湛蓝星空</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>SSD系列算法</title>
    <link href="http://yoursite.com/2019/08/21/SSD%E7%B3%BB%E5%88%97%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2019/08/21/SSD系列算法/</id>
    <published>2019-08-21T01:05:48.000Z</published>
    <updated>2019-08-21T01:05:49.046Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>One-stage基本介绍</title>
    <link href="http://yoursite.com/2019/08/20/One-stage%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D/"/>
    <id>http://yoursite.com/2019/08/20/One-stage基本介绍/</id>
    <published>2019-08-20T01:44:40.000Z</published>
    <updated>2019-08-20T09:25:33.086Z</updated>
    
    <content type="html"><![CDATA[<p>​    One-stage也是使用CNN卷积特征，直接回归物体的类别概率和位置坐标值（无region proposal），准确度低、速度相对于Two-stage快。</p><p>One-stage常见算法：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/%E7%9B%AE%E6%A0%8715.png" alt></p><p>One-stage核心组件：</p><p>CNN网络</p><p>CNN网络设计原则：从简到繁到简的卷积神经网    多尺度特征融合的网络    更轻量级的CNN网络</p><p>回归网络    </p><p><strong>One-stage和Two-stage的区别在于是否存在RPN网络。</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;​    One-stage也是使用CNN卷积特征，直接回归物体的类别概率和位置坐标值（无region proposal），准确度低、速度相对于Two-stage快。&lt;/p&gt;
&lt;p&gt;One-stage常见算法：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.gi
      
    
    </summary>
    
      <category term="目标检测" scheme="http://yoursite.com/categories/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/"/>
    
      <category term="One-stage" scheme="http://yoursite.com/categories/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/One-stage/"/>
    
      <category term="One-stage基本介绍" scheme="http://yoursite.com/categories/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/One-stage/One-stage%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D/"/>
    
    
      <category term="One-stage" scheme="http://yoursite.com/tags/One-stage/"/>
    
  </entry>
  
  <entry>
    <title>Two-stage基本介绍</title>
    <link href="http://yoursite.com/2019/08/18/Two-stage%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D/"/>
    <id>http://yoursite.com/2019/08/18/Two-stage基本介绍/</id>
    <published>2019-08-18T09:09:22.000Z</published>
    <updated>2019-08-18T09:36:01.751Z</updated>
    
    <content type="html"><![CDATA[<p>​    Two-stage相对于one-stage准确度高，但是速度相对one-stage慢。</p><p>Two-stage常见算法：RCNN、Fast RCNN、Faster RCNN、Faster RCNN变种。</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/%E7%9B%AE%E6%A0%8714.png" alt></p><p>Two-stage核心组件：</p><p><strong>CNN网络</strong></p><p> CNN网络设计原则：</p><p>从简到繁再到简的卷积神经网</p><p>多尺度特征融合的网络</p><p>更轻量级的CNN网络</p><p><strong>RPN网络</strong></p><p>区域推荐（Anchor机制）</p><p>ROI Pooling</p><p>分类和回归</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;​    Two-stage相对于one-stage准确度高，但是速度相对one-stage慢。&lt;/p&gt;
&lt;p&gt;Two-stage常见算法：RCNN、Fast RCNN、Faster RCNN、Faster RCNN变种。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://
      
    
    </summary>
    
      <category term="目标检测" scheme="http://yoursite.com/categories/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/"/>
    
      <category term="Two-stage算法" scheme="http://yoursite.com/categories/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/Two-stage%E7%AE%97%E6%B3%95/"/>
    
      <category term="Two-stage基本介绍" scheme="http://yoursite.com/categories/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/Two-stage%E7%AE%97%E6%B3%95/Two-stage%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D/"/>
    
    
      <category term="Two-stage" scheme="http://yoursite.com/tags/Two-stage/"/>
    
  </entry>
  
  <entry>
    <title>NMS算法</title>
    <link href="http://yoursite.com/2019/08/18/NMS%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2019/08/18/NMS算法/</id>
    <published>2019-08-18T08:33:12.000Z</published>
    <updated>2019-08-18T08:48:18.449Z</updated>
    
    <content type="html"><![CDATA[<p>​    NMS全称是非极大值抑制算法。</p><p>目的：为了消除多余的框，找到最佳的物体检测的位置。</p><p>思想:选取那些邻域里分数最高的窗口，同时抑制那些分数低的窗口。</p><p>其实NMS的处理不太合理。所以有人提出了Soft-NMS。</p><p>NMS和Soft-NMS的区别：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/%E7%9B%AE%E6%A0%8713.png" alt></p><p>相邻区域内的检测框的分数进行调整而非彻底抑制，从而提高了高检索率情况下的准确率。再低检索率时仍能对物体检测性能有明显提升。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;​    NMS全称是非极大值抑制算法。&lt;/p&gt;
&lt;p&gt;目的：为了消除多余的框，找到最佳的物体检测的位置。&lt;/p&gt;
&lt;p&gt;思想:选取那些邻域里分数最高的窗口，同时抑制那些分数低的窗口。&lt;/p&gt;
&lt;p&gt;其实NMS的处理不太合理。所以有人提出了Soft-NMS。&lt;/p&gt;
&lt;p&gt;
      
    
    </summary>
    
      <category term="目标检测" scheme="http://yoursite.com/categories/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/"/>
    
      <category term="NMS算法" scheme="http://yoursite.com/categories/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/NMS%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="目标检测算法" scheme="http://yoursite.com/tags/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>DPM算法</title>
    <link href="http://yoursite.com/2019/08/18/DPM%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2019/08/18/DPM算法/</id>
    <published>2019-08-18T07:52:34.000Z</published>
    <updated>2019-08-18T08:32:48.720Z</updated>
    
    <content type="html"><![CDATA[<p>​    DPM算法是传统目标检测方法的巅峰。</p><p>步骤：</p><p>1、计算DPM特征图</p><p>2、计算响应图</p><p>3、Latent SVM分类器训练</p><p>4、检测识别</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;​    DPM算法是传统目标检测方法的巅峰。&lt;/p&gt;
&lt;p&gt;步骤：&lt;/p&gt;
&lt;p&gt;1、计算DPM特征图&lt;/p&gt;
&lt;p&gt;2、计算响应图&lt;/p&gt;
&lt;p&gt;3、Latent SVM分类器训练&lt;/p&gt;
&lt;p&gt;4、检测识别&lt;/p&gt;

      
    
    </summary>
    
      <category term="目标检测" scheme="http://yoursite.com/categories/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/"/>
    
      <category term="传统目标检测" scheme="http://yoursite.com/categories/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/%E4%BC%A0%E7%BB%9F%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/"/>
    
      <category term="DPM算法" scheme="http://yoursite.com/categories/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/%E4%BC%A0%E7%BB%9F%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/DPM%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="传统目标检测" scheme="http://yoursite.com/tags/%E4%BC%A0%E7%BB%9F%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/"/>
    
  </entry>
  
  <entry>
    <title>HOG+SVM算法</title>
    <link href="http://yoursite.com/2019/08/18/HOG-SVM%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2019/08/18/HOG-SVM算法/</id>
    <published>2019-08-18T07:36:23.000Z</published>
    <updated>2019-08-18T07:51:56.371Z</updated>
    
    <content type="html"><![CDATA[<p>HOG+SVM算法主要用于行人检测。</p><p>步骤：</p><p>1、提取HOG特征。<strong>如果彩色图需要用HOG特征，则需要先转化为灰度图。</strong></p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/%E7%9B%AE%E6%A0%8711.png" alt></p><p>2、训练SVM分类器</p><p>３、利用滑动窗口提取目标区域，进行分类判断</p><p>4、NMS</p><p>5、输出检测结果</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;HOG+SVM算法主要用于行人检测。&lt;/p&gt;
&lt;p&gt;步骤：&lt;/p&gt;
&lt;p&gt;1、提取HOG特征。&lt;strong&gt;如果彩色图需要用HOG特征，则需要先转化为灰度图。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.
      
    
    </summary>
    
      <category term="目标检测" scheme="http://yoursite.com/categories/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/"/>
    
      <category term="传统目标检测算法" scheme="http://yoursite.com/categories/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/%E4%BC%A0%E7%BB%9F%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E7%AE%97%E6%B3%95/"/>
    
      <category term="HOG+SVM" scheme="http://yoursite.com/categories/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/%E4%BC%A0%E7%BB%9F%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E7%AE%97%E6%B3%95/HOG-SVM/"/>
    
    
      <category term="传统目标检测算法" scheme="http://yoursite.com/tags/%E4%BC%A0%E7%BB%9F%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>VJ算法</title>
    <link href="http://yoursite.com/2019/08/18/VJ%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2019/08/18/VJ算法/</id>
    <published>2019-08-18T07:22:05.000Z</published>
    <updated>2019-08-18T07:36:01.927Z</updated>
    
    <content type="html"><![CDATA[<p>​    VJ算法全称为Viola—Jones，多用于人脸检测。</p><p>步骤：</p><p>1、Haar特征抽取 </p><p>Haar特征分为三类：边缘特征、线性特征、中心特征和对角线特征，组合成特征模板。特征模板内有白色和黑色两种矩形，并定义该模板的特征值为白色矩形像素和减去黑色矩形像素和。Haar特征值反映了图像的灰度变化情况。例如：脸部的一些特征能由矩形特征简单的描述，如：眼睛要比脸颊颜色要深，鼻梁两侧比鼻梁颜色要深，嘴巴比周围颜色要深等。</p><p>2、训练人脸分类器（Adaboost算法等）</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/%E7%9B%AE%E6%A0%879.png" alt></p><p>3、滑动窗口</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;​    VJ算法全称为Viola—Jones，多用于人脸检测。&lt;/p&gt;
&lt;p&gt;步骤：&lt;/p&gt;
&lt;p&gt;1、Haar特征抽取 &lt;/p&gt;
&lt;p&gt;Haar特征分为三类：边缘特征、线性特征、中心特征和对角线特征，组合成特征模板。特征模板内有白色和黑色两种矩形，并定义该模板的特征值为
      
    
    </summary>
    
      <category term="目标检测" scheme="http://yoursite.com/categories/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/"/>
    
      <category term="传统目标检测算法" scheme="http://yoursite.com/categories/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/%E4%BC%A0%E7%BB%9F%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E7%AE%97%E6%B3%95/"/>
    
      <category term="VJ算法" scheme="http://yoursite.com/categories/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/%E4%BC%A0%E7%BB%9F%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E7%AE%97%E6%B3%95/VJ%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="传统目标检测算法" scheme="http://yoursite.com/tags/%E4%BC%A0%E7%BB%9F%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>mysql基础命令</title>
    <link href="http://yoursite.com/2019/08/13/mysql%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/"/>
    <id>http://yoursite.com/2019/08/13/mysql基础命令/</id>
    <published>2019-08-13T01:39:02.000Z</published>
    <updated>2019-08-13T02:19:28.350Z</updated>
    
    <content type="html"><![CDATA[<p>sql语句最后需要以；号结尾，sql语句最后需要以；号结尾，sql语句最后需要以；号结尾。重要的事说三遍。</p><h2 id="数据库操作"><a href="#数据库操作" class="headerlink" title="数据库操作"></a>数据库操作</h2><p>select version()：显示数据库版本</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/mysql34.png" alt></p><p>select now()：显示时间</p><p>show databases：查看所有数据库</p><p>show create database 数据库名：查看创建数据库的语句</p><p>create database 数据库名字：创建数据库</p><p>create database 数据库名字 charset=utf8：创建指定编码格式的数据库</p><p>drop database 数据库名：删除数据库</p><p>use 数据库名：使用数据库</p><p>select database ()：查看当前使用的数据库</p><h2 id="数据表操作"><a href="#数据表操作" class="headerlink" title="数据表操作"></a>数据表操作</h2><p>show tables:查看当前数据库中所有表</p><p>drop table 表名：删除表</p><p>show create table 表名：查看创建表的语句</p><p>create table 表名（字段 类型 约束[，字段 类型 约束]）：创建表</p><p>参数：auto_increment表示自动增长、not null表示不能为空、primary key表示主键、default 默认值</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/mysql35.png" alt></p><p>desc 表名：查看表的状态</p><p>insert into 表名 values()：向表插入数据，按照参数类型写参数</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/mysql33.png" alt></p><p>select * from 表名：查看表中所有的数据</p><p>alter table 表名 add 列名 类型：向表中添加字段</p><p>alter table 表名 modify 列名 类型 约束：不重命列名版</p><p>alter table 表名 change 列的原名 列的新名 类型 约束 ：重命列名版</p><p>alter table 表名 drop 列名：删除字段</p><h2 id="数据的增删改查"><a href="#数据的增删改查" class="headerlink" title="数据的增删改查"></a>数据的增删改查</h2><h3 id="增加"><a href="#增加" class="headerlink" title="增加"></a>增加</h3><p>全列插入：insert into 表名 values(数据)</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/mysql33.png" alt></p><p>主键字段：可以用0 null default 来占位。因为auto_increment是自动增加的</p><p>部分插入：insert into 表名(列名1) values(值1) 没有的值取默认值</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/mysql1.png" alt></p><p>多行插入：insert into 表名 values (数据1)，(数据2)</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/mysql2.png" alt></p><p>update 表名 set 列名 ：整列都改</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/mysql3.png" alt></p><p>update 表名 set  列名  where 条件：根据条件改</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/mysql5.png" alt></p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/mysql6.png" alt></p><p>通过其他表来更新一个表：</p><p>update 其他表 as 新名 inner join 被更新的表 as 新名 on  条件 set 需要改的数据</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/mysql7.png" alt></p><h3 id="查询："><a href="#查询：" class="headerlink" title="查询："></a>查询：</h3><p>select * from 表名：查询整个表，*号代表全部</p><p>select * from 表名 where ：根据条件查询</p><p>select 查询的列名 from 表名：根据列名查询。查询多列时，列名间用,隔开</p><p>select 查询的列名 as 列的新名字 from 表名：将列查询后以新的名字显示出来</p><p>select 表名.列名 from 表名</p><p>select 表的新名字.列名 from 表名 as 表的新名字</p><p>select distinct 列名 from 表名：可以去重，只显示相同数据第一次数据出现的位置</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/mysql8.png" alt></p><h4 id="条件查询："><a href="#条件查询：" class="headerlink" title="条件查询："></a>条件查询：</h4><p>and、or、not都可以用，类似python的语法。判断是否为空，is NULL。</p><h4 id="模糊查询："><a href="#模糊查询：" class="headerlink" title="模糊查询："></a>模糊查询：</h4><p>like ：%代表一个或多个，_代表一个。</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/mysql9.png" alt></p><p>select name from 表名 where name like “%小%”：查询名字中有”小”字的名字</p><p>select name from 表名 where name like “__”：查询两个字的名字</p><p>select name from 表名 where name like “__%”：查询两个字以上的名字</p><h4 id="rlike：利用正则查询"><a href="#rlike：利用正则查询" class="headerlink" title="rlike：利用正则查询"></a>rlike：利用正则查询</h4><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/mysql10.png" alt></p><h4 id="范围查询："><a href="#范围查询：" class="headerlink" title="范围查询："></a>范围查询：</h4><p>in表示在一个非连续的范围内</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/mysql11.png" alt></p><p>between 数字 and 数字表示在一个连续的范围内</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/mysql12.png" alt></p><h3 id="排序：order-by-默认从小到大排序"><a href="#排序：order-by-默认从小到大排序" class="headerlink" title="排序：order by 默认从小到大排序"></a>排序：order by 默认从小到大排序</h3><p>asc：从小到大排</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/mysql13.png" alt></p><p>desc：从大到小排</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/mysql14.png" alt></p><p>如果排序字段相同，我们可以设置多个排序字段。若不设置，默认按照主键大小排。</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/mysql15.png" alt></p><h3 id="聚合函数-count，max，min，avg，sum，round-：不能跟其他字段一起用"><a href="#聚合函数-count，max，min，avg，sum，round-：不能跟其他字段一起用" class="headerlink" title="聚合函数(count，max，min，avg，sum，round)：不能跟其他字段一起用"></a>聚合函数(count，max，min，avg，sum，round)：不能跟其他字段一起用</h3><p>count：计算个数，其他类似</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/mysql16.png" alt></p><p>max：计算最大的</p><p>min：计算最小的</p><p>avg：计算平均值</p><p>sum：求和</p><p>round：四舍五入 ，round(123.23,1)保留一位小数=123.2</p><h3 id="分组：group-by"><a href="#分组：group-by" class="headerlink" title="分组：group by"></a>分组：group by</h3><p>按照性别分组：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/mysql17.png" alt></p><p>配合聚合函数使用计算每种性别的人数：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/mysql18.png" alt></p><p>计算男性的人数：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/mysql19.png" alt></p><p>group_concat():查询同一组的其他字段</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/mysql20.png" alt></p><p>还可以用字符串分割</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/mysql21.png" alt></p><p>having：将达到条件的组输出，可以配合聚合函数一起使用</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/mysql22.png" alt></p><p><strong>having和where的区别：having是在分组后进行筛选，where是在原表的基础上进行筛选</strong></p><h3 id="分页："><a href="#分页：" class="headerlink" title="分页："></a>分页：</h3><p>limit start，count   限制查询出来的数据个数。start代表从哪开始，count 代表查询的数据个数。start默认为0</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/mysql23.png" alt></p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/mysql24.png" alt></p><h3 id="链接查询：内链接、左链接、右链接"><a href="#链接查询：内链接、左链接、右链接" class="headerlink" title="链接查询：内链接、左链接、右链接"></a>链接查询：内链接、左链接、右链接</h3><h4 id="内链接：inner-join-……on"><a href="#内链接：inner-join-……on" class="headerlink" title="内链接：inner join ……on"></a>内链接：inner join ……on</h4><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/mysql25.png" alt></p><p>在两个表中取交集，如果存在则将两表数据合并。不存在则跳过。</p><p>可以利用as化简语句：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/mysql26.png" alt></p><p>可以根据需求修改需要显示的数据：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/mysql27.png" alt></p><p>还可以修改数据显示的位置：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/mysql28.png" alt></p><p>通过某个表的字段排序：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/mysql29.png" alt></p><h4 id="左链接：left-join……on。谁在左边，谁就是左表。"><a href="#左链接：left-join……on。谁在左边，谁就是左表。" class="headerlink" title="左链接：left join……on。谁在左边，谁就是左表。"></a>左链接：left join……on。谁在左边，谁就是左表。</h4><p>查询的结果为两个表匹配到的数据，左表特有的数据，对于右表不存在的数据使用null填充</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/mysql30.png" alt></p><p>将左表特有的数据提取出来：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/mysql31.png" alt></p><h4 id="右链接：right-join……on：类似左表。可以直接将右链接的表中左表和右表的显示交换即可得右链接。"><a href="#右链接：right-join……on：类似左表。可以直接将右链接的表中左表和右表的显示交换即可得右链接。" class="headerlink" title="右链接：right join……on：类似左表。可以直接将右链接的表中左表和右表的显示交换即可得右链接。"></a>右链接：right join……on：类似左表。可以直接将右链接的表中左表和右表的显示交换即可得右链接。</h4><p>自关联：补。。。。</p><p>子查询：查询里嵌套一个查询</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/mysql32.png" alt></p><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><p>删除分为物理删除和逻辑删除：</p><p>物理删除：</p><p>delete from 表名:删除整个表</p><p>delete from 表名 where 条件：删除符合条件的数据</p><p>逻辑删除：（用一个字段表示，这条信息是否还能用）</p><p>alter table 表名 add 字段 类型 default 默认值</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;sql语句最后需要以；号结尾，sql语句最后需要以；号结尾，sql语句最后需要以；号结尾。重要的事说三遍。&lt;/p&gt;
&lt;h2 id=&quot;数据库操作&quot;&gt;&lt;a href=&quot;#数据库操作&quot; class=&quot;headerlink&quot; title=&quot;数据库操作&quot;&gt;&lt;/a&gt;数据库操作&lt;/h2&gt;
      
    
    </summary>
    
      <category term="数据库" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="mysql" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/"/>
    
      <category term="基础命令" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/"/>
    
    
      <category term="mysql" scheme="http://yoursite.com/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>网络知识散记</title>
    <link href="http://yoursite.com/2019/08/13/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E6%95%A3%E8%AE%B0/"/>
    <id>http://yoursite.com/2019/08/13/网络知识散记/</id>
    <published>2019-08-13T01:20:46.000Z</published>
    <updated>2019-08-13T01:28:13.242Z</updated>
    
    <content type="html"><![CDATA[<h2 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h2><p>端口是英文port的意译，可以认为是设备与外界通讯交流的出口。端口可分为虚拟端口和物理端口，其中虚拟端口指计算机内部或交换机路由器内的端口，不可见。例如计算机中的80端口、21端口、23端口等。物理端口又称为接口，是可见端口，计算机背板的RJ45网口，交换机路由器集线器等RJ45端口。电话使用RJ11插口也属于物理端口的范畴。（用来区分哪个进程）   同一台电脑用pid区分进程，不同电脑用端口区分进程。</p><p>端口范围是0到65535</p><p>知名端口是众所周知的端口，范围是0到1023</p><p>动态端口的范围是1024到65535</p><p>查看端口状态：用netstat -an查看</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/net1.png" alt></p><h2 id="TCP-IP协议"><a href="#TCP-IP协议" class="headerlink" title="TCP/IP协议"></a>TCP/IP协议</h2><p>TCP/IP:这不是两个协议，这是一个协议族，包含很多协议。主要是TCP/IP协议。</p><p>四层：物理层、网络层、传输层、应用层</p><p>七层：物理层、链路层、网络层、传输层、 会话层、表示层、应用层</p><h2 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h2><p>用来标记唯一一台电脑。每一个IP地址都包括网络地址和主机地址</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/net2.png" alt></p><p>网络地址相同，则处于同一个网段，主机地址用来标记网里的电脑</p><p>A类网络的IP地址范围为：1.0.0.1－126.255.255.254； </p><p>B类网络的IP地址范围为：128.1.0.1－191.255.255.254； </p><p>C类网络的IP地址范围为：192.0.1.1－223.255.255.254</p><p>1．A类IP地址</p><p>一个A类IP地址由1字节（每个字节是8位）的网络地址和3个字节主机地址组成,即第一段数字范围为1～126。每个A类地址可连接16387064台主机(不能用0(产生冲突)和255(广播地址)，Internet有126个A类地址。</p><p>2．B类IP地址</p><p>一个B类IP地址由2个字节的网络地址和2个字节的主机地址组成，第一段数字范围为128～191。每个B类地址可连接64516(254*254)台主机(不能用0(产生冲突)和255(广播地址))，Internet有16256个B类地址。</p><p>3．C类IP地址</p><p>一个C类地址是由3个字节的网络地址和1个字节的主机地址组成，第一段数字范围为192～223。每个C类地址可连接254台主机(不能用0(产生冲突)和255(广播地址)，Internet有2054512个C类地址。</p><p>4．D类地址用于多点播送。</p><p>第一个字节的数字范围为224～239，是多点播送地址，用于多目的地信息的传输，和作为备用。全零（“0.0.0.0”）地址对应于当前主机，全“1”的IP地址（“255.255.255.255”）是当前子网的广播地址。多播和广播的区别：广播在同一个局域网都能收到，多播是指定那些人可以收得到，其他人收不到，常用于视频会议。</p><p>5.E类地址</p><p>第一段数字范围为240～254。E类地址保留，仅作实验和开发用。</p><p>全零（“0．0．0．0”）地址对应于当前主机。全“1”的IP地址（“255．255．255．255”）是当前子网的广播地址。</p><p>在IP地址3种主要类型里，各保留了3个区域作为私有地址，常见于局域网中。</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/net3.png" alt></p><p>##常用术语</p><p>网络号：网络号等于ip地址和网络掩码按位与操作</p><p>网络掩码（子网掩码）的作用：取网络号、主机号</p><p>两台电脑能通信的前提是处于同一个网络号</p><p>集线器（hub）的作用：实现多台电脑连接在一起，组成一个小型局域网，交换机也是。</p><p>集线器和交换机的区别：集线器是广播发数据，交换机不是每次都是广播，效率高。</p><p>实际地址：代表网卡地址（MAC）。由六个字节组成，前三个字节代表厂商，后三个字节代表厂商生产</p><p>arp：根据ip找mac地址</p><p>rarp：根据mac地址找ip</p><p>icmp：ping的时候用</p><p>arp -a即是查看本地局域网内所有用户ip和mac地址绑定关系的一个命令。</p><p>ARP -d 就是清除缓存中的数据。也是删除ip和mac绑定的项目。</p><p>路由器：连接不同的网络，使他们之间能够通信</p><p>rip：路由解析协议</p><p>mac：标记实际转发数据时的地址</p><p>ip：标记逻辑上的地址</p><p>natmask：和ip地址一起确定网络号</p><p>默认网关：发送的ip不在同一个网段内，那么会把这个数据转发给默认网关。</p><p>为什么TCP比UDP稳定？在TCP中，如果有一方接收到对方的数据，一定会发送ack确认包给对方。而在UDP中，没有这个过程。</p><p>TCP三次握手：确定一定发送数据到对方    四次挥手：调用close时使用</p><p>TCP长连接、短连接：</p><p>TTL：表示经过的路由器数目。每经过一个路由器，TTL-1。</p><p>MSL：表示一个数据包存在的最多时间</p><p>CDN：内容分发</p><p>查看域名解析的IP地址：</p><p>nslookup 域名         例子：nslookup baidu.com</p><p>常见的网络攻击：</p><p>DDOS攻击：拒绝服务器攻击。</p><p>DNS攻击：1.DNS服务器被劫持：篡改IP</p><p>​                  2.DNS欺骗：</p><p>ARP攻击：中间人攻击</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;端口&quot;&gt;&lt;a href=&quot;#端口&quot; class=&quot;headerlink&quot; title=&quot;端口&quot;&gt;&lt;/a&gt;端口&lt;/h2&gt;&lt;p&gt;端口是英文port的意译，可以认为是设备与外界通讯交流的出口。端口可分为虚拟端口和物理端口，其中虚拟端口指计算机内部或交换机路由器内的端口，
      
    
    </summary>
    
      <category term="网络知识" scheme="http://yoursite.com/categories/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/"/>
    
      <category term="知识散记" scheme="http://yoursite.com/categories/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/%E7%9F%A5%E8%AF%86%E6%95%A3%E8%AE%B0/"/>
    
    
      <category term="网络知识散记" scheme="http://yoursite.com/tags/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E6%95%A3%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>目标检测概述</title>
    <link href="http://yoursite.com/2019/08/12/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E6%A6%82%E8%BF%B0/"/>
    <id>http://yoursite.com/2019/08/12/目标检测概述/</id>
    <published>2019-08-12T02:30:19.000Z</published>
    <updated>2019-08-18T07:20:44.266Z</updated>
    
    <content type="html"><![CDATA[<p>​    目标检测方法分为传统目标检测方法和深度学习目标检测方法。</p><p>传统目标检测方法：Viola-Jones、HOG+SVM、DPM等</p><p>Viola-Jones：采用积分图特征，进行人脸检测</p><p>HOG+SVM：行人检测。通过HOG特征结合SVM分类器进行检测。</p><p>DPM：同样通过HOG特征，并加入许多其他额外的策略进行检测。传统目标检测最好的方法。</p><p>深度学习目标检测方法：One-state、Two-stage</p><p>One-stage：YOLO和SSD系列，直接回归目标位置。</p><p>Two-stage：Faster RCNN系列，利用网络对候选区进行推荐。</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/%E7%9B%AE%E6%A0%871.png" alt></p><p>目标检测问题基本流程：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/%E7%9B%AE%E6%A0%8710.png" alt></p><p><strong>Viola-Jones（人脸检测）步骤</strong></p><p>1、Haar特征抽取</p><p>2、训练人脸分类器（Adaboost算法）</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/%E7%9B%AE%E6%A0%872.png" alt></p><p>3、滑动窗口</p><p><strong>HOG+SVM（行人检测）步骤</strong></p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/%E7%9B%AE%E6%A0%873.png" alt></p><p><strong>DPM（物体检测）步骤</strong></p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/%E7%9B%AE%E6%A0%874.png" alt></p><p>NMS（非极大值抑制算法）</p><p>目的：为了消除多余的框，找到最佳的物体检测的位置</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/%E7%9B%AE%E6%A0%87.png" alt></p><p>Soft-NMS是对NMS算法的改进</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/%E7%9B%AE%E6%A0%876.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;​    目标检测方法分为传统目标检测方法和深度学习目标检测方法。&lt;/p&gt;
&lt;p&gt;传统目标检测方法：Viola-Jones、HOG+SVM、DPM等&lt;/p&gt;
&lt;p&gt;Viola-Jones：采用积分图特征，进行人脸检测&lt;/p&gt;
&lt;p&gt;HOG+SVM：行人检测。通过HOG特征结
      
    
    </summary>
    
      <category term="目标检测" scheme="http://yoursite.com/categories/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/"/>
    
      <category term="目标检测概述" scheme="http://yoursite.com/categories/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E6%A6%82%E8%BF%B0/"/>
    
    
      <category term="目标检测" scheme="http://yoursite.com/tags/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/"/>
    
  </entry>
  
  <entry>
    <title>opencv颜色识别</title>
    <link href="http://yoursite.com/2019/08/12/opencv%E9%A2%9C%E8%89%B2%E8%AF%86%E5%88%AB/"/>
    <id>http://yoursite.com/2019/08/12/opencv颜色识别/</id>
    <published>2019-08-12T01:18:09.000Z</published>
    <updated>2019-08-18T01:08:11.659Z</updated>
    
    <content type="html"><![CDATA[<p>   数字图像处理中常用的采用模型是RGB（红，绿，蓝）模型和HSV（色调，饱和度，亮度），RGB广泛应用于彩色监视器和彩色视频摄像机，我们平时的图片一般都是RGB模型。而HSV模型更符合人描述和解释颜色的方式，HSV的彩色描述对人来说是自然且非常直观的。</p><p>这里的颜色识别是指根据人们的意愿提取图片中对应的颜色区域。</p><p>颜色识别步骤：</p><p>1、读取一张图片或视频.</p><p>2、用cvtcolor将它从RGB转为HSV。</p><p>3、通过inrange得出掩膜。</p><p>4、用 图像的”与”操作(bitwise_and)得出对应区域的图像。</p><p>coding：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/color.png" alt></p><p>读者可以加一些其他的操作提高效果，例如什么开运算、滤波之类的。这里就不赘述了，接下来，贴一张HSV的颜色阈值表，可以参考：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/color2.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;   数字图像处理中常用的采用模型是RGB（红，绿，蓝）模型和HSV（色调，饱和度，亮度），RGB广泛应用于彩色监视器和彩色视频摄像机，我们平时的图片一般都是RGB模型。而HSV模型更符合人描述和解释颜色的方式，HSV的彩色描述对人来说是自然且非常直观的。&lt;/p&gt;
&lt;p&gt;这
      
    
    </summary>
    
      <category term="python" scheme="http://yoursite.com/categories/python/"/>
    
      <category term="opencv" scheme="http://yoursite.com/categories/python/opencv/"/>
    
      <category term="颜色识别" scheme="http://yoursite.com/categories/python/opencv/%E9%A2%9C%E8%89%B2%E8%AF%86%E5%88%AB/"/>
    
    
      <category term="颜色识别" scheme="http://yoursite.com/tags/%E9%A2%9C%E8%89%B2%E8%AF%86%E5%88%AB/"/>
    
  </entry>
  
  <entry>
    <title>魔法方法</title>
    <link href="http://yoursite.com/2019/08/10/%E9%AD%94%E6%B3%95%E6%96%B9%E6%B3%95/"/>
    <id>http://yoursite.com/2019/08/10/魔法方法/</id>
    <published>2019-08-10T01:34:31.000Z</published>
    <updated>2019-08-10T02:12:25.513Z</updated>
    
    <content type="html"><![CDATA[<p>​    魔法方法是指Python内部已经包含的，被双下划线所包围的方法，这些方法在进行特定的操作时会自动被调用。使用Python的魔法方法可以是Python的自由度变得更高，当不需要重写魔法方法也可以在规定的默认情况下生效。在需要重写时也可以让使用者根据自己的需求来重写部分方法来达到自己的期待。</p><h2 id="常用的魔法方法："><a href="#常用的魔法方法：" class="headerlink" title="常用的魔法方法："></a>常用的魔法方法：</h2><p>__doc__：表示类的描述信息</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/magic1.png" alt></p><p>__module__:表示当前操作的对象在哪个模块</p><p>__class__:表示当前操作的对象的类是什么</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/magic2.png" alt></p><p>__call__：让对象直接调用call方法</p><p>__dict__：类或对象的所有属性</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/magic3.png" alt></p><p>__getitem__、__setitem__、__delitem__：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/magic4.png" alt></p><h2 id="魔法方法集合"><a href="#魔法方法集合" class="headerlink" title="魔法方法集合"></a>魔法方法集合</h2><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/magic5.png" alt></p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/magic6.png" alt></p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/magic7.png" alt></p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/magic8.png" alt></p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/magic9.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;​    魔法方法是指Python内部已经包含的，被双下划线所包围的方法，这些方法在进行特定的操作时会自动被调用。使用Python的魔法方法可以是Python的自由度变得更高，当不需要重写魔法方法也可以在规定的默认情况下生效。在需要重写时也可以让使用者根据自己的需求来重写部
      
    
    </summary>
    
      <category term="python" scheme="http://yoursite.com/categories/python/"/>
    
      <category term="魔法方法" scheme="http://yoursite.com/categories/python/%E9%AD%94%E6%B3%95%E6%96%B9%E6%B3%95/"/>
    
    
      <category term="魔法方法" scheme="http://yoursite.com/tags/%E9%AD%94%E6%B3%95%E6%96%B9%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>深度学习（3）</title>
    <link href="http://yoursite.com/2019/08/09/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%EF%BC%883%EF%BC%89/"/>
    <id>http://yoursite.com/2019/08/09/深度学习（3）/</id>
    <published>2019-08-09T05:03:29.000Z</published>
    <updated>2019-08-09T05:09:52.613Z</updated>
    
    <content type="html"><![CDATA[<p>​    感知机：有n个输入数据，通过权重与各数据之间的计算和，比较激活函数结果，得出输出。感知机是解决分类问题。</p><p>神经网络的基本组成包括输入层、隐藏层、输出层。卷积神经网络的特点在于隐藏层分为卷积层和池化层。</p><p>神经网络的种类：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/DL30.png" alt></p><p>神经网络的策略是交叉熵损失，优化是通过反向传播算法（相当于梯度下降 ）。</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/DL31.png" alt></p><p>简单神经网络：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/DL32.png" alt></p><p>卷积神经网络：</p><p>卷积层：通过在原始图像上平移来提取特征</p><p>零填充方式：SAME和VALID。</p><p>当填充方式为SAME时：无法取整时，向上取值</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/DL33.png" alt></p><p>当填充方式为VALID时，无法取整时，向上取值</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/DL34.png" alt></p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/DL35.png" alt></p><p>卷积向下取整，池化向上取整</p><p>例：当卷积层100个filter，5*5，步长为1，零填充是2时。输入[28,28,1]大小的图像，输出[26,26,100]的图像。</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/DL36.png" alt></p><p>池化层：通过特征后稀疏参数来减少学习的参数，降低网络的复杂度（最大池化和平均值化）</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/DL37.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;​    感知机：有n个输入数据，通过权重与各数据之间的计算和，比较激活函数结果，得出输出。感知机是解决分类问题。&lt;/p&gt;
&lt;p&gt;神经网络的基本组成包括输入层、隐藏层、输出层。卷积神经网络的特点在于隐藏层分为卷积层和池化层。&lt;/p&gt;
&lt;p&gt;神经网络的种类：&lt;/p&gt;
&lt;p&gt;&lt;
      
    
    </summary>
    
      <category term="python" scheme="http://yoursite.com/categories/python/"/>
    
      <category term="深度学习" scheme="http://yoursite.com/categories/python/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="深度学习（3）" scheme="http://yoursite.com/categories/python/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%EF%BC%883%EF%BC%89/"/>
    
    
      <category term="深度学习" scheme="http://yoursite.com/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>深度学习（2）</title>
    <link href="http://yoursite.com/2019/08/09/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%EF%BC%882%EF%BC%89/"/>
    <id>http://yoursite.com/2019/08/09/深度学习（2）/</id>
    <published>2019-08-09T04:53:25.000Z</published>
    <updated>2019-08-09T05:03:13.437Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数据读取"><a href="#数据读取" class="headerlink" title="数据读取"></a>数据读取</h2><p>通过线程和队列提高速度。可以边取数据边训练</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/DL19.png" alt></p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/DL20.png" alt></p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/DL@1.png" alt></p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/DL21.png" alt></p><h2 id="模型的保存和加载"><a href="#模型的保存和加载" class="headerlink" title="模型的保存和加载"></a>模型的保存和加载</h2><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/DL22.png" alt></p><p>模型保存：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/DL23.png" alt></p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/DL24.png" alt></p><p>模型加载：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/DL25.png" alt></p><h2 id="添加权重参数、损失值等的变化"><a href="#添加权重参数、损失值等的变化" class="headerlink" title="添加权重参数、损失值等的变化"></a>添加权重参数、损失值等的变化</h2><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/DL26.png" alt></p><p>首先收集变量：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/DL27.png" alt></p><p>而后在会话中运行：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/DL28.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;数据读取&quot;&gt;&lt;a href=&quot;#数据读取&quot; class=&quot;headerlink&quot; title=&quot;数据读取&quot;&gt;&lt;/a&gt;数据读取&lt;/h2&gt;&lt;p&gt;通过线程和队列提高速度。可以边取数据边训练&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubuserc
      
    
    </summary>
    
      <category term="python" scheme="http://yoursite.com/categories/python/"/>
    
      <category term="深度学习" scheme="http://yoursite.com/categories/python/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="深度学习（2）" scheme="http://yoursite.com/categories/python/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%EF%BC%882%EF%BC%89/"/>
    
    
      <category term="深度学习" scheme="http://yoursite.com/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>深度学习（1）</title>
    <link href="http://yoursite.com/2019/08/09/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%EF%BC%881%EF%BC%89/"/>
    <id>http://yoursite.com/2019/08/09/深度学习（1）/</id>
    <published>2019-08-09T04:17:39.000Z</published>
    <updated>2019-08-09T04:52:39.127Z</updated>
    
    <content type="html"><![CDATA[<h2 id="tensorflow基本知识"><a href="#tensorflow基本知识" class="headerlink" title="tensorflow基本知识"></a>tensorflow基本知识</h2><p>在tensorflow中把数据称为张量（tensor）。</p><p>张量的阶：相当于数组的维度。    </p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/DL1.png" alt></p><p>张量的属性：graph、op、name、shape</p><p>tensorflow中张量形状分为动态形状和静态形状，其在于有没有生成一个新的张量数据。静态形状的修改不能跨维度修改</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/DL2.png" alt></p><p>把操作称为节点（OP），所有操作都是一个OP。</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/DL3.png" alt></p><p>整个程序的结构称为图（graph）</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/DL5.png" alt></p><p>运算程序的图称为会话（Session）。一次只能运行一个图</p><p>会话的作用：1、运行图的结构 2、分配资源运算 3、掌握资源</p><p>会话需要进行资源释放，需要run后进行close。否则可以使用with作为上下文管理器</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/DL6.png" alt></p><p>可以在会话当中指定图去运行</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/DL7.png" alt></p><p>sess.run(fetches，feed_dict=None,graph=None)启动整个图。</p><p>用来运行op和计算tensor</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/DL9.png" alt></p><p>feed_dict常与placeholder(占位符)一起使用</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/20190809123839.png" alt></p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/DL8.png" alt></p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/DL10.png" alt></p><p>变量：tensorflow中的变量也是一种op，是一种特殊的张量能够进行存储持久化，它的值就是张量，默认被训练。其中有个trainable参数默认为True，如果改为False，变量将不再变化。</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/DL11.png" alt></p><h2 id="tf-reduce-mean"><a href="#tf-reduce-mean" class="headerlink" title="tf.reduce_mean()"></a>tf.reduce_mean()</h2><p>函数用于计算张量tensor沿着指定的数轴（tensor的某一维度）上的的平均值，主要用作降维或者计算tensor（图像）的平均值。</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/DL12.png" alt></p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/DL13.png" alt></p><p>如果想设置为原来向量的维度，keep_dims=True。</p><h2 id="图的可视化（tensorboard）"><a href="#图的可视化（tensorboard）" class="headerlink" title="图的可视化（tensorboard）"></a>图的可视化（tensorboard）</h2><p>首先通过pip安装，而后在会话中进行写入事件。</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/DL14.png" alt></p><p>最后在命令行启动</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/DL15.png" alt></p><p>双引号中间填绝对路径，注意不要出现中文和空格。</p><h2 id="变量作用域："><a href="#变量作用域：" class="headerlink" title="变量作用域："></a>变量作用域：</h2><p>让模型更直观的显示。</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/DL16.png" alt></p><h2 id="深度学习中的线性回归："><a href="#深度学习中的线性回归：" class="headerlink" title="深度学习中的线性回归："></a>深度学习中的线性回归：</h2><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/DL17.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;tensorflow基本知识&quot;&gt;&lt;a href=&quot;#tensorflow基本知识&quot; class=&quot;headerlink&quot; title=&quot;tensorflow基本知识&quot;&gt;&lt;/a&gt;tensorflow基本知识&lt;/h2&gt;&lt;p&gt;在tensorflow中把数据称为张量（te
      
    
    </summary>
    
      <category term="python" scheme="http://yoursite.com/categories/python/"/>
    
      <category term="深度学习" scheme="http://yoursite.com/categories/python/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="深度学习（1）" scheme="http://yoursite.com/categories/python/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%EF%BC%881%EF%BC%89/"/>
    
    
      <category term="深度学习" scheme="http://yoursite.com/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>机器学习（2）</title>
    <link href="http://yoursite.com/2019/08/09/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%882%EF%BC%89/"/>
    <id>http://yoursite.com/2019/08/09/机器学习（2）/</id>
    <published>2019-08-09T03:48:50.000Z</published>
    <updated>2019-08-09T04:07:48.826Z</updated>
    
    <content type="html"><![CDATA[<h2 id="模型的保存和加载"><a href="#模型的保存和加载" class="headerlink" title="模型的保存和加载"></a>模型的保存和加载</h2><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/ML40.png" alt></p><p>joblib.dump():保存模型，第一个参数是估计器，第二个参数是保存模型的目录。模型的文件格式是pkl。</p><p>joblib.load()：读取模型。参数是模型的目录</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/ML56.png" alt></p><h2 id="线性回归"><a href="#线性回归" class="headerlink" title="线性回归"></a>线性回归</h2><p>线性回归通过一个或多个自变量和因变量之间进行建模的回归分析，其中可以为一个或多个自变量之间的线性组合</p><p>公式:h(w)=w0+w1x+w2x2+…</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/ML42.png" alt></p><p>正规方程和梯度下降的性能评估：均方误差</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/ML43.png" alt></p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/ML45.png" alt></p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/ML44.png" alt></p><p>过拟合：一个假设在训练数据上能够获得比其他假设更好的拟合，但是在训练数据外的数据集上却不能很好地拟合数据，此时认为这个假设出现了过拟合的现象。(模型过于复杂)</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/ML46.png" alt></p><p>解决方法：正则化。用岭回归实现</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/ML47.png" alt></p><p>欠拟合：一个假设在训练数据上不能获得更好的拟合，但是在训练数据外的数据集上也不能很好地拟合数据。此时认为这个假设出现了欠拟合的现象。(模型过于简单) 解决办法是添加数据的特征数量。</p><h2 id="分类算法-逻辑回归"><a href="#分类算法-逻辑回归" class="headerlink" title="分类算法-逻辑回归"></a>分类算法-逻辑回归</h2><p>解决二分类问题</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/ML48.png" alt></p><p>penalty是正则化的方式是l2，C是正则化力度</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/ML49.png" alt></p><h2 id="k—means"><a href="#k—means" class="headerlink" title="k—means"></a>k—means</h2><p>k代表数据划分为几个类别</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/ML50.png" alt></p><p>聚类评估标准：轮廓系数，范围在[-1,1]越接近1，效果越好</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/ML51.png" alt></p><h2 id="精确率和召回率"><a href="#精确率和召回率" class="headerlink" title="精确率和召回率"></a>精确率和召回率</h2><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/ML52.png" alt></p><p>分类模型评估API：F1-score,反应了模型的稳健性</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/ML53.png" alt></p><p>模型选择和调优：1、交叉验证 2、网格搜索</p><p>交叉验证为了让被评估的模型更加准确可信</p><p>网格搜索是用来调参数的。通常情况下，有很多参数是需要手动指定的（如k-近邻算法的k）但是手动过于繁杂。所以需要对模型预设几种超参数组合，每组超参数都采用交叉验证来进行评估。</p><p>sklearn.model_Selection.GridSearchCV</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/ML54.png" alt></p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/ML55.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;模型的保存和加载&quot;&gt;&lt;a href=&quot;#模型的保存和加载&quot; class=&quot;headerlink&quot; title=&quot;模型的保存和加载&quot;&gt;&lt;/a&gt;模型的保存和加载&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Br
      
    
    </summary>
    
      <category term="python" scheme="http://yoursite.com/categories/python/"/>
    
      <category term="机器学习" scheme="http://yoursite.com/categories/python/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="机器学习（2）" scheme="http://yoursite.com/categories/python/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%882%EF%BC%89/"/>
    
    
      <category term="机器学习" scheme="http://yoursite.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>机器学习（1）</title>
    <link href="http://yoursite.com/2019/08/09/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%881%EF%BC%89/"/>
    <id>http://yoursite.com/2019/08/09/机器学习（1）/</id>
    <published>2019-08-09T03:22:57.000Z</published>
    <updated>2019-08-09T03:48:20.778Z</updated>
    
    <content type="html"><![CDATA[<h2 id="机器学习算法分类"><a href="#机器学习算法分类" class="headerlink" title="机器学习算法分类"></a>机器学习算法分类</h2><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/20190809112544.png" alt></p><p>区分监督学习和非监督学习的方法：看是否有标准答案。无监督学习无标准答案，只有特征值。</p><p>区分分类问题和回归问题的方法:目标值是否是离散型。目标值是离散型，则是分类问题。目标值是连续型，则是回归问题。</p><h2 id="数据分割"><a href="#数据分割" class="headerlink" title="数据分割"></a>数据分割</h2><p>模型=算法+数据    数据分为训练集和测试集</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/ML24.png" alt></p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/ML25.png" alt></p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/ML26.png" alt></p><p>fit_transform=fit+transform：fit做的是计算平均值和标准差，transform做的是转化</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/ML27.png" alt></p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/ML28.png" alt></p><h2 id="分类算法-k近邻算法-KNN-："><a href="#分类算法-k近邻算法-KNN-：" class="headerlink" title="分类算法-k近邻算法(KNN)："></a>分类算法-k近邻算法(KNN)：</h2><p>如果一个样本在特征空间中的k个最相似(即特征空间中最邻近)的样本中的大多数属于某一个类别，则该样本也属于这个类别。</p><p>如何求距离：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/ML29.png" alt></p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/ML30.png" alt></p><p>k值取很小，容易受异常点影响</p><p>k值取很大,容易受k值数量的波动</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/ML31.png" alt></p><h2 id="分类算法—朴素贝叶斯"><a href="#分类算法—朴素贝叶斯" class="headerlink" title="分类算法—朴素贝叶斯"></a>分类算法—朴素贝叶斯</h2><p>朴素代表特征独立,不需要调参。这是基于概率的预测</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/ML39.png" alt></p><p>这里的C代表类别，W代表特征。</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/ML33.png" alt></p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/ML32.png" alt></p><h2 id="决策树"><a href="#决策树" class="headerlink" title="决策树"></a>决策树</h2><p>信息熵：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/ML34.png" alt></p><p>信息增益：就是熵和特征条件熵的差</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/ML35.png" alt></p><p>随机变量的不确定性（熵）越小，信息增益越大，这个特征的表现就越好</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/ML36.png" alt></p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/ML37.png" alt></p><p>随机森林：随机森林是一个包含多个决策树的分类器，并且其输出的类别是由个别树输出的类别的众数而定。</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/ML38.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;机器学习算法分类&quot;&gt;&lt;a href=&quot;#机器学习算法分类&quot; class=&quot;headerlink&quot; title=&quot;机器学习算法分类&quot;&gt;&lt;/a&gt;机器学习算法分类&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Br
      
    
    </summary>
    
      <category term="python" scheme="http://yoursite.com/categories/python/"/>
    
      <category term="机器学习" scheme="http://yoursite.com/categories/python/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="机器学习（1）" scheme="http://yoursite.com/categories/python/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%881%EF%BC%89/"/>
    
    
      <category term="机器学习" scheme="http://yoursite.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>特征工程</title>
    <link href="http://yoursite.com/2019/08/09/%E7%89%B9%E5%BE%81%E5%B7%A5%E7%A8%8B/"/>
    <id>http://yoursite.com/2019/08/09/特征工程/</id>
    <published>2019-08-09T02:53:28.000Z</published>
    <updated>2019-08-12T01:18:53.519Z</updated>
    
    <content type="html"><![CDATA[<p>​    前些天我把python的处理图像的库——opencv总结了一下，但这终究是传统方法处理图像。现在都是用深度学习网络处理图像。所以，在学深度学习之前，我看了些机器学习的知识。但在看机器学习的算法前，我们先来看看特征工程。</p><p>特征工程三大知识：特征抽取、特征预处理、特征降维。</p><h2 id="特征抽取"><a href="#特征抽取" class="headerlink" title="特征抽取"></a>特征抽取</h2><p>字典特征抽取，把数据中的以字符串标记的数据转化为one-hot编码。</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/ML1.png" alt></p><p>由上面代码可得下面的稀疏（sparse）矩阵：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/ML2.png" alt></p><p>将稀疏矩阵转为矩阵：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/ML3.png" alt></p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/ML4.png" alt></p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/ML6.png" alt></p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/ML7.png" alt></p><p>将矩阵转化为字典：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/ML8.png" alt></p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/ML9.png" alt></p><p>文本特征抽取：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/ML10.png" alt></p><p>和字典特征抽取不一样的是CountVectorizer没有sparse参数，只能通过矩阵的toarray转化为数组</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/ML12.png" alt></p><p>可得：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/ML11.png" alt></p><p><strong>注意：单个字母不统计。因为单个英文字母没有依据</strong></p><p>如果文本是中文，根据需要的词频给文本添加空格。同样，单个字无法统计</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/ML13.png" alt></p><p>利用jieba分词对数据进行one-hot编码：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/ML14.png" alt></p><p>TF-IDF特征抽取：用以评估一个词对于一个文件集或一个语料库中的其中一份文件的重要程度</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/ML15.png" alt></p><h2 id="特征预处理"><a href="#特征预处理" class="headerlink" title="特征预处理"></a>特征预处理</h2><p>数据归一化处理：通过对原始数据进行交换把数据映射到（默认为[0,1]）之间</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/ML16.png" alt></p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/ML17.png" alt></p><p>归一化缺点：注意在特定场景最大值最小值是变化的。另外，最大值与最小值非常容易受异常点的影响，所以这种方法的鲁棒性差，只适合传统精确小数据场景。</p><p>数据标准化处理:通过对原始数据进行变换把数据变换到均值为0，方差为1的范围。</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/ML18.png" alt></p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/ML19.png" alt></p><p>标准化总结：在已有样本足够多的情况下比较稳定，适合现代嘈杂大数据场景</p><p>缺失值处理方法:</p><p>删除：如果每列或者行数据缺失值达到一定比例时，建议放弃整行或者整列</p><p>插补：可以通过缺失值每行或者每列的平均值、中位数来填充</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/ML20.png" alt></p><h2 id="数据降维："><a href="#数据降维：" class="headerlink" title="数据降维："></a>数据降维：</h2><p>减少特征的数量。这里的维度代表特征的个数。两种方法：1.特征选择 2.主成分分析</p><p>特征选择：特征选择就是单纯地从提取到的所有特征中选择部分特征作为训练集特征，特征在选择前和选择后可以改变值、也不改变值。但是选择后的特征维数肯定比选择前小。主要方法：Filter（过滤式）、Embedded（嵌入式）、Wrapper（包裹式）</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/ML21.png" alt></p><p>主成分分析：PCA技术，PCA是一种分析、简化数据集的技术。特征数达到数百才会使用</p><p>目的：是数据维数压缩，尽可能降低原数据的维数，损失少量信息</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/ML22.png" alt></p><p>PCA语法：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/ML23.png" alt></p><p>n_components取值可以是小数和整数：小数的取值范围是0-1，代表降维后的维度是原本维度的0-1倍数，整数的值是降维降几个维。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;​    前些天我把python的处理图像的库——opencv总结了一下，但这终究是传统方法处理图像。现在都是用深度学习网络处理图像。所以，在学深度学习之前，我看了些机器学习的知识。但在看机器学习的算法前，我们先来看看特征工程。&lt;/p&gt;
&lt;p&gt;特征工程三大知识：特征抽取、特
      
    
    </summary>
    
      <category term="python" scheme="http://yoursite.com/categories/python/"/>
    
      <category term="机器学习" scheme="http://yoursite.com/categories/python/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="特征工程" scheme="http://yoursite.com/categories/python/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E7%89%B9%E5%BE%81%E5%B7%A5%E7%A8%8B/"/>
    
    
      <category term="机器学习" scheme="http://yoursite.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>opencv(7)</title>
    <link href="http://yoursite.com/2019/08/09/opencv-7/"/>
    <id>http://yoursite.com/2019/08/09/opencv-7/</id>
    <published>2019-08-09T02:33:14.000Z</published>
    <updated>2019-08-09T02:49:40.038Z</updated>
    
    <content type="html"><![CDATA[<h2 id="直方图"><a href="#直方图" class="headerlink" title="直方图"></a>直方图</h2><p>横坐标：图像中各个像素的灰度级</p><p>纵坐标：具有该灰度级的像素个数</p><p>归一化直方图：</p><p>横坐标：图像中各个像素的灰度级</p><p>纵坐标：出现这个灰度级的概率</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/opencv96.png" alt></p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/opencv97.png" alt></p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/opencv98.png" alt></p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/opencv99.png" alt></p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/opencv100.png" alt></p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/opencv101.png" alt></p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/opencv102.png" alt></p><p>掩膜：通过掩膜可以将一张图的某块区域的直方图画出来</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/opencv103.png" alt></p><p>直方图均值化：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/opencv104.png" alt></p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/opencv105.png" alt></p><p>注意:用cv2.equalizeHist进行直方图均衡化处理时，对彩色图像进行处理时，分通道进行。灰度图像直接均衡化</p><p>利用CLAHE有限对比适应性直方图均衡化，对彩色图像也是分通道进行。灰度图像直接均衡化。</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/opencv106.png" alt></p><h2 id="背景建模："><a href="#背景建模：" class="headerlink" title="背景建模："></a>背景建模：</h2><p>以高斯混合模型为基础的背景/前景分割算法</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/opencv107.png" alt></p><p>apply可以得到前景的掩膜</p><h2 id="傅里叶变换"><a href="#傅里叶变换" class="headerlink" title="傅里叶变换"></a>傅里叶变换</h2><p>补  。。。。。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;直方图&quot;&gt;&lt;a href=&quot;#直方图&quot; class=&quot;headerlink&quot; title=&quot;直方图&quot;&gt;&lt;/a&gt;直方图&lt;/h2&gt;&lt;p&gt;横坐标：图像中各个像素的灰度级&lt;/p&gt;
&lt;p&gt;纵坐标：具有该灰度级的像素个数&lt;/p&gt;
&lt;p&gt;归一化直方图：&lt;/p&gt;
&lt;p&gt;横坐标：图
      
    
    </summary>
    
      <category term="python" scheme="http://yoursite.com/categories/python/"/>
    
      <category term="opencv" scheme="http://yoursite.com/categories/python/opencv/"/>
    
      <category term="opencv(7)" scheme="http://yoursite.com/categories/python/opencv/opencv-7/"/>
    
    
      <category term="视觉处理" scheme="http://yoursite.com/tags/%E8%A7%86%E8%A7%89%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>opencv(6)</title>
    <link href="http://yoursite.com/2019/08/08/opencv-6/"/>
    <id>http://yoursite.com/2019/08/08/opencv-6/</id>
    <published>2019-08-08T07:03:02.000Z</published>
    <updated>2019-08-09T01:51:38.877Z</updated>
    
    <content type="html"><![CDATA[<h2 id="特征提取"><a href="#特征提取" class="headerlink" title="特征提取"></a>特征提取</h2><p>图像特征：可以表达图像中对象的主要信息、并且以此为依据可以从其他未知图像中检测出相似或者相同图像。</p><p>常见的图像特征：边缘、角点、纹理</p><p>角点检测：cv2.cornerHarris()</p><p>img:输入图像</p><p>blockSize：角点检测中要考虑的领域大小</p><p>ksize：Sobel求导中使用的窗口大小</p><p>k：方程参数，参数为[0.04，0.06]</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/opencv83.png" alt></p><p>亚像素级的角点检测：红色是原先的角点，绿色像素是修正后的像素</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/opencv84.png" alt></p><p>适合于跟踪的角点检测：cv2.goodFeaturesToTrack():</p><p>输入灰度图像、检测的角点数目、设置角点的质量水平，0-1之间，低于这个数的都会被忽略、设置两个角点间的最短欧式距离。</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/opencv85.png" alt></p><p>SIFT尺度不变特征变换匹配算法：</p><p>cv2.xfeatures2d.SIFT_create()：创建sift特征器</p><p>sift.detect()可以在图像找到关键点。如果想在图像的特定区域搜索，可以创建一个掩膜图像作为参数。属性如下：</p><p>pt：表示图像中关键点的x坐标和y坐标</p><p>size：表示特征的直径</p><p>angle：表示特征的方向</p><p>response：表示关键点强度</p><p>octave：表示特征所在金字塔的层级</p><p>class_id：表示关键点的ID</p><p>sift.compute():计算关键点的描述符，在sift.detect后使用。</p><p>sift.detectAndCompute()：直接找到关键点并计算出描述符</p><p>cv2.drawKeypoints():</p><p>image:原始图像</p><p>keypoints：特征点向量</p><p>outimage：特征点绘制的画布图像，可以是原图像</p><p>color：绘制的特征点颜色，可以是原图像。</p><p>flags：五种绘制模式：</p><p>DRAW_MATCHES_FLAGS_DRAW_RICH_KEYPOINTS:就会绘制代表关键点大小的圆圈甚至可以绘制除关键点的方向。 </p><p>DEFAULT：只绘制特征点的坐标点,显示在图像上就是一个个小圆点,每个小圆点的圆心坐标都是特征点的坐标。 </p><p>DRAW_OVER_OUTIMG：函数不创建输出的图像,而是直接在输出图像变量空间绘制,要求本身输出图像变量就是一个初始化好了的,size与type都是已经初始化好的变量 </p><p>NOT_DRAW_SINGLE_POINTS：单点的特征点不被绘制 </p><p>DRAW_RICH_KEYPOINTS：绘制特征点的时候绘制的是一个个带有方向的圆,这种方法同时显示图像的坐标,size，和方向,是最能显示特征的一种绘制方式</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/opencv86.png" alt></p><p>SURF：加速稳健特征算法，加快版的SIFT。与SIFT类似</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/opencv87.png" alt></p><p>BRIEF:这是一种特征描述符，他不提供查找特征的方法。所以我们需要使用其他的特征检测器。例如：SIFT或SURF。推荐使用STAR。</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/opencv88.png" alt></p><p>orb检测：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/opencv89.png" alt></p><p>bf暴力匹配：</p><p>cv2.BFMatcher()：创建一个BFMatcher对象。参数：</p><p>​     normType：指定使用的距离测试类型。默认值为cv2.NORM_L2。cv2.NORM_L1也行。这两种适用于SIFT和SURF。对于ORB,BRIEF，应使用cv2.NORM_HAMMING。如果VTA_K==3或4，normType应设置为cv2.NORM_HAMMING2。</p><p>​     crossCheck：默认为False。如果设置为True，匹配条件就会更加严格。</p><p>BFMatcher对象具有两个方法：match()和knnMatch()。第一种方法会返回最佳匹配，第二个方法为每个关键点返回k个最佳匹配（降序排列后取前k个）。</p><p>cv2.drawMatches cv2.drawMatchsKnn：就像使用 cv2.drawKeypoints() 绘制关点一样我们可以使用 cv2.drawMatches()来绘制匹配的点。它会将两幅图像先水平排列然后在最佳匹配的点之间绘制直线从原图像到目标图像。如果前面使用的是BFMatcher.knnMatch()现在我们可以使用函数 cv2.drawMatchsKnn 为每个关键点和它的 k 个最佳匹配点绘制匹配线。如果 k 等于 2就会为每个关键点绘制两条最佳匹配直线。如果我们选择性绘制就给函数传入一个掩模。</p><p> 对ORB描述符进行暴力匹配：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/opencv90.png" alt></p><p>match=bf.match(des1，des2)：返回值是一个DMatch对象列表。具有以下属性：</p><p> DMatch.distance - 描述符之间的距离。越小越好。 </p><p>• DMatch.trainIdx - 目标图像中描述符的索引。</p><p> • DMatch.queryIdx - 查询图像中描述符的索引。</p><p> • DMatch.imgIdx - 目标图像的索引</p><p>对SIFT描述符进行暴力匹配：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/opencv91.png" alt></p><p>FLANN匹配器：</p><p>cv2.FlannBasedMatcher( [, indexParams[, searchParams]] )</p><p>indexParams：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/opencv92.png" alt></p><p>searchParams：</p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/opencv93.png" alt></p><p><img src="https://raw.githubusercontent.com/Brickexperts/Figurebed/master/opencv94.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;特征提取&quot;&gt;&lt;a href=&quot;#特征提取&quot; class=&quot;headerlink&quot; title=&quot;特征提取&quot;&gt;&lt;/a&gt;特征提取&lt;/h2&gt;&lt;p&gt;图像特征：可以表达图像中对象的主要信息、并且以此为依据可以从其他未知图像中检测出相似或者相同图像。&lt;/p&gt;
&lt;p&gt;常见的图像
      
    
    </summary>
    
      <category term="python" scheme="http://yoursite.com/categories/python/"/>
    
      <category term="opencv" scheme="http://yoursite.com/categories/python/opencv/"/>
    
      <category term="opencv(6)" scheme="http://yoursite.com/categories/python/opencv/opencv-6/"/>
    
    
      <category term="视觉处理" scheme="http://yoursite.com/tags/%E8%A7%86%E8%A7%89%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
</feed>
